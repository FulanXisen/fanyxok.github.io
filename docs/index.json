[{"content":"32-bit 表示一个单精度浮点数 float\n$V=(-1)^s \\times M \\times 2^E$ 32-bit 分为3部分： S, E, M\nS: 符号位，1bit，0 表示正数， -1 表示负数 E: 指数位，8bit，取值[-127, 128]. M: 尾数位，23bit，取值[0, $2^{23}-1$]. 指数的底固定为2，指数有正数也有负数，但指数部分没有符号位，取一个中间值，小于中间值的表示负数，等于中间值的表示0，大于中间值的表示正数，中间值的定义如下：Bias=$2^{k-1}$-1, k表示E的bit数。实际的E为E-Bias.\n尾数部分隐藏了小数点前的1，实际为1.M。M转换为十进制从高位开始计算： $1+b_{22}\\times\\frac{1}{2}+b_{21}\\times\\frac{1}{4}+\u0026hellip;+b_{0}\\times\\frac{1}{2^{23}}$\n规格化的表示，E不是全0，也不是全1，M任意取值\nE全为0时，表示+0.0, -0.0和接近0.0的值\nE全为1，M全为0时，表示无穷，符号位区分正无穷和负无穷\nE全为1，M不全为0时，表示NaN，不是一个数。\n","permalink":"https://YuXinFan.github.io/posts/ieee745/","summary":"32-bit 表示一个单精度浮点数 float\n$V=(-1)^s \\times M \\times 2^E$ 32-bit 分为3部分： S, E, M\nS: 符号位，1bit，0 表示正数， -1 表示负数 E: 指数位，8bit，取值[-127, 128]. M: 尾数位，23bit，取值[0, $2^{23}-1$]. 指数的底固定为2，指数有正数也有负数，但指数部分没有符号位，取一个中间值，小于中间值的表示负数，等于中间值的表示0，大于中间值的表示正数，中间值的定义如下：Bias=$2^{k-1}$-1, k表示E的bit数。实际的E为E-Bias.\n尾数部分隐藏了小数点前的1，实际为1.M。M转换为十进制从高位开始计算： $1+b_{22}\\times\\frac{1}{2}+b_{21}\\times\\frac{1}{4}+\u0026hellip;+b_{0}\\times\\frac{1}{2^{23}}$\n规格化的表示，E不是全0，也不是全1，M任意取值\nE全为0时，表示+0.0, -0.0和接近0.0的值\nE全为1，M全为0时，表示无穷，符号位区分正无穷和负无穷\nE全为1，M不全为0时，表示NaN，不是一个数。","title":"IEEE745浮点数表示法"},{"content":"AES 对称密钥加密中最流行的算法之一, 除加密以外还可以用于构建消息认证码, 伪随机函数等密码工具\nAES的区块长度固定为128比特，密钥长度则可以是128，192或256比特\n分组密码工作模式 使用同一个区块密码密钥对多于一块的数据进行加密\n区块密码自身只能加密长度等于密码区块长度的单块数据，若要加密变长数据，则数据必须先被划分为一些单独的密码块\n最后一块数据也需要使用合适填充方式将数据扩展到符合密码块大小的长度\n一种工作模式描述了加密每一数据块的过程，并常常使用基于一个通常称为初始化向量的附加输入值以进行随机化，以保证安全。\n初始化向量IV 许多工作模式中用于将加密随机化的一个位块，由此即使同样的明文被多次加密也会产生不同的密文，避免了较慢的重新产生密钥的过程。\n初始化向量与密钥相比有不同的安全性需求，因此IV通常无须保密，然而在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个IV. 对于CBC和CFB，重用IV会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。 对于OFB和CTR而言，重用IV会导致完全失去安全性。\n在CBC模式中，IV在加密时必须是无法预测的. SSL2.0使用的采用上一个消息的最后一块密文作为下一个消息的IV，是不安全的\nPadding ECB和CBC需要最后一块在加密前进行填充\n在明文的最后填充空字符以使其长度为块长度的整数倍 在数据后添加一个1位，再添加足够的0位直到满足块长度的要求 添加一个值为128的字节（十六进制的80），再以0字节填满最后一个块 向最后一个块填充n个值均为n的字节 密文窃取 等等 常用模式 电子密码本（ECB） 需要加密的消息按照块密码的块大小被分为数个块，并对每个块进行独立加密。\n缺点在于同样的明文块会被加密成相同的密文块；它不能很好的隐藏数据模式。在某些场合，这种方法不能提供严格的数据保密性，因此并不推荐用于密码协议中。\n易受到重放攻击的影响，因为每个块是以完全相同的方式解密的.\n密码块链接（CBC） 每个明文块先与前一个密文块进行异或后，再进行加密. 为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。\n主要缺点在于加密过程是串行的，无法被并行化，而且消息必须被填充到块大小的整数倍。在解密时，从两个邻接的密文块中即可得到一个明文块。因此，解密过程可以被并行化.\n填充密码块链接（PCBC） 每个明文块先与前一个明文块和密文块进行异或后再进行加密, 互换两个邻接的密文块不会对后续块的解密造成影响\n密文反馈（CFB，Cipher feedback） 类似于CBC，可以将块密码变为自同步的流密码；工作过程亦非常相似，CFB的解密过程几乎就是颠倒的CBC的加密过程\n输出反馈模式（Output feedback, OFB） 将块密码变成同步的流密码。它产生密钥流的块，然后将其与明文块进行异或，得到密文。 与其它流密码一样，密文中一个位的翻转会使明文中同样位置的位也产生翻转。这种特性使得许多错误校正码，例如奇偶校验位，即使在加密前计算，而在加密后进行校验也可以得出正确结果。 每个使用OFB的输出块与其前面所有的输出块相关，因此不能并行化处理。然而，由于明文和密文只在最终的异或过程中使用，因此可以事先对IV进行加密，最后并行的将明文或密文进行并行的异或处理。\n计数器模式（CTR） CTR模式的特征类似于OFB，但它允许在解密时进行随机存取。由于加密和解密过程均可以进行并行处理，CTR适合运用于多处理器的硬件上。\n其他 消息认证码（MAC）通常由块密码得到，例如CBC-MAC（英语：CBC-MAC），OMAC（英语：One-key_MAC）和PMAC（英语：PMAC_(cryptography)）。\n认证加密也采用块密码作为其中的一部，其同时使用加密和MAC以提供保密性和数据完整性，例如IAPM（英语：IAPM_(mode)），CCM（英语：CCM_mode），CWC（英语：CWC_mode），EAX（英语：EAX_mode），GCM（英语：Galois/Counter_Mode）和OCB（英语：OCB_mode）。\n","permalink":"https://YuXinFan.github.io/posts/aes/","summary":"AES 对称密钥加密中最流行的算法之一, 除加密以外还可以用于构建消息认证码, 伪随机函数等密码工具\nAES的区块长度固定为128比特，密钥长度则可以是128，192或256比特\n分组密码工作模式 使用同一个区块密码密钥对多于一块的数据进行加密\n区块密码自身只能加密长度等于密码区块长度的单块数据，若要加密变长数据，则数据必须先被划分为一些单独的密码块\n最后一块数据也需要使用合适填充方式将数据扩展到符合密码块大小的长度\n一种工作模式描述了加密每一数据块的过程，并常常使用基于一个通常称为初始化向量的附加输入值以进行随机化，以保证安全。\n初始化向量IV 许多工作模式中用于将加密随机化的一个位块，由此即使同样的明文被多次加密也会产生不同的密文，避免了较慢的重新产生密钥的过程。\n初始化向量与密钥相比有不同的安全性需求，因此IV通常无须保密，然而在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个IV. 对于CBC和CFB，重用IV会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。 对于OFB和CTR而言，重用IV会导致完全失去安全性。\n在CBC模式中，IV在加密时必须是无法预测的. SSL2.0使用的采用上一个消息的最后一块密文作为下一个消息的IV，是不安全的\nPadding ECB和CBC需要最后一块在加密前进行填充\n在明文的最后填充空字符以使其长度为块长度的整数倍 在数据后添加一个1位，再添加足够的0位直到满足块长度的要求 添加一个值为128的字节（十六进制的80），再以0字节填满最后一个块 向最后一个块填充n个值均为n的字节 密文窃取 等等 常用模式 电子密码本（ECB） 需要加密的消息按照块密码的块大小被分为数个块，并对每个块进行独立加密。\n缺点在于同样的明文块会被加密成相同的密文块；它不能很好的隐藏数据模式。在某些场合，这种方法不能提供严格的数据保密性，因此并不推荐用于密码协议中。\n易受到重放攻击的影响，因为每个块是以完全相同的方式解密的.\n密码块链接（CBC） 每个明文块先与前一个密文块进行异或后，再进行加密. 为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。\n主要缺点在于加密过程是串行的，无法被并行化，而且消息必须被填充到块大小的整数倍。在解密时，从两个邻接的密文块中即可得到一个明文块。因此，解密过程可以被并行化.\n填充密码块链接（PCBC） 每个明文块先与前一个明文块和密文块进行异或后再进行加密, 互换两个邻接的密文块不会对后续块的解密造成影响\n密文反馈（CFB，Cipher feedback） 类似于CBC，可以将块密码变为自同步的流密码；工作过程亦非常相似，CFB的解密过程几乎就是颠倒的CBC的加密过程\n输出反馈模式（Output feedback, OFB） 将块密码变成同步的流密码。它产生密钥流的块，然后将其与明文块进行异或，得到密文。 与其它流密码一样，密文中一个位的翻转会使明文中同样位置的位也产生翻转。这种特性使得许多错误校正码，例如奇偶校验位，即使在加密前计算，而在加密后进行校验也可以得出正确结果。 每个使用OFB的输出块与其前面所有的输出块相关，因此不能并行化处理。然而，由于明文和密文只在最终的异或过程中使用，因此可以事先对IV进行加密，最后并行的将明文或密文进行并行的异或处理。\n计数器模式（CTR） CTR模式的特征类似于OFB，但它允许在解密时进行随机存取。由于加密和解密过程均可以进行并行处理，CTR适合运用于多处理器的硬件上。\n其他 消息认证码（MAC）通常由块密码得到，例如CBC-MAC（英语：CBC-MAC），OMAC（英语：One-key_MAC）和PMAC（英语：PMAC_(cryptography)）。\n认证加密也采用块密码作为其中的一部，其同时使用加密和MAC以提供保密性和数据完整性，例如IAPM（英语：IAPM_(mode)），CCM（英语：CCM_mode），CWC（英语：CWC_mode），EAX（英语：EAX_mode），GCM（英语：Galois/Counter_Mode）和OCB（英语：OCB_mode）。","title":"AES对称加密"},{"content":"Welcome The first post of hugo\nThis is a second header The third The fouth Fifty Six? amazing\nA math equation: \\(c^2 = a^2 + b^2\\)\nfull line equation: $$ e^e = \\pi $$\nA Table a a b b A complex latex equation $$\\begin{array}{cc} a \u0026amp; b \\\\ c \u0026amp; d \\end{array}$$\n$$\\begin{bmatrix} a \u0026amp; b \\newline c \u0026amp; d \\end{bmatrix}$$\n","permalink":"https://YuXinFan.github.io/posts/my-first-post/","summary":"Welcome The first post of hugo\nThis is a second header The third The fouth Fifty Six? amazing\nA math equation: \\(c^2 = a^2 + b^2\\)\nfull line equation: $$ e^e = \\pi $$\nA Table a a b b A complex latex equation $$\\begin{array}{cc} a \u0026amp; b \\\\ c \u0026amp; d \\end{array}$$\n$$\\begin{bmatrix} a \u0026amp; b \\newline c \u0026amp; d \\end{bmatrix}$$","title":"My First Post"},{"content":"Cyclic Group 定义 $$\\langle\\mathbb{G},q,g \\rangle$$\n\\(\\mathbb{G}=\\langle \\mathbb{Z}_{n}, \\cdot \\rangle\\)\n\\(\\mathbb{Z}_{n} \\)是一个集合, {$0$\u0026hellip;$n-1$}.\n\\(\\cdot\\)是集合中的运算符.\n对\\(\\mathbb{G}\\)中的元素$a$进行$k$次幂运算表示为\\(a^{k}=a \\cdot a \u0026hellip;\\cdot a\\), 即$k$个$a$进行$\\cdot$运算.\n若群$\\mathbb{G}$的每一个元素都是$\\mathbb{G}$的某一个固定元素$a$的幂，则称$\\mathbb{G}$为循环群.\n$q$是$\\mathbb{G}$的order, $q$的值等于$\\mathbb{G}$中元素的个数, 也记为$|\\mathbb{G}|$.\n$g$是$\\mathbb{G}$的generator(生成元), $\\mathbb{G}$中的所有元素都能由$g$通过幂运算生成.\n由群$\\mathbb{G}$, 阶$q$和生成元$g$, 即可定义一个循环群.\n如何寻找一个生成元 如果$\\mathbb{G}$有素数阶$p$, 则$\\mathbb{G}$中除了identity之外的所有元素都是$\\mathbb{G}$的生成元.\n如果$p$是素数, 则$\\mathbb{Z}_{p}^{*}$是阶为$p-1$的循环群.\n假设$\\mathbb{G}$阶非素数$p$, 可以均匀的从$\\mathbb{G}$中采样元素, 直到这个元素是一个生成元.\n$\\mathbb{G}$的阶$q$有素数因数$\\{p_{i}\\}^k_{i=1}$, 检查元素$h$是否为生成元\nfor $i = 1$ to $k$ : if $h^{q/p_{i}}=1$ return \u0026ldquo;$h$ is not a generator\u0026rdquo; return \u0026ldquo;$h$ is a generator\u0026rdquo; $\\mathbb{G}$有阶$q$,生成元$g$, 则任意一个元素可以表示为$h=g^{x}$.\n当gcd($x,q$)=1时, $h$也是$\\mathbb{G}$的一个生成元. Oblivious Transfer from Cyclic Group Reference:\nMore efficient oblivious transfer and extensions for faster secure computation\nAsharov G, Lindell Y, Schneider T, et al.\nProceedings of the 2013 ACM SIGSAC conference on Computer \u0026amp; communications security.\n以下方案基于DDH假设.\nFast Notes Input Sender and Receiver agree on $\\langle\\mathbb{G},q,g \\rangle$. Sender and Receiver agree on Hash. Sender: n个 ($x_{i}^{0}, x_{i}^{1}$) pair Receiver: n个 bit ($\\sigma_{1},\u0026hellip;,\\sigma_{n}$) Receiver do $\\alpha_{i}\\in_{R}\\mathbb{Z}_{q}$ $h_{i}\\in_{R}\\mathbb{G}$ $h_{i}^{0}= (\\sigma_{i} == 0) \\ ?\\ g^{\\alpha_{i}} : h_{i}$ $h_{i}^{1}= (\\sigma_{i} == 0) \\ ?\\ h_{i} : g^{\\alpha_{i}}$ send $n$ pair $(h_{i}^{0}, h_{i}^{1})$ to Sender. Sender do $r\\in_{R}\\mathbb{Z}_{q}$ $u=g^{r}$ $k_{i}^{0}, k_{i}^{1} = (h_{i}^{0})^{r}, (h_{i}^{1})^{r}$ $v_{i}^{0}, v_{i}^{1} = x_{i}^{0} \\oplus \\text{Hash}(k_{i}^{0}), x_{i}^{1} \\oplus \\text{Hash}(k_{i}^{1})$ send $u$ to Receiver. send n pair $(v_{i}^{0}, v_{i}^{1})$. Receiver do $k_{i}^{\\sigma_{i}} = u^{\\alpha_{i}}$ $x_{i}^{\\sigma_{i}} = v_{i}^{\\sigma_{i}} \\oplus \\text{Hash}(k_{i}^{\\sigma_{i}})$ Receiver outputs $\\{x_{i}^{\\sigma_i}\\}$, Sender has no output. Discussion $x$应当和Hash的长度保持一致, 或者小于Hash的长度, 否则$v$的头几位会泄露$x$的信息. 如果Hash的长度与$k$的长度一致, 由于$k$是$\\mathbb{G}$中的元素, $x$也应是$\\mathbb{G}$中的元素, 否则会泄露$x$的信息. 最好的情况是, S和R约定好Hash, 可以从较短的$k$中产生较长的Hash$(k)$, 那么此时也应约定好$x$的bit长度$l$. OT传输的信息长度可能会变, 也可能太长, 如果导致计算的开销过高, 或许可以通过与对称密码结合的方法, 用OT传输秘钥, 用秘钥加密$x$, 从而让Receiver获得秘钥来解密密文. 此时对称加密的秘钥长度就可以固定下来. 不过对称加密如AES本身秘钥的长度就达到了129,192和256, 或许已经超过了$\\mathbb{G}$的长度. MPC中最用的两中有限域是$prime$域和$2k$域$\\mathbb{G}_{p}$和$\\mathbb{G}_{2^k}$, 理论上来说素数域的效率会更高一些, 而2k域正好对应计算时32bit, 64bi的数据范围. ","permalink":"https://YuXinFan.github.io/posts/otandcylicgroup/","summary":"Cyclic Group 定义 $$\\langle\\mathbb{G},q,g \\rangle$$\n\\(\\mathbb{G}=\\langle \\mathbb{Z}_{n}, \\cdot \\rangle\\)\n\\(\\mathbb{Z}_{n} \\)是一个集合, {$0$\u0026hellip;$n-1$}.\n\\(\\cdot\\)是集合中的运算符.\n对\\(\\mathbb{G}\\)中的元素$a$进行$k$次幂运算表示为\\(a^{k}=a \\cdot a \u0026hellip;\\cdot a\\), 即$k$个$a$进行$\\cdot$运算.\n若群$\\mathbb{G}$的每一个元素都是$\\mathbb{G}$的某一个固定元素$a$的幂，则称$\\mathbb{G}$为循环群.\n$q$是$\\mathbb{G}$的order, $q$的值等于$\\mathbb{G}$中元素的个数, 也记为$|\\mathbb{G}|$.\n$g$是$\\mathbb{G}$的generator(生成元), $\\mathbb{G}$中的所有元素都能由$g$通过幂运算生成.\n由群$\\mathbb{G}$, 阶$q$和生成元$g$, 即可定义一个循环群.\n如何寻找一个生成元 如果$\\mathbb{G}$有素数阶$p$, 则$\\mathbb{G}$中除了identity之外的所有元素都是$\\mathbb{G}$的生成元.\n如果$p$是素数, 则$\\mathbb{Z}_{p}^{*}$是阶为$p-1$的循环群.\n假设$\\mathbb{G}$阶非素数$p$, 可以均匀的从$\\mathbb{G}$中采样元素, 直到这个元素是一个生成元.\n$\\mathbb{G}$的阶$q$有素数因数$\\{p_{i}\\}^k_{i=1}$, 检查元素$h$是否为生成元\nfor $i = 1$ to $k$ : if $h^{q/p_{i}}=1$ return \u0026ldquo;$h$ is not a generator\u0026rdquo; return \u0026ldquo;$h$ is a generator\u0026rdquo; $\\mathbb{G}$有阶$q$,生成元$g$, 则任意一个元素可以表示为$h=g^{x}$.\n当gcd($x,q$)=1时, $h$也是$\\mathbb{G}$的一个生成元. Oblivious Transfer from Cyclic Group Reference:\nMore efficient oblivious transfer and extensions for faster secure computation","title":"Oblivious Transfer and Cyclic Group"}]