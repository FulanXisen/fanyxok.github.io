[{"content":"ARM Cortex-M RTOS Context Switching 30 Oct 2019 by Chris Coleman\nMany embedded systems reach a level of complexity where having a basic set of scheduling primitives and ability to run different tasks can be helpful. The operation of switching from one task to another is known as a context switch. A Real Time Operating System (RTOS) will typically provide this functionality. Having a foundational knowledge of how the core of an RTOS works can be a valuable skill set for an embedded engineer to have.\nIn this article we will explore how context switching works on ARM Cortex-M MCUs. We will discuss how the hardware was designed to support this operation, features that impact the context switching implementation such as the Floating Point Unit (FPU), and common pitfalls seen when porting an RTOS to a platform. We will also walk through a practical example of analyzing the FreeRTOS context switcher, xPortPendSVHandler, utilizing gdb to strengthen our understanding.\nIf you’d rather listen to me present this information and see some demos in action, watch this webinar recording.\nLike Interrupt? Subscribe to get our latest posts straight to your mailbox.\nTable of Contents Cortex-M ARM MCU Features Cortex-M Operation Modes Registers Stack Pointers Context State Stacking RTOS Context Switching Demystifying the FreeRTOS Context Switcher The Port Compiling the code and launching it with GDB Context Switching Starting the FreeRTOS Scheduler Closing Reference Links Cortex-M ARM MCU Features To understand how RTOS context switching works for ARM Cortex-M MCUs, it’s critical to have foundational knowledge about the primitives the architecture provides to make it possible.\nIn this section we go through these building blocks by distilling down the information spread across the ARM Cortex-M reference manuals and the ARM Architecture Procedure Calling Standard (AAPCS)1 which defines the Application Binary Interface (ABI) a compiler must abide by for ARM.\nNOTE: If you already have a good understanding of these concepts, feel free to switch over this section (pun intended).\nCortex-M Operation Modes When a Cortex-M based MCU is running from an exception handler such as an Interrupt Service Routine (ISR), it is known as running in Handler Mode. The rest of the time the MCU runs in Thread Mode.\nThe core can operate at either a privileged or unprivileged level. Certain instructions and operations are only allowed when the software is executing as privileged. For example, unpriviledged code may not access NVIC registers. In Handler Mode, the core is always privileged. In Thread Mode, the software can execute at either level.\nSwitching Thread Mode from the unprivileged to privileged level can only happen when running from Handler Mode.\nThese different configurations enable use cases where certain application code, such as the RTOS kernel, can be better sandboxed from one another. We will cycle back to this terminology throughout the article.\nRegisters Core Registers Every Cortex-M MCU is comprised of 16, 32-bit Core Registers\nSection 5.1.1 of the AAPCS1 defines the roles and names of the registers:\nRegister Alternative Names Role in the procedure call standard r15 PC The Program Counter (Current Instruction) r14 LR The Link Register (Return Address) r13 SP The Stack Pointer r12 IP The Intra-Procedure-call scratch register r11 v8 Variable-register 8 r10 v7 Variable-register 7 r9 v6, SB, TR Variable-register 6 or Platform Register r8, r7, r6, r5, r4 v5, v4, v3, v2, v1 Variable-register 5 - Variable-register 1 r3, r2, r1, r0 a4, a3, a2, a1 Argument / scratch register 4 - Argument / scratch register 1 Fun Facts: Many compilers will accept any of the alternative names when accessing registers using assembly. For example, with GCC setting r0 to zero could be achieved with either __asm(\u0026quot;mov r0, #0\u0026quot;) or __asm(\u0026quot;mov a1, #0\u0026quot;). In the AAPCS specification, “upper case is used when the register has a fixed role in the procedure call standard” so PC is more correct than pc, which is why certain names in the table are capitalized and others are not.\nr12 Intra-Procedure-call Scratch Register The address space for ARM Cortex-M devices is 32 bits. However, it’s not possible for a branch and link (bl) instruction to jump across the entire address region (because some bits encode the instruction itself). In this situation, a jump to a function that is far away in the address space may require passing through a shim function generated by the linker known as a veneer. r12 is the only register that may be used within the veneer without needing to preserve the original state.\nr9 as Platform Register In a vast majority of applications, r9 is just used as another variable register within a function. However, the additional platform-specific use cases merit further clarification. In both of these situations the state of the register may need to be preserved across function calls.\nOne application is to use r9 as a static base (SB). Normally when code is compiled, the code is dependent on the position it runs from. That is, functions are linked together based on the fact that the code and data will always be located at a specific location. However, for some applications you may want the ability to run code from arbitrary locations. For example, maybe you want to load a function from flash into RAM for faster execution. In these situations you will need to generate Position Independent Code (PIC). When executing PIC, the address of global \u0026amp; static data needs to be looked up. These addresses are stored in a table known as the Global Offset Table. The base of this table can be stored in r9 and then functions will reference this register to look it up. For example, this behavior will be triggered for ARM Cortex-M devices when compiling with the -fpic and -msingle-pic-base compiler options.\nAnother application is to use r9 as the thread register (TR). In this situation, the register holds a pointer to the current thread-local storage context\nFloating Point (FP) registers Cortex-M4, Cortex-M7 and Cortex-M33s can implement an optional unit to natively support floating point operations, known as the Floating Point (FP) extension.\nFun fact: The FP extension is itself based off implementations originally defined for ARMv7-A and ARMv7-R architectures, known as VFPv4-D16. Consequently, you will sometimes see the implementation referred to by its legacy name, VFP extension.\nThere are technically two floating point extensions a Cortex-M device may implement, FPv4-SP \u0026amp; FPv5 but a full discussion is outside the scope of this article.\nBoth extensions expose the same set of registers for FPU operations. They can be addressed in two ways:\nAs thirty-two 32 bit (single-word) registers (s0 - s31) As sixteen 64 bit (double-word) registers (d0 - d16) where, s0 and s1 make up d0, s2 and s3 make up d1, … and so on.\nWhen a FP extension is present, there is also one special register, FPSCR, which allows for configuration and control of floating point system options.\nBy default, even if an MCU implements the FP extension, when the device is reset, the feature is disabled. To enable it, a write to the Coprocessor Access Control Register (CPACR) located at address 0xE000ED88 must take place.\nThe layout can be found in the ARMv7 Reference Manual2:\nwhere, CP10 and CP11 are used to control floating point availability. Both fields are 2 bits and must be identical to correctly configure the FPU.\nbit 1 bit 0 CP10 \u0026amp; CP11 FPU Configuration 0 0 FPU Disabled (default). Any access generates a UsageFault. 0 1 Privileged access only. Any unprivileged access generates a UsageFault. 1 0 Reserved 1 1 Privileged and unprivileged access allowed. Special Registers There’s a number of Special Registers which can be written to and read from using the Move to Special Register (MSR) and Move to Register from Special Register (MRS) instructions, respectively.\nA full discussion of all the registers is outside the scope of this article but the ARM Reference Manual documentation about the instruction itself has a great overview 2:\nThere are some special rules about the privilege level needed to read and write to the special registers worth remembering:\nExcerpt from “B5.2.2 MRS”2:\nIf unprivileged code attempts to read any stack pointer, the priority masks, or the IPSR, the read returns zero.\nExcerpt from “B5.2.3 MSR”2:\nThe processor ignores writes from unprivileged Thread mode to any stack pointer, the EPSR, the IPSR, the masks, or CONTROL. If privileged Thread mode software writes a 1 to the CONTROL.nPRIV bit, the processor switches to unprivileged Thread mode execution, and ignores any further writes to special-purpose registers. After any Thread mode transition from privileged to unprivileged execution, software must issue an ISB instruction to ensure instruction fetch correctness.\nFor context switching, one of the most important special registers is the CONTROL register. Bits in the register read-as-zero unless they are implemented. The ARMv8-M architecture3 has the largest number of optional extensions so the most complete assignment set one will see is:\nwhere\nSFPA indicates whether secure floating-point is active or inactive based on whether the bit is set or not. This is only present when the ARMv8-M Security Extension is implemented FPCA indicates whether the floating point context is active. We’ll go into detail below. SPSEL controls what stack pointer is in use. We’ll go into more detail below. nPriv controls whether or not thread mode is operating as privileged or unprivileged. When set to 1, thread mode operates as unprivileged otherwise it operates as privileged Stack Pointers The Cortex-M architecture implements two stacks known as the Main Stack (tracked in the msp register) and the Process Stack (tracked in the psp register). On reset, the MSP is always active and its initial value is derived from the first word in the vector table. When a stack pointer is “active”, its current value will be returned when the sp register is accessed.\nIn Handler Mode, the msp is always the stack which is used. In Thread Mode, the stack pointer which is used can be controlled in two ways:\nWrites of 1 to the SPSEL bit in the CONTROL register will switch from using the msp to the psp The value placed in EXC_RETURN upon exception return. We will expand on this below. Context State Stacking In our guide about ARM Cortex-M Exception Handling, we touched upon how the hardware itself implements the AAPCS1 so that interrupts can be implemented as normal C functions. Here we will expand on what that actually means.\nPer the AAPCS1, there is a certain set of registers that a function is responsible for restoring to their original value before returning to the function which called it:\nA subroutine must preserve the contents of the registers r4-r8, r10, r11 and SP (and r9 in PCS variants that designate r9 as v6).\nConversely, this means it is the responsibility of the calling function to preserve the registers not mentioned, r0 - r3, r12 and LR (r14).\nThe specification also states the “The [C]PSR is a global register” where “the N, Z, C, V and Q bits (bits 27-31) and the GE[3:0] bits (bits 16-19) are undefined on entry to or return from a public interface.” These bits convey state about recent comparisons, etc. This means it’s also the calling functions responsibility to preserve any state it needs in the register.\nThe AAPCS also imposes a requirement that “The stack must be double-word aligned.” for “public interfaces” which means when entering a function the stack should always start off 8-byte aligned.\nTaking all of these factors into account, in order for execution from an interrupt to be ABI compliant, the ARM architecture needs to align the stack and save the register state that a calling function is responsible for preserving. To accomplish this, the ARM Cortex-M core will push that context onto the stack.\nNOTE: The stack data is pushed on is the one which was in use prior to servicing the exception. So for example, if the system was in Thread Mode using the psp and exception takes place, the data will be pushed on the psp. If the core was already servicing another exception and was preempted by a higher priority exception, the data will be pushed on the msp.\nThe reference manual has a great picture of what the stack looks like after this automatic context state saving takes place:\nNOTE: On exception entry, the ARM hardware uses bit 9 of the stacked xPSR value to indicate whether 4 bytes of padding was added to align the stack on an 8 byte boundary.\nFP Extension \u0026amp; Context State Stacking When the FP Extension is in use and active, the AAPCS1 states that s16 - s31 must be preserved across subroutine calls and s0 - s15 do not need to be preserved. Additionally, similar to the PSR register, the state of the FPU needs to be preserved so the FPSCR needs to be stored as well. This means an additional 17 registers (68 bytes) need to be stacked on exception entry!\nFortunately, the folks at ARM realized this could be a performance or memory problem for some use cases so there are several really neat ways to optimize this.\nAs we mentioned above, one option is to completely disable the FPU. In this situation no state needs to be preserved.\nHowever, there’s also some fine granularity controls about how the context is preserved. These can be configured via the Floating Point Context Control Register (FPCCR) located at address 0xE000EF34:\nWith respect to Context State Stacking, the values that are interesting are:\nASPEN - When set to 1 (default), any execution of a floating point instruction will set the FPCA bit in the control register we mentioned above. LSPEN - When set to 1 (default) enables what is known as a lazy context save4. Basically what this means is on exception entry, space will be reserved on the stack for the caller saved floating point registers (s0-s15 \u0026amp; FPSCR) but the data will not actually be pushed by default. If and only if a floating point instruction is executed while in the exception, only then will the state be pushed. This is pretty sweet because it means as long as an interrupt does not use the FPU, no extra interrupt latency penalty is incurred! When the FPU is “in use” (CONTROL.FPCA=1), an extended frame will be saved by the hardware:\nNOTE: If the FPU is enabled but no floating point instructions are executed or ASPEN is disabled (i.e CONTROL.FPCA=0), only the basic frame will be saved. The ARM lazy context save application note4 explores some interesting tricks one can play based on these facts to prevent the extended frame from always needing to be allocated even when the FPU is in use.\nException Return Finally, in order for the hardware to figure out what state to restore when exiting an exception, a special value, known as EXC_RETURN needs to be loaded into the link register, lr. Typically, this will just mirror the value in the lr on exception entry. However, a different value can also be manually loaded into the register as well (i.e to change the Thread Mode stack pointer being used like we discussed above).\nOn exception entry, the ARM reference manual pseudocode for the value stored in lr gives the best description5:\nIt describes the current stack frame in use (Extended vs Basic) as well as what the active stack pointer was prior to the exception taking place.\nWhen returning from an exception, the possible values and behavior for EXC_RETURN are:\nEXC_RETURN Value Mode to Return To Stack to use 0xFFFFFFF1 Handler Mode MSP 0xFFFFFFF9 Thread Mode MSP 0xFFFFFFFD Thread Mode PSP 0xFFFFFFE1 Handler Mode (FPU Extended Frame) MSP 0xFFFFFFE9 Thread Mode (FPU Extended Frame) MSP 0xFFFFFFED Thread Mode (FPU Extended Frame) PSP RTOS Context Switching An RTOS at its cores offers several basic primitives:\nA scheduler capable of context switching between different tasks. Tasks can usually be prioritized and at a bare minimum a scheduler is usually capable of alternating between tasks when new events arrive (i.e a new accelerometer sample is available) or when the task yields its slot. Very basic Operating System primitives (such as mutexes/semaphores and a way to pass messages between tasks) Configuration operations for sandboxing different code from one another by leveraging the privilege and access control features the hardware offers. Schedulers usually come in two main varieties:\nPreemptive - A context switch while a task is “running” if something more important comes up. Cooperative - A context switch will never occur while another task is “running”. A task must explicitly yield for another task to run. Tasks must “co-operate” for everyone to get a chance to run. When an RTOS scheduler decides a different task should be run than what is currently running, it will trigger a context switch. When switching from one task to another, the “state” of the current task needs to be preserved in some way. This includes information such as the execution state of the task (i.e blocked on a mutex, sleeping, etc) and the values of the active hardware registers.\nAs we alluded to in our ARM Cortex-M Exception article, the SVCall, PendSV, and SysTick interrupts integrated into every Cortex-M device were explicitly designed to make task management simple. Consequently, the context switching logic winds up looking extremely similar regardless of the RTOS in use. So if you understand how one works, you will be able to pretty easily learn how any other one works!\nIn the sections that follow we will walk through step-by-step how the context switcher within FreeRTOS6 works for Cortex-M devices. FreeRTOS is a very popular (and open source!) RTOS found in numerous commercial products. It has a great track record and has been around since ~2003 by Real Time Engineers Ltd. In 2017 the company was acquired by Amazon, who now manages the project.\nDemystifying the FreeRTOS Context Switcher For this setup we will use:\na nRF52840-DK7 (ARM Cortex-M4F) as our development board SEGGER JLinkGDBServer8 as our GDB Server. GCC 8.3.1 / GNU Arm Embedded Toolchain as our compiler9 GNU make as our build system All the code can be found on the Interrupt Github page with more details in the README in the directory linked.\nThe example application itself is very basic: it creates a “Ping” FreeRTOS task and a “Pong” FreeRTOS task. The “Ping” task sends a message to the “Pong” task once per second and each time the event loop in a task runs, I’ve added a breakpoint instruction so we can confirm with the debugger the tasks are switching between each other.\nThe Port FreeRTOS has excellent documentation10 about creating a new project. If you are trying to port FreeRTOS to your own platform, I’d strongly recommend reading through those docs. For context, the approximate steps I followed for the minimal port to the Cortex-M4 are:\nSet up a build system and startup sequence for your MCU. Extensive details about what these steps look like can be found in our zero to main() series. Compile the core source files included in the FreeRTOS Kernel11 (tasks.c, queue.c, list.c, timers.c) Choose a “port”. A port is the platform specific files needed for the architecture in use. Since ports often wind up having assembly and assembly syntax is compiler specific there will often be ports per compiler for a given architecture. The FreeRTOS Kernel 11 already has a default port for pretty much any architecture imaginable so usually you can just choose one from there. In our case, we want a port for a Cortex-M4F which can be found in portable/GCC/ARM_CM4F/. Once you find the “port” you will need to add port.c to your compilation list. Chose a FreeRTOS heap implementation12. I went with the most basic one for the example, portable/MemMang/heap_1.c Add the port directory (in our case portable/GCC) and the root directory of the kernel as include paths to the build system. Create a FreeRTOSConfig.h13 with the configuration settings for your particular application Create some tasks (xTaskCreate), start the scheduler (vTaskStartScheduler), and you are ready to go! Compiling the code and launching it with GDB # Compile the code $ make Compiling main.c Compiling startup.c Compiling freertos_kernel/tasks.c Compiling freertos_kernel/queue.c Compiling freertos_kernel/list.c Compiling freertos_kernel/timers.c Compiling freertos_kernel/portable/GCC/ARM_CM4F/port.c Compiling freertos_kernel/portable/MemMang/heap_1.c Linking library Generated build/nrf52.elf # In one terminal, start a GDB Server $ JLinkGDBServer -if swd -device nRF52840_xxAA SEGGER J-Link GDB Server V6.52a Command Line Version # Flash the code on the NRF52 and start gdb $ arm-none-eabi-gdb-py --eval-command=\u0026quot;target remote localhost:2331\u0026quot; --ex=\u0026quot;mon reset\u0026quot; --ex=\u0026quot;load\u0026quot; --ex=\u0026quot;mon reset\u0026quot; --se=build/nrf52.elf GNU gdb (GNU Tools for Arm Embedded Processors 8-2019-q3-update) 8.3.0.20190703-git Copyright (C) 2019 Free Software Foundation, Inc. [...] Resetting target Loading section .interrupts, size 0x40 lma 0x0 Loading section .text, size 0x194d lma 0x40 Loading section .data, size 0x4 lma 0x1990 Start address 0x40, load size 6545 Transfer rate: 2130 KB/sec, 2181 bytes/write. Resetting target (gdb) Context Switching Let’s start by looking at the code that deals with context switching itself. Once we understand that, we will cycle back to how the scheduler itself is started and tasks are created.\nThe FreeRTOS scheduler works by utilizing the built in SysTick and PendSV interrupts. The SysTick is configured to fire periodically. Each time it fires, a check is performed to see if a context switch is required by calling xTaskIncrementTick:\nvoid xPortSysTickHandler( void ) { /* The SysTick runs at the lowest interrupt priority, so when this interrupt executes all interrupts must be unmasked. There is therefore no need to save and then restore the interrupt mask value as its value is already known. */ portDISABLE_INTERRUPTS(); { /* Increment the RTOS tick. */ if( xTaskIncrementTick() != pdFALSE ) { /* A context switch is required. Context switching is performed in the PendSV interrupt. Pend the PendSV interrupt. */ portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; } } portENABLE_INTERRUPTS(); } A context switch may also occur outside of this if a task decides to yield (portYIELD).\nBoth of these paths trigger the PendSV exception, where the real magic happens:\n// FreeRTOSConfig.h #define vPortSVCHandler SVC_Handler #define xPortPendSVHandler PendSV_Handler #define xPortSysTickHandler SysTick_Handler // port.c void xPortPendSVHandler( void ) { /* This is a naked function. */ __asm volatile ( \u0026quot; mrs r0, psp \\n\u0026quot; \u0026quot; isb \\n\u0026quot; \u0026quot; \\n\u0026quot; \u0026quot; ldr r3, pxCurrentTCBConst \\n\u0026quot; /* Get the location of the current TCB. */ \u0026quot; ldr r2, [r3] \\n\u0026quot; \u0026quot; \\n\u0026quot; \u0026quot; tst r14, #0x10 \\n\u0026quot; /* Is the task using the FPU context? If so, push high vfp registers. */ \u0026quot; it eq \\n\u0026quot; \u0026quot; vstmdbeq r0!, {s16-s31} \\n\u0026quot; \u0026quot; \\n\u0026quot; \u0026quot; stmdb r0!, {r4-r11, r14} \\n\u0026quot; /* Save the core registers. */ \u0026quot; str r0, [r2] \\n\u0026quot; /* Save the new top of stack into the first member of the TCB. */ \u0026quot; \\n\u0026quot; \u0026quot; stmdb sp!, {r0, r3} \\n\u0026quot; \u0026quot; mov r0, %0 \\n\u0026quot; \u0026quot; msr basepri, r0 \\n\u0026quot; \u0026quot; dsb \\n\u0026quot; \u0026quot; isb \\n\u0026quot; \u0026quot; bl vTaskSwitchContext \\n\u0026quot; \u0026quot; mov r0, #0 \\n\u0026quot; \u0026quot; msr basepri, r0 \\n\u0026quot; \u0026quot; ldmia sp!, {r0, r3} \\n\u0026quot; \u0026quot; \\n\u0026quot; \u0026quot; ldr r1, [r3] \\n\u0026quot; /* The first item in pxCurrentTCB is the task top of stack. */ \u0026quot; ldr r0, [r1] \\n\u0026quot; \u0026quot; \\n\u0026quot; \u0026quot; ldmia r0!, {r4-r11, r14} \\n\u0026quot; /* Pop the core registers. */ \u0026quot; \\n\u0026quot; \u0026quot; tst r14, #0x10 \\n\u0026quot; /* Is the task using the FPU context? If so, pop the high vfp registers too. */ \u0026quot; it eq \\n\u0026quot; \u0026quot; vldmiaeq r0!, {s16-s31} \\n\u0026quot; \u0026quot; \\n\u0026quot; \u0026quot; msr psp, r0 \\n\u0026quot; \u0026quot; isb \\n\u0026quot; \u0026quot; \\n\u0026quot; \u0026quot; \\n\u0026quot; \u0026quot; bx r14 \\n\u0026quot; \u0026quot; \\n\u0026quot; \u0026quot; .align 4 \\n\u0026quot; \u0026quot;pxCurrentTCBConst: .word pxCurrentTCB \\n\u0026quot; ::\u0026quot;i\u0026quot;(configMAX_SYSCALL_INTERRUPT_PRIORITY) ); } Let’s halt the debugger in this function and step through instruction by instruction discussing what is actually happening.\n(gdb) mon reset Resetting target (gdb) c Continuing. Program received signal SIGTRAP, Trace/breakpoint trap. prvQueuePingTask (pvParameters=\u0026lt;optimized out\u0026gt;) at main.c:33 33 __asm(\u0026quot;bkpt 1\u0026quot;); (gdb) break PendSV_Handler Breakpoint 2 at 0x1430: file freertos_kernel/portable/GCC/ARM_CM4F/port.c, line 435. (gdb) n 34 xQueueSend(xQueue, \u0026amp;ulValueToSend, 0U); (gdb) c Continuing. Breakpoint 2, PendSV_Handler () at freertos_kernel/portable/GCC/ARM_CM4F/port.c:435 435\t__asm volatile Great, we are halted on the first line of the context switcher. As we discussed above, the hardware will automatically save registers on exception entry for us. We can figure out how things are stacked by looking at the current lr value which encodes this information.\n(gdb) p/x $lr $7 = 0xfffffffd Using this info we know that the code was executing in thread mode and using the psp for it’s stack. We also know that the FPU context was not active.\nThis tells us a basic frame was saved by the hardware on the psp. We can walk up the stack using x/a with gdb to dump the register values. I’ve annotated the registers being read inline below:\n(gdb) x/a $psp // top of stack will be $r0 0x200005a0 \u0026lt;ucHeap+1096\u0026gt;:\t0x1 \u0026lt;g_pfnVectors+1\u0026gt; (gdb) \u0026lt;enter to get $r1\u0026gt; 0x200005a4 \u0026lt;ucHeap+1100\u0026gt;:\t0x200003b4 \u0026lt;ucHeap+604\u0026gt; (gdb) \u0026lt;enter to get $r2\u0026gt; 0x200005a8 \u0026lt;ucHeap+1104\u0026gt;:\t0x10000000 (gdb) \u0026lt;enter to get $r3\u0026gt; 0x200005ac \u0026lt;ucHeap+1108\u0026gt;:\t0x0 \u0026lt;g_pfnVectors\u0026gt; (gdb) \u0026lt;enter to get $r12 \u0026gt; 0x200005b0 \u0026lt;ucHeap+1112\u0026gt;:\t0x200001a8 \u0026lt;ucHeap+80\u0026gt; (gdb) \u0026lt;enter to get $lr\u0026gt; 0x200005b4 \u0026lt;ucHeap+1116\u0026gt;:\t0xbd1 \u0026lt;xQueueGenericSend+152\u0026gt; (gdb) \u0026lt;enter to get ReturnAddress\u0026gt; 0x200005b8 \u0026lt;ucHeap+1120\u0026gt;:\t0x1422 \u0026lt;vPortExitCritical+30\u0026gt; (gdb) \u0026lt;enter to get xPSR\u0026gt; // notice bit 9 is not set so there is no padding byte 0x200005bc \u0026lt;ucHeap+1124\u0026gt;:\t0x6100f000 Now we are ready to walk through the assembly code that makes up the context switcher. First we have:\n\u0026quot; mrs r0, psp \\n\u0026quot; \u0026quot; isb \\n\u0026quot; We see that the current location of the psp (the stack that was in use prior to exception entry) is loaded into r0 using the mrs instruction detailed above. This is followed by an isb (Instruction Synchronization Barrier) which flushes the instruction pipeline guaranteeing any instruction which follows will be re-fetched. Technically it doesn’t really serve any purpose here and shouldn’t be required at all14.\n// step over the first two instructions (can also type \u0026quot;si 2\u0026quot; for short) (gdb) step instruction 2 Moving on we have:\n\u0026quot; ldr r3, pxCurrentTCBConst \\n\u0026quot; /* Get the location of the current TCB. */ \u0026quot; ldr r2, [r3] \\n\u0026quot; [...] \u0026quot;pxCurrentTCBConst: .word pxCurrentTCB \\n\u0026quot; What’s happening here is a label with the location of the C variable, pxCurrentTCB, is loaded into $r3. Then the value of pxCurrentTCB gets loaded into $r2. We can confirm this by stepping through the two instructions and comparing the registers with the C types.\n(gdb) step instruction (gdb) p/x $r3 $23 = 0x20000008 (gdb) p \u0026amp;pxCurrentTCB $24 = (TCB_t * volatile *) 0x20000008 \u0026lt;pxCurrentTCB\u0026gt; (gdb) step instruction (gdb) p/x $r2 $25 = 0x20000610 (gdb) p pxCurrentTCB $26 = (TCB_t * volatile) 0x20000610 \u0026lt;ucHeap+1208\u0026gt; Next we have:\n\u0026quot; tst r14, #0x10 \\n\u0026quot; /* Is the task using the FPU context? If so, push high vfp registers. */ \u0026quot; it eq \\n\u0026quot; \u0026quot; vstmdbeq r0!, {s16-s31} \\n\u0026quot; This set of instructions checks to see if the FPU Context was active prior to exception entry. This can be resolved by reading the information passed via the $lr register on exception entry (more details above). If bit 5 is 0, the FPU is active, otherwise it is not. The tst (Test) instruction performs a logical AND operation between the register and the immediate value provided (so in this case r14 \u0026amp; 0x10). It then populates condition flags in the PSR register based on the result. Condition flags available include a “Zero condition flag” which means the result of the AND was zero.\nThe it (If-Then) instruction is then used to conditionally execute further instructions based on the current state in the condition flags. it eq is shorthand for “if the result of the last comparison was zero then execute the instruction that follows”. The following instruction pushes the callee-saved floating point registers onto the psp (currently stored in r0). In our case the result is not zero so this instruction should be skipped. We should see the psp remains unchanged from the value we originally dumped:\n(gdb) p/x $r0 $1 = 0x200005a0 (gdb) si 4 (gdb) x/i $pc =\u0026gt; 0x1446 \u0026lt;PendSV_Handler+22\u0026gt;:\tstmdb\tr0!, {r4, r5, r6, r7, r8, r9, r10, r11, lr} (gdb) p/x $r0 $1 = 0x200005a0 WARNING: Over the years I’ve seen a lot of nasty stack overflows arise here which can be tricky to track down. As soon as an FPU instruction is used an additional 132 bytes will be pushed on the stack, which can lead to unexpected overflows of small embedded stacks\nThis brings us to the next part which is pretty self explanatory:\n\u0026quot; stmdb r0!, {r4-r11, r14} \\n\u0026quot; /* Save the core registers. */ \u0026quot; str r0, [r2] \\n\u0026quot; /* Save the new top of stack into the first member of the TCB. */ We push all the callee-saved core registers onto psp using the stmdb (Store Multiple Decrement Before stores multiple registers) instruction and then update the first word in our pxCurrentTCB pointer with the updated stack location (stored in r0).\npxCurrentTCB is a FreeRTOS symbol that is always populated with the running task. A TCB (Task Control Block) contains various state associated with the task. Looking at the source code we see the first word is:\ntypedef struct tskTaskControlBlock /_ The old naming convention is used to prevent breaking kernel aware debuggers. _/ { volatile StackType_t _pxTopOfStack; /_\u0026lt; Points to the location of the last item placed on the tasks stack. THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. \\*/ [...] We can also look confirm this is what is happening by comparing the C types with register values within gdb:\n(gdb) si 0x0000144a\t435\t__asm volatile (gdb) p/x $r0 $2 = 0x2000057c (gdb) x/i $pc =\u0026gt; 0x144a \u0026lt;PendSV_Handler+26\u0026gt;:\tstr\tr0, [r2, #0] (gdb) p/x pxCurrentTCB-\u0026gt;pxTopOfStack $3 = 0x200005a4 (gdb) si 0x0000144c\t435\t__asm volatile (gdb) p/x pxCurrentTCB-\u0026gt;pxTopOfStack $4 = 0x2000057c Awesome! At this point we have saved all the register state of the original task and recorded that location within the task specific TCB context. Now it’s time to actually context switch over to a new task:\n\u0026quot; stmdb sp!, {r0, r3} \\n\u0026quot; \u0026quot; mov r0, %0 \\n\u0026quot; \u0026quot; msr basepri, r0 \\n\u0026quot; \u0026quot; dsb \\n\u0026quot; \u0026quot; isb \\n\u0026quot; \u0026quot; bl vTaskSwitchContext \\n\u0026quot; [...] ::\u0026quot;i\u0026quot;(configMAX_SYSCALL_INTERRUPT_PRIORITY) We see the port uses a GCC feature known as Extended Asm15 to mix C macros with ARM assembly. This block prepares to call the context switch logic, vTaskSwitchContext, a C function which determines the next task to run. First the “argument” registers are saved on the active stack (always msp for exceptions). Next interrupts below configMAX_SYSCALL_INTERRUPT_PRIORITY are disabled since it is only safe to access the data structures accessed by vTaskSwitchContext without interruption. If interrupts were not disabled, the context switching code could be preempted and a call to a FreeRTOS *_FromISR() API could corrupt the data structure.\nWhen lowering the effective execution level, an isb instruction is required for the new priority to be visible for future instructions. The dsb instruction shouldn’t be explicitly necessary here16. Finally we call the C function. From FreeRTOS documentation we can conclude what will happen:\n/* * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE. IT IS ONLY * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER. * * Sets the pointer to the current TCB to the TCB of the highest priority task * that is ready to run. */ portDONT_DISCARD void vTaskSwitchContext( void ) PRIVILEGED_FUNCTION; So when the function returns pxCurrentTCB should be populated with the new task to switch to. Let’s try it out!\n// display the name (gdb) p pxCurrentTCB-\u0026gt;pcTaskName $6 = \u0026quot;Ping\u0026quot;, '\\000' \u0026lt;repeats 11 times\u0026gt; (gdb) si 5 0x00001460\t435\t__asm volatile (gdb) x/i $pc =\u0026gt; 0x1460 \u0026lt;PendSV_Handler+48\u0026gt;:\tbl\t0x760 \u0026lt;vTaskSwitchContext\u0026gt; // step over the function call using \u0026quot;next instruction\u0026quot; (\u0026quot;ni\u0026quot;) (gdb) ni 0x00001464\t435\t__asm volatile (gdb) x/i $pc =\u0026gt; 0x1464 \u0026lt;PendSV_Handler+52\u0026gt;:\tmov.w\tr0, #0 (gdb) p pxCurrentTCB-\u0026gt;pcTaskName $7 = \u0026quot;Pong\u0026quot;, '\\000' \u0026lt;repeats 11 times\u0026gt; We see that the pxCurrentTCB has changed from the “Ping” task to the “Pong” task.\nUpon return from the function call, all interrupts are re-enabled by resetting basepri to 0 and the initial values of the argument registers ($r0-$r3) prior to the function invocation are restored by popping them off the stack. No synchronization instructions are required for the msr call because the ARM core will actually take care of this for you when the execution priority increases 17. Let’s step over this block:\n\u0026quot; mov r0, #0 \\n\u0026quot; \u0026quot; msr basepri, r0 \\n\u0026quot; \u0026quot; ldmia sp!, {r0, r3} \\n\u0026quot; (gdb) si 3 0x0000146e in PendSV_Handler () at freertos_kernel/portable/GCC/ARM_CM4F/port.c:435 435\t__asm volatile (gdb) x/i $pc =\u0026gt; 0x146e \u0026lt;PendSV_Handler+62\u0026gt;:\tldr\tr1, [r3, #0] Now it’s time to actually start up the new task. Recall when we saved the “Ping” task state above, we placed the location of the task stack in pxTopOfStack. So to recover the task state of the “Pong” task we just need to do the opposite. First this requires loading up the new TCB_t that pxCurrentTCB points to:\n\u0026quot; ldr r1, [r3] \\n\u0026quot; /* The first item in pxCurrentTCB is the task top of stack. */ \u0026quot; ldr r0, [r1] \\n\u0026quot; (gdb) p/x pxCurrentTCB $8 = 0x200003b0 (gdb) si 0x00001470\t435\t__asm volatile (gdb) p/x $r1 $11 = 0x200003b0 (gdb) p/x pxCurrentTCB-\u0026gt;pxTopOfStack $12 = 0x20000324 (gdb) si 0x00001472\t435\t__asm volatile (gdb) p/x $r0 $13 = 0x20000324 r0 now holds a pointer to the top of the stack for the task we want to switch to. First we pop the callee-saved core registers using the ldmia (Load Multiple Increment After) instruction, then we check the restored value in the $lr / $r14 register to determine if there is any FPU state which needs to be restored as well (in our case, it does not):\n\u0026quot; ldmia r0!, {r4-r11, r14} \\n\u0026quot; /* Pop the core registers. */ \u0026quot; \\n\u0026quot; \u0026quot; tst r14, #0x10 \\n\u0026quot; /* Is the task using the FPU context? If so, pop the high vfp registers too. */ \u0026quot; it eq \\n\u0026quot; \u0026quot; vldmiaeq r0!, {s16-s31} \\n\u0026quot; \u0026quot; \\n\u0026quot; (gdb) si 4 0x00001480\t435\t__asm volatile (gdb) x/i $pc =\u0026gt; 0x1480 \u0026lt;PendSV_Handler+80\u0026gt;:\tmsr\tPSP, r0 Now r0 points to the location of the program stack exactly as it was when the “Pong” task originally got context switched out via the PendSV exception handler! Let’s take a look at the stack just like we did on exception entry:\n(gdb) x/a $r0 // contains $r0 value for \u0026quot;Pong\u0026quot; task 0x20000348 \u0026lt;ucHeap+496\u0026gt;:\t0x0 \u0026lt;g_pfnVectors\u0026gt; (gdb) \u0026lt; enter for $r1 \u0026gt; 0x2000034c \u0026lt;ucHeap+500\u0026gt;:\t0x200003b4 \u0026lt;ucHeap+604\u0026gt; (gdb) \u0026lt; enter for $r2 \u0026gt; 0x20000350 \u0026lt;ucHeap+504\u0026gt;:\t0x20000000 \u0026lt;uxCriticalNesting\u0026gt; (gdb) \u0026lt; enter for $r3 \u0026gt; 0x20000354 \u0026lt;ucHeap+508\u0026gt;:\t0x10000000 (gdb) \u0026lt; enter for $r12 \u0026gt; 0x20000358 \u0026lt;ucHeap+512\u0026gt;:\t0x0 \u0026lt;g_pfnVectors\u0026gt; (gdb) \u0026lt; enter for $r14 / $lr \u0026gt; 0x2000035c \u0026lt;ucHeap+516\u0026gt;:\t0x5d9 \u0026lt;xTaskResumeAll+40\u0026gt; (gdb) \u0026lt; enter for ReturnAddress - the pc that should be fetched upon return \u0026gt; 0x20000360 \u0026lt;ucHeap+520\u0026gt;:\t0xe2a \u0026lt;xQueueReceive+246\u0026gt; (gdb) \u0026lt; psr value\u0026gt; 0x20000364 \u0026lt;ucHeap+524\u0026gt;:\t0x61000000 The last thing we need to do is change the location of the psp to match the value in r0 and populate the link register (r14) with the special EXC_RETURN value we just recovered from the “Pong” task stack with the ldmia instruction. This will tell the hardware how return to Thread Mode and restore the context state that was automatically saved correctly:\n\u0026quot; msr psp, r0 \\n\u0026quot; \u0026quot; isb \\n\u0026quot; \u0026quot; \\n\u0026quot; \u0026quot; \\n\u0026quot; \u0026quot; bx r14 \\n\u0026quot; \u0026quot; \\n\u0026quot; Based on the dump of the top of the “Pong” stack we did above, we expect to see $sp=0x20000368, $pc=0xe2a, $lr=0x5d9 after the branch to r14. Let’s give it a try:\n// state prior to branching (gdb) info reg [...] sp 0x20002a88 0x20002a88 lr 0xfffffffd 4294967293 pc 0x1480 0x1480 \u0026lt;PendSV_Handler+80\u0026gt; xpsr 0x2100000e 553648142 msp 0x20002a88 536881800 psp 0x200005a0 536872352 [...] (gdb) si 3 // state after branching xQueueReceive (xQueue=0x20000160 \u0026lt;ucHeap+8\u0026gt;, pvBuffer=pvBuffer@entry=0x2000039c \u0026lt;ucHeap+580\u0026gt;, xTicksToWait=\u0026lt;optimized out\u0026gt;, xTicksToWait@entry=4294967295) at freertos_kernel/queue.c:1378 1378\tportYIELD_WITHIN_API(); (gdb) info reg sp 0x20000368 0x20000368 \u0026lt;ucHeap+528\u0026gt; lr 0x5d9 1497 pc 0xe2a 0xe2a \u0026lt;xQueueReceive+246\u0026gt; xpsr 0x61000000 1627389952 msp 0x20002a88 536881800 psp 0x20000368 536871784 (gdb) bt #0 xQueueReceive (xQueue=0x20000160 \u0026lt;ucHeap+8\u0026gt;, pvBuffer=pvBuffer@entry=0x2000039c \u0026lt;ucHeap+580\u0026gt;, xTicksToWait=\u0026lt;optimized out\u0026gt;, xTicksToWait@entry=4294967295) at freertos_kernel/queue.c:1378 #1 0x00000084 in prvQueuePongTask (pvParameters=\u0026lt;optimized out\u0026gt;) at main.c:41 #2 0x00001334 in ?? () at freertos_kernel/portable/GCC/ARM_CM4F/port.c:703 They values match! We’ve successfully completed a context switch and are running the pong task!\nStarting the FreeRTOS Scheduler The astute observer reader may wonder how the scheduler starts in the first place. What happens if a PendSV gets triggered but there isn’t a currently running task because the system just booted?!\nThere are several different strategies but a common pattern an RTOS will follow when creating a new task is to initialize the task stack to look like it had been context switched out by the scheduler. Then to start the scheduler itself by triggering a SVC exception with the svc instruction. This way starting a thread is nearly identical to context switching to a thread.\nDuring initialization you will also usually find a couple extra configuration settings such as:\nConfiguration as to whether or not tasks operate at privileged or unprivileged level\nFP Extension configuration (i.e whether or not the FPU is enabled and what context stacking schema to use). For example, the port used in the example does the following FPU configuration:\nstatic void vPortEnableVFP( void ) { __asm volatile ( \u0026quot;\tldr.w r0, =0xE000ED88\t\\n\u0026quot; /* The FPU enable bits are in the CPACR. / \u0026quot;\tldr r1, [r0]\t\\n\u0026quot; \u0026quot;\t\\n\u0026quot; \u0026quot;\torr r1, r1, #( 0xf \u0026laquo; 20 )\t\\n\u0026quot; / Enable CP10 and CP11 coprocessors, then save back. / \u0026quot;\tstr r1, [r0]\t\\n\u0026quot; \u0026quot;\tbx r14\t\u0026quot; ); } [\u0026hellip;] BaseType_t xPortStartScheduler( void ) { [\u0026hellip;] / Ensure the VFP is enabled - it should be anyway. */ vPortEnableVFP();\n/* Lazy save always. */ *( portFPCCR ) |= portASPEN_AND_LSPEN_BITS; [\u0026hellip;]\nTo start FreeRTOS and get tasks to runvTaskStartScheduler needs to be called. If you are interested in taking a closer look at this logic, I’d recommend looking at are pxPortInitialiseStack, xPortStartScheduler, and vPortSVCHandler functions in port.c.\nClosing We hope you learned something interesting about how the ARM Cortex-M architecture hardware helps to enable multi-tasking and developed a better understanding of how the FreeRTOS implementation works.\nWe’d love to hear interesting RTOS bugs you have tracked down or other topics you would like to see covered on the topic. Let me know in the discussion area below!\nInterested in learning more about debugging HardFaults? Watch this webinar recording..\nSee anything you\u0026rsquo;d like to change? Submit a pull request or open an issue at GitHub\nReference Links ARM Architecture Procedure Calling Standard(AAPCS) ↩ ↩2 ↩3 ↩4 ↩5\nARMv7-M Architecture Reference Manual ↩ ↩2 ↩3 ↩4\nARMv8-M link ↩\nCortex-M4F Lazy Stacking and Context Switch App note ↩ ↩2\nSee B1.5.6 Exception entry behavior ↩\nFreeRTOS ↩\nnRF52840 Development Kit ↩\nJLinkGDBServer ↩\nGNU ARM Embedded toolchain for download ↩\nCreating a FreeRTOS Project ↩\nGithub FreeRTOS Kernel ↩ ↩2\nFreeRTOS Heap documentation ↩\nFreeRTOSConfig.h documentation ↩\nISB after mrs ↩\nExtended Asm ↩\nDiscussion about DSB in FreeRTOS port ↩\nSee “Visibility of changes in execution priority resulting from executing an MSR instruction” ↩\nChris Coleman is a founder and CTO at Memfault. Prior to founding Memfault, Chris worked on the embedded software teams at Sun, Pebble, and Fitbit.\nDiscourseEmbed = { discourseUrl: \u0026lsquo;https://community.memfault.com/', discourseEmbedUrl: \u0026lsquo;https://interrupt.memfault.com/blog/cortex-m-rtos-context-switching' }; (function() { var d = document.createElement(\u0026lsquo;script\u0026rsquo;); d.type = \u0026rsquo;text/javascript\u0026rsquo;; d.async = true; d.src = DiscourseEmbed.discourseUrl + \u0026lsquo;javascripts/embed.js\u0026rsquo;; (document.getElementsByTagName(\u0026lsquo;head\u0026rsquo;)[0] || document.getElementsByTagName(\u0026lsquo;body\u0026rsquo;)[0]).appendChild(d); })(); anchors.options.visible = \u0026lsquo;hover\u0026rsquo;; anchors.add(\u0026rsquo;.post-content \u0026gt; h1, h2, h3, h4, h5, h6\u0026rsquo;);\n","permalink":"uildDrafts/posts/p02-cortex-m-context-switching/","summary":"ARM Cortex-M RTOS Context Switching 30 Oct 2019 by Chris Coleman\nMany embedded systems reach a level of complexity where having a basic set of scheduling primitives and ability to run different tasks can be helpful. The operation of switching from one task to another is known as a context switch. A Real Time Operating System (RTOS) will typically provide this functionality. Having a foundational knowledge of how the core of an RTOS works can be a valuable skill set for an embedded engineer to have.","title":"ARM Cortex-M RTOS Context Switching"},{"content":"How to debug a HardFault on an ARM Cortex-M MCU 20 Nov 2019 by Chris Coleman\nFaults happen on embedded devices all the time for a variety of reasons – ranging from something as simple as a NULL pointer dereference to something more unexpected like running a faulty code path only when in a zero-g environment on the Tower of Terror in Disneyland1. It’s important for any embedded engineer to understand how to debug and resolve this class of issue quickly.\nIn this article, we explain how to debug faults on ARM Cortex-M based devices. In the process, we learn about fault registers, how to automate fault analysis, and figure out ways to recover from some faults without rebooting the MCU. We include practical examples, with a step by step walk-through on how to investigate them.\nIf you’d rather listen to me present this information and see some demos in action, watch this webinar recording.\nLike Interrupt? Subscribe to get our latest posts straight to your mailbox.\nTable of Contents Determining What Caused The Fault Relevant Status Registers Configurable Fault Status Registers (CFSR) - 0xE000ED28 HardFault Status Register (HFSR) - 0xE000ED2C Recovering the Call Stack Automating the Analysis Halting \u0026amp; Determining Core Register State Fault Register Analyzers Postmortem Analysis Recovering From A Fault Examples eXecute Never Fault Bad Address Read Coprocessor Fault Imprecise Fault Fault Entry Exception Recovering from a UsageFault without a SYSRESET Determining What Caused The Fault All MCUs in the Cortex-M series have several different pieces of state which can be analyzed when a fault takes place to trace down what went wrong.\nFirst we will explore the dedicated fault status registers that are present on all Cortex-M MCUs except the Cortex-M0.\nIf you are trying to debug a Cortex-M0, you can skip ahead to the next section where we discuss how to recover the core register state and instruction being executed at the time of the exception.\nNOTE: If you already know the state to inspect when a fault occurs, you may want to skip ahead to the section about how to automate the analysis.\nRelevant Status Registers Configurable Fault Status Registers (CFSR) - 0xE000ED28 This 32 bit register contains a summary of the fault(s) which took place and resulted in the exception. The register is comprised of three different status registers – UsageFault, BusFault \u0026amp; MemManage Fault Status Registers:\nThe register can be accessed via a 32 bit read at 0xE000ED28 or each register can be read individually. For example, in GDB it would look something like this:\nEntire CFSR - print/x *(uint32_t *) 0xE000ED28 UsageFault Status Register (UFSR) - print/x *(uint16_t *)0xE000ED2A BusFault Status Register (BFSR) - print/x *(uint8_t *)0xE000ED29 MemManage Status Register (MMFSR) - print/x *(uint8_t *)0xE000ED28 NOTE: If multiple faults have occurred, bits related to several faults may be set. Fields are only cleared by a system reset or by writing a 1 to them.\nUsageFault Status Register (UFSR) - 0xE000ED2A This register is a 2 byte register which summarizes any faults that are not related to memory access failures, such as executing invalid instructions or trying to enter invalid states.\nwhere,\nDIVBYZERO - Indicates a divide instruction was executed where the denominator was zero. This fault is configurable. UNALIGNED - Indicates an unaligned access operation occurred. Unaligned multiple word accesses, such as accessing a uint64_t that is not 8-byte aligned, will always generate this fault. With the exception of Cortex-M0 MCUs, whether or not unaligned accesses below 4 bytes generate a fault is also configurable. NOCP - Indicates that a Cortex-M coprocessor instruction was issued but the coprocessor was disabled or not present. One common case where this fault happens is when code is compiled to use the Floating Point extension (-mfloat-abi=hard -mfpu=fpv4-sp-d16) but the coprocessor was not enabled on boot. INVPC - Indicates an integrity check failure on EXC_RETURN. We’ll explore an example below. EXC_RETURN is the value branched to upon return from an exception. If this fault flag is set, it means a reserved EXC_RETURN value was used on exception exit. INVSTATE - Indicates the processor has tried to execute an instruction with an invalid Execution Program Status Register (EPSR) value. Among other things the ESPR tracks whether or not the processor is in thumb mode state. Instructions which use “interworking addresses”2 (bx \u0026amp; blx or ldr \u0026amp; ldm when loading a pc-relative value) must set bit[0] of the instruction to 1 as this is used to update ESPR.T. If this rule is violated, a INVSTATE exception will be generated. When writing C code, the compiler will take care of this automatically, but this is a common bug which can arise when hand-writing assembly. UNDEFINSTR - Indicates an undefined instruction was executed. This can happen on exception exit if the stack got corrupted. A compiler may emit undefined instructions as well for code paths that should be unreachable. Configurable UsageFault It is worth noting that some classes of UsageFaults are configurable via the Configuration and Control Register (CCR) located at address 0xE000ED14.\nBit 4 (DIV_0_TRP) - Controls whether or not divide by zeros will trigger a fault. Bit 3 (UNALIGN_TRP) - Controls whether or not unaligned accesses will always generate a fault. NOTE: On reset both of these optional faults are disabled. It is generally a good idea to enable DIV_0_TRP to catch mathematical errors in your code.\nBusFault Status Register (BFSR) - 0xE000ED29 This register is a 1 byte register which summarizes faults related to instruction prefetch or memory access failures.\nBFARVALID - Indicates that the Bus Fault Address Register (BFAR), a 32 bit register located at 0xE000ED38, holds the address which triggered the fault. We’ll walk through an example using this info below. LSPERR \u0026amp; STKERR - Indicates that a fault occurred during lazy state preservation or during exception entry, respectively. Both are situations where the hardware is automatically saving state on the stack. One way this error may occur is if the stack in use overflows off the valid RAM address range while trying to service an exception. We’ll go over an example below. UNSTKERR - Indicates that a fault occurred trying to return from an exception. This typically arises if the stack was corrupted while the exception was running or the stack pointer was changed and its contents were not initialized correctly. IMPRECISERR - This flag is very important. It tells us whether or not the hardware was able to determine the exact location of the fault. We will explore some debug strategies when this flag is set in the next section and walk through a code exampe below. PRECISERR - Indicates that the instruction which was executing prior to exception entry triggered the fault. Imprecise Bus Error Debug Tips Imprecise errors are one of the hardest classes of faults to debug. They result asynchronously to instruction execution flow. This means the registers stacked on exception entry will not point to the code that caused the exception.\nInstruction fetches and data loads should always generate synchronous faults for Cortex-M devices and be precise. Conversely, store operations can generate asynchronous faults. This is because writes will sometimes be buffered prior to being flushed to prevent pipeline stalls so the program counter will advance before the actual data store completes.\nWhen debugging an imprecise error, you will want to inspect the code around the area reported by the exception for a store that looks suspicious. If the MCU has support for the ARM Embedded Trace Macrocell (ETM), the history of recently executed instructions can be viewed by some debuggers3.\nAuxiliary Control Register (ACTLR) - 0xE000E008 This register allows for some hardware optimizations or features to be disabled typically at the cost of overall performance or interrupt latency. The exact configuration options available are specific to the Cortex-M implementation being used.\nFor the Cortex M3 \u0026amp; Cortex M4 only, there is a trick to make all IMPRECISE accesses PRECISE by disabling any write buffering. This can be done by setting bit 1 (DISDEFWBUF) of the register to 1.\nFor the Cortex M7, there is no way to force all stores to be synchronous / precise.\nAuxiliary Bus Fault Status Register (ABFSR) - 0xE000EFA8 This register only exists for Cortex-M7 devices. When an IMPRECISE error occurs it will at least give us an indication of what memory bus the fault occurred on4:\nA full discussion of memory interfaces is outside the scope of this article but more details can be found in the reference manual 4.\nMemManage Status Register (MMFSR) - 0xE000ED28 This register reports Memory Protection Unit faults.\nTypically MPU faults will only trigger if the MPU has been configured and enabled by the firmware. However, there are a few memory access errors that will always result in a MemManage fault – such as trying to execute code from the system address range (0xExxx.xxxx).\nThe layout of the register looks like this:\nwhere,\nMMARVALID - Indicates that the MemManage Fault Address Register (MMFAR), a 32 bit register located at 0xE000ED34, holds the address which triggered the MemManage fault. MLSPERR \u0026amp; MSTKERR - Indicates that a MemManage fault occurred during lazy state preservation or exception entry, respectively. For example, this could happen if an MPU region is being used to detect stack overflows. MUNSTKERR - Indicates that a fault occurred while returning from an exception DACCVIOL - Indicates that a data access triggered the MemManage fault. IACCVIOL - Indicates that an attempt to execute an instruction triggered an MPU or Execute Never (XN) fault. We’ll explore an example below. HardFault Status Register (HFSR) - 0xE000ED2C This registers explains the reason a HardFault exception was triggered.\nThere’s not too much information in this register but we will go over the fields real quickly\nDEBUGEVT - Indicates that a debug event (i.e executing a breakpoint instruction) occurred while the debug subsystem was not enabled FORCED - This means a configurable fault (i.e. the fault types we discussed in previous sections) was escalated to a HardFault, either because the configurable fault handler was not enabled or a fault occurred within the handler. VECTTBL - Indicates a fault occurred because of an issue reading from an address in the vector table. This is pretty atypical but could happen if there is a bad address in the vector table and an unexpected interrupt fires. Recovering the Call Stack To fix a fault, we will want to determine what code was running when the fault occurred. To accomplish this, we need to recover the register state at the time of exception entry.\nIf the fault is readily reproducible and we have a debugger attached to the board, we can manually add a breakpoint for the function which handles the exception. In GDB this will look something like\n(gdb) break HardFault_Handler Upon exception entry some registers will always be automatically saved on the stack. Depending on whether or not an FPU is in use, either a basic or extended stack frame will be pushed by hardware.\nRegardless, the hardware will always push the same core set of registers to the very top of the stack which was active prior to entering the exception. ARM Cortex-M devices have two stack pointers, msp \u0026amp; psp. Upon exception entry, the active stack pointer is encoded in bit 2 of the EXC_RETURN value pushed to the link register. If the bit is set, the psp was active prior to exception entry, else the msp was active.\nLet’s look at the state when we break in HardFault_Handler for a pathological example:\nint illegal_instruction_execution(void) { int (*bad_instruction)(void) = (void *)0xE0000000; return bad_instruction(); } (gdb) p/x $lr $4 = 0xfffffffd # psp was active prior to exception if bit 2 is set # otherwise, the msp was active (gdb) p/x $lr\u0026amp;(1\u0026lt;\u0026lt;2) $5 = 0x4 # First eight values on stack will always be: # r0, r1, r2, r3, r12, LR, pc, xPSR (gdb) p/a *(uint32_t[8] *)$psp $16 = { 0x0 \u0026lt;g_pfnVectors\u0026gt;, 0x200003c4 \u0026lt;ucHeap+604\u0026gt;, 0x10000000, 0xe0000000, 0x200001b8 \u0026lt;ucHeap+80\u0026gt;, 0x61 \u0026lt;illegal_instruction_execution+16\u0026gt;, 0xe0000000, 0x80000000 } Offset 6 and 7 in the array dumped hold the LR (illegal_instruction_execution) \u0026amp; PC (0xe0000000) so we now can see exactly where the fault originated!\nFaults from Faults The astute observer might wonder what happens when a new fault occurs in the code dealing with a fault. If you have enabled configurable fault handlers (i.e MemManage, BusFault, or UsageFault), a fault generated in these handlers will trigger a HardFault.\nOnce in the HardFault Handler, the ARM Core is operating at a non-configurable priority level, -1. At this level or above, a fault will put the processor in an unrecoverable state where a reset is expected. This state is known as Lockup.\nTypically, the processor will automatically reset upon entering lockup but this is not a requirement per the specification. For example, you may have to enable a hardware watchdog for a reset to take place. It’s worth double checking the reference manual for the MCU being used for clarification.\nWhen a debugger is attached, lockup often has a different behavior. For example, on the NRF52840, “Reset from CPU lockup is disabled if the device is in debug interface mode”5.\nWhen a lockup happens, the processor will repeatedly fetch the same fixed instruction, 0xFFFFFFFE or the instruction which triggered the lockup, in a loop until a reset occurs.\nFun Fact: Whether or not some classes of MemManage or BusFaults trigger a fault from an exception is actually configurable via the MPU_CTRL.HFNMIENA \u0026amp; CCR.BFHFNMIGN register fields, respectively.\nAutomating the Analysis At this point we have gone over all the pieces of information which can be manually examined to determine what caused a fault. While this might be fun the first couple times, it can become a tiresome and error prone process if you wind up doing it often. In the following sections we’ll explore how we can automate this analysis!\nHalting \u0026amp; Determining Core Register State What if we are trying to debug an issue that is not easy to reproduce? Even if we have a debugger attached, useful state may be overwritten before we have a chance to halt the debugger and take a look.\nThe first thing we can do is to programmatically trigger a breakpoint when the system faults:\n// NOTE: If you are using CMSIS, the registers can also be // accessed through CoreDebug-\u0026gt;DHCSR \u0026amp; CoreDebug_DHCSR_C_DEBUGEN_Msk #define HALT_IF_DEBUGGING() \\ do { \\ if ((*(volatile uint32_t *)0xE000EDF0) \u0026amp; (1 \u0026lt;\u0026lt; 0)) { \\ __asm(\u0026quot;bkpt 1\u0026quot;); \\ } \\ } while (0) Above, we discussed how to hand unroll the register state prior to the exception taking place. Let’s explore how we can instrument the code to make this a less painful process.\nFirst, we can easily define a C struct to represent the register stacking:\ntypedef struct __attribute__((packed)) ContextStateFrame { uint32_t r0; uint32_t r1; uint32_t r2; uint32_t r3; uint32_t r12; uint32_t lr; uint32_t return_address; uint32_t xpsr; } sContextStateFrame; We can determine the stack pointer that was active prior to the exception using a small assembly shim that applies the logic discussed above and passes the active stack pointer as an argument into my_fault_handler_c:\n#define HARDFAULT_HANDLING_ASM(_x) \\ __asm volatile( \\ \u0026quot;tst lr, #4 \\n\u0026quot; \\ \u0026quot;ite eq \\n\u0026quot; \\ \u0026quot;mrseq r0, msp \\n\u0026quot; \\ \u0026quot;mrsne r0, psp \\n\u0026quot; \\ \u0026quot;b my_fault_handler_c \\n\u0026quot; \\ ) Finally, we can put together my_fault_handler_c that looks something like:\n// Disable optimizations for this function so \u0026quot;frame\u0026quot; argument // does not get optimized away __attribute__((optimize(\u0026quot;O0\u0026quot;))) void my_fault_handler_c(sContextStateFrame *frame) { // If and only if a debugger is attached, execute a breakpoint // instruction so we can take a look at what triggered the fault HALT_IF_DEBUGGING(); // Logic for dealing with the exception. Typically: // - log the fault which occurred for postmortem analysis // - If the fault is recoverable, // - clear errors and return back to Thread Mode // - else // - reboot system } Now when a fault occurs and a debugger is attached, we will automatically hit a breakpoint and be able to look at the register state! Re-examining our illegal_instruction_execution example we have:\n0x00000244 in my_fault_handler_c (frame=0x200005d8 \u0026lt;ucHeap+1136\u0026gt;) at ./cortex-m-fault-debug/startup.c:94 94\tHALT_IF_DEBUGGING(); (gdb) p/a *frame $18 = { r0 = 0x0 \u0026lt;g_pfnVectors\u0026gt;, r1 = 0x200003c4 \u0026lt;ucHeap+604\u0026gt;, r2 = 0x10000000, r3 = 0xe0000000, r12 = 0x200001b8 \u0026lt;ucHeap+80\u0026gt;, lr = 0x61 \u0026lt;illegal_instruction_execution+16\u0026gt;, return_address = 0xe0000000, xpsr = 0x80000000 } Furthermore, we now have a variable we can read stack info from and a C function we can easily extend for postportem analysis!\nFault Register Analyzers Instrumenting the code Many Real Time Operating Systems (RTOS) targetting Cortex-M devices will add options to dump verbose fault register information to the console upon crash. Some examples include Arm Mbed OS6 and Zephyr7. For example, with Zephyr, the illegal_instruction_execution() crash looks like:\n***** MPU FAULT ***** Instruction Access Violation ***** Hardware exception ***** Current thread ID = 0x20000074 Faulting instruction address = 0xe0000000 Fatal fault in thread 0x20000074! Aborting. This approach has a couple notable limitations:\nIt bloats the code \u0026amp; data size of the binary image and consequently often gets turned off. It can increase the stack size requirements for the fault handler (due to printf calls) It requires a firmware update to improve or fix issues with the analyzers It requires a console session be active to see what fault occurred. Furthermore, this can be flaky if the system is in a crashed state. Debugger Plugins Many embedded IDEs expose a system view that can be used to look at registers. The registers will often be decoded into human readable descriptions. These implementations typically leverage the CMSIS System View Description (SVD) format8, a standardized XML file format for describing the memory mapped registers in an ARM MCU. Most silicon vendors expose this information on their own website, ARM’s website9, or provide the files upon request.\nYou can even load these files in GDB using PyCortexMDebug10, a GDB python script .\nTo use the utility, all you need to do is update your .gdbinit to use PyPi packages from your environment (instructions here) and then run:\n$ git clone git@github.com:bnahill/PyCortexMDebug.git # Check out Python 2 compatible code $ git checkout 77af54e $ cd PyCortexMDebug $ python setup.py install When you next start gdb, you can source the svd_gdb.py script and use it to start inspecting registers. Here’s some output for the svd plugin we will use in the examples below:\n(gdb) source cmdebug/svd_gdb.py (gdb) svd_load cortex-m4-scb.svd (gdb) svd Available Peripherals: ... SCB: System control block ... (gdb) svd SCB Registers in SCB: ... CFSR_UFSR_BFSR_MMFSR: 524288 Configurable fault status register ... (gdb) svd SCB CFSR_UFSR_BFSR_MMFSR Fields in SCB CFSR_UFSR_BFSR_MMFSR: IACCVIOL: 0 Instruction access violation flag DACCVIOL: 0 Data access violation flag MUNSTKERR: 0 Memory manager fault on unstacking for a return from exception MSTKERR: 0 Memory manager fault on stacking for exception entry. MLSPERR: 0 MMARVALID: 0 Memory Management Fault Address Register (MMAR) valid flag IBUSERR: 1 Instruction bus error PRECISERR: 0 Precise data bus error IMPRECISERR: 0 Imprecise data bus error UNSTKERR: 0 Bus fault on unstacking for a return from exception STKERR: 0 Bus fault on stacking for exception entry LSPERR: 0 Bus fault on floating-point lazy state preservation BFARVALID: 0 Bus Fault Address Register (BFAR) valid flag UNDEFINSTR: 0 Undefined instruction usage fault INVSTATE: 1 Invalid state usage fault INVPC: 0 Invalid PC load usage fault NOCP: 0 No coprocessor usage fault. UNALIGNED: 0 Unaligned access usage fault DIVBYZERO: 0 Divide by zero usage fault Postmortem Analysis The previous two approaches are only helpful if we have a debug or physical connection to the device. Once the product has shipped and is out in the field these strategies will not help to triage what went wrong on devices.\nOne approach is to simply try and reproduce the issue on site. This is a guessing game (are you actually reproducing the same issue the customer hit?), can be a huge time sink and in some cases is not even particularly feasible1.\nAnother strategy is to log the fault register and stack values to persistent storage and periocially collect or push the error logs. On the server side, the register values can be decoded and addresses can be symbolicated to try to root cause the crash.\nAlternatively, an end-to-end firmware error analysis system, such as Memfault, can be used to automatically collect, transport, deduplicate and surface the faults and crashes happening in the field. Here is some example output from Memfault for the bad memory read example we will walk through below:\nRecovering From A Fault DISCLAIMER: Typically when a fault occurs, the best thing to do is reset the MCU since it’s hard to be certain what parts of the MCU were corrupted as part of the fault (embedded MCUs don’t offer a MMU like you would find on a bigger processors).\nOccasionally, you may want to recover the system from a fault without rebooting it. For example, maybe you have one RTOS task isolated by the MPU that just needs to be restarted.\nLet’s quickly explore how we could implement a recovery mechanism that puts a RTOS task which experience a UsageFault into an idle loop and reboots the system otherwise.\nWe will use the Application Interrupt and Reset Control Register to reset the device if the fault is unrecoverable. We can easily extend my_fault_handler_c from above:\nvoid my_fault_handler_c(sContextStateFrame *frame) { [...] volatile uint32_t *cfsr = (volatile uint32_t *)0xE000ED28; const uint32_t usage_fault_mask = 0xffff0000; const bool non_usage_fault_occurred = (*cfsr \u0026amp; ~usage_fault_mask) != 0; // the bottom 8 bits of the xpsr hold the exception number of the // executing exception or 0 if the processor is in Thread mode const bool faulted_from_exception = ((frame-\u0026gt;xpsr \u0026amp; 0xFF) != 0); if (faulted_from_exception || non_usage_fault_occurred) { // For any fault within an ISR or non-usage faults // let's reboot the system volatile uint32_t *aircr = (volatile uint32_t *)0xE000ED0C; *aircr = (0x05FA \u0026lt;\u0026lt; 16) | 0x1 \u0026lt;\u0026lt; 2; while (1) { } // should be unreachable } [...] } Now, the interesting part, how do we clean up our state and return to normal code from the HardFault handler?!\nThere’s a few things we will need to do:\nClear any logged faults from the CFSR by writing 1 to each bit which is set. Change the function we return to so we idle the task. In the example case it’s recover_from_task_fault. Scribble a known pattern over the lr. The function we are returning to will need to take special action (i.e like deleting the task or entering a while(1) loop). It can’t just exit and branch to where we were before so we want to fault if this is attempted. Reset the xpsr. Among other things the xpsr tracks the state of previous comparison instructions which were run and whether or not we are in the middle of a “If-Then” instruction block. The only bit that needs to remain set is the “T” field (bit 24) indicating the processor is in thumb mode11. This winds up looking like:\n// Clear any logged faults from the CFSR *cfsr |= *cfsr; // the instruction we will return to when we exit from the exception frame-\u0026gt;return_address = (uint32_t)recover_from_task_fault; // the function we are returning to should never branch // so set lr to a pattern that would fault if it did frame-\u0026gt;lr = 0xdeadbeef; // reset the psr state and only leave the // \u0026quot;thumb instruction interworking\u0026quot; bit set frame-\u0026gt;xpsr = (1 \u0026lt;\u0026lt; 24); You may recall from the RTOS Context Switching post that fault handlers can work just like regular C functions so after these changes we will exit from my_fault_handler_c and start executing whatever is in recover_from_task_fault function. We will walk through an example of this below.\nExamples In the sections below we will walk through the analysis of a couple faults.\nFor this setup we will use:\na nRF52840-DK12 (ARM Cortex-M4F) as our development board SEGGER JLinkGDBServer13 as our GDB Server. GCC 8.3.1 / GNU Arm Embedded Toolchain as our compiler14 GNU make as our build system All the code can be found on the Interrupt Github page with more details in the README in the directory linked.\nSetup Start a GDB Server:\nJLinkGDBServer -if swd -device nRF52840_xxAA Follow the instructions above to setup support for reading SVD files from GDB, build, and flash the example app:\n$ make [...] Linking library Generated build/nrf52.elf $ arm-none-eabi-gdb-py --eval-command=\u0026quot;target remote localhost:2331\u0026quot; --ex=\u0026quot;mon reset\u0026quot; --ex=\u0026quot;load\u0026quot; --ex=\u0026quot;mon reset\u0026quot; --se=build/nrf52.elf $ source PyCortexMDebug/cmdebug/svd_gdb.py $ (gdb) svd_load cortex-m4-scb.svd Loading SVD file cortex-m4-scb.svd... (gdb) The app has eight different crashes you can configure by changing FAULT_EXAMPLE_CONFIG at compile time or by editing the value at runtime:\n(gdb) break main (gdb) continue (gdb) set g_crash_config=1 (gdb) continue eXecute Never Fault Code int illegal_instruction_execution(void) { int (*bad_instruction)(void) = (void *)0xE0000000; return bad_instruction(); } Analysis (gdb) break main (gdb) continue Breakpoint 1, main () at ./cortex-m-fault-debug/main.c:180 180\txQueue = xQueueCreate(mainQUEUE_LENGTH, sizeof(unsigned long)); (gdb) set g_crash_config=0 (gdb) c Continuing. Program received signal SIGTRAP, Trace/breakpoint trap. 0x00000218 in my_fault_handler_c (frame=0x200005e8 \u0026lt;ucHeap+1152\u0026gt;) at ./cortex-m-fault-debug/startup.c:91 91\tHALT_IF_DEBUGGING(); (gdb) bt #0 0x00000218 in my_fault_handler_c (frame=0x200005e8 \u0026lt;ucHeap+1152\u0026gt;) at ./cortex-m-fault-debug/startup.c:91 #1 \u0026lt;signal handler called\u0026gt; #2 0x00001468 in prvPortStartFirstTask () at ./cortex-m-fault-debug/freertos_kernel/portable/GCC/ARM_CM4F/port.c:267 #3 0x000016e6 in xPortStartScheduler () at ./cortex-m-fault-debug/freertos_kernel/portable/GCC/ARM_CM4F/port.c:379 #4 0x1058e476 in ?? () We can check the CFSR to see if there is any information about the fault which occurred.\n(gdb) p/x *(uint32_t*)0xE000ED28 $3 = 0x1 (gdb) svd SCB CFSR_UFSR_BFSR_MMFSR Fields in SCB CFSR_UFSR_BFSR_MMFSR: IACCVIOL: 1 Instruction access violation flag [...] That’s interesting! We hit a Memory Management instruction access violation fault even though we haven’t enabled any MPU regions. From the CFSR, we know that the stacked frame is valid so we can take a look at that to see what it reveals:\n(gdb) p/a *frame $1 = { r0 = 0x0 \u0026lt;g_pfnVectors\u0026gt;, r1 = 0x200003c4 \u0026lt;ucHeap+604\u0026gt;, r2 = 0x10000000, r3 = 0xe0000000, r12 = 0x200001b8 \u0026lt;ucHeap+80\u0026gt;, lr = 0x195 \u0026lt;prvQueuePingTask+52\u0026gt;, return_address = 0xe0000000, xpsr = 0x80000000 } We can clearly see that the executing instruction was 0xe0000000 and that the calling function was prvQueuePingTask.\nFrom the ARMv7-M reference manual15 we find:\nThe MPU is restricted in how it can change the default memory map attributes associated with System space, that is, for addresses 0xE0000000 and higher. System space is always marked as XN, Execute Never.\nSo the fault registers didn’t lie to us, and it does make sense that we hit a memory management fault!\nBad Address Read Code uint32_t read_from_bad_address(void) { return *(volatile uint32_t *)0xbadcafe; } Analysis (gdb) break main (gdb) continue Breakpoint 1, main () at ./cortex-m-fault-debug/main.c:189 189\txQueue = xQueueCreate(mainQUEUE_LENGTH, sizeof(unsigned long)); (gdb) set g_crash_config=1 (gdb) c Continuing. Program received signal SIGTRAP, Trace/breakpoint trap. 0x00000218 in my_fault_handler_c (frame=0x200005e8 \u0026lt;ucHeap+1152\u0026gt;) at ./cortex-m-fault-debug/startup.c:91 91\tHALT_IF_DEBUGGING(); Again, let’s take a look at the CFSR and see if it tells us anything useful.\n(gdb) p/x *(uint32_t*)0xE000ED28 $13 = 0x8200 (gdb) svd SCB CFSR_UFSR_BFSR_MMFSR Fields in SCB CFSR_UFSR_BFSR_MMFSR: [...] PRECISERR: 1 Precise data bus error [...] BFARVALID: 1 Bus Fault Address Register (BFAR) valid flag Great, we have a precise bus fault which means the return address in the stack frame holds the instruction which triggered the fault and that we can read BFAR to determine what memory access triggered the fault!\n(gdb) svd/x SCB BFAR Fields in SCB BFAR: BFAR: 0x0BADCAFE Bus fault address (gdb) p/a *frame $16 = { r0 = 0x1 \u0026lt;g_pfnVectors+1\u0026gt;, r1 = 0x200003c4 \u0026lt;ucHeap+604\u0026gt;, r2 = 0x10000000, r3 = 0xbadcafe, r12 = 0x200001b8 \u0026lt;ucHeap+80\u0026gt;, lr = 0x195 \u0026lt;prvQueuePingTask+52\u0026gt;, return_address = 0x13a \u0026lt;trigger_crash+22\u0026gt;, xpsr = 0x81000000 } (gdb) info line *0x13a Line 123 of \u0026quot;./cortex-m-fault-debug/main.c\u0026quot; starts at address 0x138 \u0026lt;trigger_crash+20\u0026gt; and ends at 0x13e \u0026lt;trigger_crash+26\u0026gt;. (gdb) list *0x13a 0x13a is in trigger_crash (./cortex-m-fault-debug/main.c:123). 118\tswitch (crash_id) { 119\tcase 0: 120\tillegal_instruction_execution(); 121\tbreak; 122\tcase 1: ===\u0026gt; FAULT HERE 123\tread_from_bad_address(); 124\tbreak; 125\tcase 2: 126\taccess_disabled_coprocessor(); 127\tbreak; Great, so we have pinpointed the exact code which triggered the issue and can now fix it!\nCoprocessor Fault Code void access_disabled_coprocessor(void) { // FreeRTOS will automatically enable the FPU co-processor. // Let's disable it for the purposes of this example __asm volatile( \u0026quot;ldr r0, =0xE000ED88 \\n\u0026quot; \u0026quot;mov r1, #0 \\n\u0026quot; \u0026quot;str r1, [r0]\t\\n\u0026quot; \u0026quot;dsb \\n\u0026quot; \u0026quot;vmov r0, s0 \\n\u0026quot; ); } Analysis (gdb) break main (gdb) continue Breakpoint 4, main () at ./cortex-m-fault-debug/main.c:180 180\txQueue = xQueueCreate(mainQUEUE_LENGTH, sizeof(unsigned long)); (gdb) set g_crash_config=2 (gdb) c Continuing. Program received signal SIGTRAP, Trace/breakpoint trap. 0x00000218 in my_fault_handler_c (frame=0x20002d80) at ./cortex-m-fault-debug/startup.c:91 91\tHALT_IF_DEBUGGING(); We can inspect CFSR to get a clue about the crash which took place\n(gdb) p/x *(uint32_t*)0xE000ED28 $13 = 0x8200 (gdb) svd SCB CFSR_UFSR_BFSR_MMFSR Fields in SCB CFSR_UFSR_BFSR_MMFSR: [...] NOCP: 1 No coprocessor usage fault. [...] We see it was a coprocessor UsageFault which tells us we either issued an instruction to a non-existent or disabled Cortex-M coprocessor. We know the frame contents are valid so we can inspect that to figure out where the fault originated:\n(gdb) p/a *frame $27 = { r0 = 0xe000ed88, r1 = 0x0 \u0026lt;g_pfnVectors\u0026gt;, r2 = 0x10000000, r3 = 0x0 \u0026lt;g_pfnVectors\u0026gt;, r12 = 0x200001b8 \u0026lt;ucHeap+80\u0026gt;, lr = 0x199 \u0026lt;prvQueuePingTask+52\u0026gt;, return_address = 0x114 \u0026lt;access_disabled_coprocessor+12\u0026gt;, xpsr = 0x81000000 } (gdb) disassemble 0x114 Dump of assembler code for function access_disabled_coprocessor: 0x00000108 \u0026lt;+0\u0026gt;:\tldr\tr0, [pc, #16]\t; (0x11c) 0x0000010a \u0026lt;+2\u0026gt;:\tmov.w\tr1, #0 0x0000010e \u0026lt;+6\u0026gt;:\tstr\tr1, [r0, #0] 0x00000110 \u0026lt;+8\u0026gt;:\tdsb\tsy ===\u0026gt; FAULT HERE on a Floating Point instruction 0x00000114 \u0026lt;+12\u0026gt;:\tvmov\tr0, s0 0x00000118 \u0026lt;+16\u0026gt;:\tbx\tlr vmov is a floating point instruction so we now know what coprocessor the NOCP was caused by. The FPU is enabled using bits 20-23 of the CPACR register located at 0xE000ED88. A value of 0 indicates the extension is disabled. Let’s check it:\n(gdb) p/x (*(uint32_t*)0xE000ED88 \u0026gt;\u0026gt; 20) \u0026amp; 0xf $29 = 0x0 We can clearly see the FP Extension is disabled. We will have to enable the FPU to fix our bug.\nImprecise Fault Code void bad_addr_double_word_write(void) { volatile uint64_t *buf = (volatile uint64_t *)0x30000000; *buf = 0x1122334455667788; } Analysis (gdb) break main (gdb) continue Breakpoint 4, main () at ./cortex-m-fault-debug/main.c:182 182\txQueue = xQueueCreate(mainQUEUE_LENGTH, sizeof(unsigned long)); (gdb) set g_crash_config=3 (gdb) c Continuing. Program received signal SIGTRAP, Trace/breakpoint trap. 0x0000021c in my_fault_handler_c (frame=0x200005e8 \u0026lt;ucHeap+1152\u0026gt;) at ./cortex-m-fault-debug/startup.c:91 91\tHALT_IF_DEBUGGING(); Let’s inspect CFSR:\n(gdb) p/x *(uint32_t*)0xE000ED28 $31 = 0x400 (gdb) svd SCB CFSR_UFSR_BFSR_MMFSR Fields in SCB CFSR_UFSR_BFSR_MMFSR: [...] IMPRECISERR: 1 Imprecise data bus error [...] Yikes, the error is imprecise. This means the stack frame will point to the general area where the fault occurred but not the exact instruction!\n(gdb) p/a *frame $32 = { r0 = 0x55667788, r1 = 0x11223344, r2 = 0x10000000, r3 = 0x30000000, r12 = 0x200001b8 \u0026lt;ucHeap+80\u0026gt;, lr = 0x199 \u0026lt;prvQueuePingTask+52\u0026gt;, return_address = 0x198 \u0026lt;prvQueuePingTask+52\u0026gt;, xpsr = 0x81000000 } (gdb) list *0x198 0x198 is in prvQueuePingTask (./cortex-m-fault-debug/main.c:162). 157 158\twhile (1) { 159\tvTaskDelayUntil(\u0026amp;xNextWakeTime, mainQUEUE_SEND_FREQUENCY_MS); 160\txQueueSend(xQueue, \u0026amp;ulValueToSend, 0U); 161 ==\u0026gt; Crash somewhere around here 162\ttrigger_crash(g_crash_config); 163\t} 164\t} 165 166\tstatic void prvQueuePongTask(void *pvParameters) { Analysis after making the Imprecise Error Precise If the crash was not readily reproducible we would have to inspect the code around this region and hypothesize what looks suspicious. However, recall that there is a trick we can use for the Cortex-M4 to make all memory stores precise. Let’s enable that and re-examine:\n(gdb) mon reset Resetting target (gdb) c Continuing. Breakpoint 4, main () at ./cortex-m-fault-debug/main.c:182 182\txQueue = xQueueCreate(mainQUEUE_LENGTH, sizeof(unsigned long)); (gdb) set g_crash_config=3 ==\u0026gt; Make all memory stores precise at the cost of performance ==\u0026gt; by setting DISDEFWBUF in the Cortex M3/M4 ACTLR reg (gdb) set *(uint32_t*)0xE000E008=(*(uint32_t*)0xE000E008 | 1\u0026lt;\u0026lt;1) (gdb) c Continuing. Program received signal SIGTRAP, Trace/breakpoint trap. 0x0000021c in my_fault_handler_c (frame=0x200005e8 \u0026lt;ucHeap+1152\u0026gt;) at ./cortex-m-fault-debug/startup.c:91 91\tHALT_IF_DEBUGGING(); (gdb) p/a *frame $33 = { r0 = 0x55667788, r1 = 0x11223344, r2 = 0x10000000, r3 = 0x30000000, r12 = 0x200001b8 \u0026lt;ucHeap+80\u0026gt;, lr = 0x199 \u0026lt;prvQueuePingTask+52\u0026gt;, return_address = 0xfa \u0026lt;bad_addr_double_word_write+10\u0026gt;, xpsr = 0x81000000 } (gdb) list *0xfa 0xfa is in bad_addr_double_word_write (./cortex-m-fault-debug/main.c:92). 90\tvoid bad_addr_double_word_write(void) { 91\tvolatile uint64_t *buf = (volatile uint64_t *)0x30000000; ==\u0026gt; FAULT HERE 92\t*buf = 0x1122334455667788; 93\t} (gdb) Awesome, that saved us some time … we were able to determine the exact line that caused the crash!\nFault Entry Exception Code void stkerr_from_psp(void) { extern uint32_t _start_of_ram[]; uint8_t dummy_variable; const size_t distance_to_ram_bottom = (uint32_t)\u0026amp;dummy_variable - (uint32_t)_start_of_ram; volatile uint8_t big_buf[distance_to_ram_bottom - 8]; for (size_t i = 0; i \u0026lt; sizeof(big_buf); i++) { big_buf[i] = i; } trigger_irq(); } Analysis (gdb) break main (gdb) continue Breakpoint 4, main () at ./cortex-m-fault-debug/main.c:182 182\txQueue = xQueueCreate(mainQUEUE_LENGTH, sizeof(unsigned long)); (gdb) set g_crash_config=4 (gdb) c Continuing. Program received signal SIGTRAP, Trace/breakpoint trap. 0x0000021c in my_fault_handler_c (frame=0x1fffffe0) at ./cortex-m-fault-debug/startup.c:91 91\tHALT_IF_DEBUGGING(); Let’s take a look at CFSR again to get a clue about what happened:\n(gdb) p/x *(uint32_t*)0xE000ED28 $39 = 0x1000 (gdb) svd SCB CFSR_UFSR_BFSR_MMFSR Fields in SCB CFSR_UFSR_BFSR_MMFSR: [...] STKERR: 1 Bus fault on stacking for exception entry Debug Tips when dealing with a STKERR There are two really important things to note when a stacking exception occurs:\nThe stack pointer will always reflect the correct adjusted position as if the hardware successfully stacked the registers. This means you can find the stack pointer prior to exception entry by adding the adjustment value. Depending on what access triggers the exception, the stacked frame may be partially valid. For example, the very last store of the hardware stacking could trigger the fault and all the other stores could be valid. However, the order the hardware pushes register state on the stack is implementation specific. So when inspecting the frame assume the values being looked at may be invalid! Taking this knowledge into account, let’s examine the stack frame:\n(gdb) p frame $40 = (sContextStateFrame *) 0x1fffffe0 Interestingly, if we look up the memory map of the NRF5216, we will find that RAM starts at 0x20000000. Our stack pointer location, 0x1fffffe0 is right below that in an undefined memory region. This must be why we faulted! We see that the stack pointer is 32 bytes below RAM, which matches the size of sContextStateFrame. This unfortunately means none of the values stacked will be valid since all stores were issued to a non-existent address space!\nWe can manually walk up the stack to get some clues:\n(gdb) x/a 0x20000000 0x20000000 \u0026lt;uxCriticalNesting\u0026gt;:\t0x3020100 (gdb) 0x20000004 \u0026lt;g_crash_config\u0026gt;:\t0x7060504 (gdb) 0x20000008 \u0026lt;xQueue\u0026gt;:\t0xb0a0908 (gdb) 0x2000000c \u0026lt;s_buffer\u0026gt;:\t0xf0e0d0c (gdb) 0x20000010 \u0026lt;s_buffer+4\u0026gt;:\t0x13121110 (gdb) 0x20000014 \u0026lt;s_buffer+8\u0026gt;:\t0x17161514 (gdb) 0x20000018 \u0026lt;pxCurrentTCB\u0026gt;:\t0x1b1a1918 (gdb) 0x2000001c \u0026lt;pxDelayedTaskList\u0026gt;:\t0x1f1e1d1c (gdb) 0x20000020 \u0026lt;pxOverflowDelayedTaskList\u0026gt;:\t0x23222120 It looks like the RAM has a pattern of sequentially increasing values and that the RAM addresses map to different variables in our code (i.e pxCurrentTCB). This suggests we overflowed the stack we were using and started to clobber RAM in the system until we ran off the end of RAM!\nTIP: To catch this type of failure sooner consider using an MPU Region\nSince the crash is reproducible, let’s leverage a watchpoint and see if we can capture the stack corruption in action! Let’s add a watchpoint for any access near the bottom of RAM, 0x2000000c:\n(gdb) mon reset (gdb) continue Breakpoint 4, main () at ./cortex-m-fault-debug/main.c:182 182\txQueue = xQueueCreate(mainQUEUE_LENGTH, sizeof(unsigned long)); (gdb) set g_crash_config=4 (gdb) watch *(uint32_t*)0x2000000c Hardware watchpoint 9: *(uint32_t*)0x2000000c TIP: Sometimes it will take a couple tries to choose the right RAM range to watch. It’s possible an area of the stack never gets written to and the watchpoint never fires or that the memory address being watched gets updated many many times before the actual failure. In this example, I intentionally opted not to watch 0x20000000 because that is the address of a FreeRTOS variable, uxCriticalNesting which is updated a lot.\nLet’s continue and see what happens:\n(gdb) continue Hardware watchpoint 9: *(uint32_t*)0x2000000c Old value = 0 New value = 12 0x000000c0 in stkerr_from_psp () at ./cortex-m-fault-debug/main.c:68 68\tbig_buf[i] = i; (gdb) bt #0 0x000000c0 in stkerr_from_psp () at ./cortex-m-fault-debug/main.c:68 #1 0x00000198 in prvQueuePingTask (pvParameters=\u0026lt;optimized out\u0026gt;) at ./cortex-m-fault-debug/main.c:162 #2 0x00001488 in ?? () at ./cortex-m-fault-debug/freertos_kernel/portable/GCC/ARM_CM4F/port.c:703 Backtrace stopped: previous frame identical to this frame (corrupt stack?) (gdb) list *0xc0 0xc0 is in stkerr_from_psp (./cortex-m-fault-debug/main.c:68). 63\textern uint32_t _start_of_ram[]; 64\tuint8_t dummy_variable; 65\tconst size_t distance_to_ram_bottom = (uint32_t)\u0026amp;dummy_variable - (uint32_t)_start_of_ram; 66\tvolatile uint8_t big_buf[distance_to_ram_bottom - 8]; 67\tfor (size_t i = 0; i \u0026lt; sizeof(big_buf); i++) { 68\tbig_buf[i] = i; 69\t} 70 71\ttrigger_irq(); 72\t} Great, we’ve found a variable located on the stack big_buf being updated. It must be this function call path which is leading to a stack overflow. We can now inspect the call chain and remove big stack allocations!\nRecovering from a UsageFault without a SYSRESET In this example we’ll just step through the code we developed above and confirm we don’t reset when a UsageFault occurs.\nCode void unaligned_double_word_read(void) { extern void *g_unaligned_buffer; uint64_t *buf = g_unaligned_buffer; *buf = 0x1122334455667788; } Analysis (gdb) break main (gdb) continue Breakpoint 4, main () at ./cortex-m-fault-debug/main.c:188 188\txQueue = xQueueCreate(mainQUEUE_LENGTH, sizeof(unsigned long)); (gdb) set g_crash_config=5 (gdb) c Continuing. Program received signal SIGTRAP, Trace/breakpoint trap. 0x00000228 in my_fault_handler_c (frame=0x200005e8 \u0026lt;ucHeap+1152\u0026gt;) at ./cortex-m-fault-debug/startup.c:94 94\tHALT_IF_DEBUGGING(); We have entered the breakpoint in the fault handler. We can step over it and confirm we fall through to the recover_from_task_fault function.\n(gdb) break recover_from_task_fault Breakpoint 12 at 0x1a8: file ./cortex-m-fault-debug/main.c, line 181. (gdb) n 108\tvolatile uint32_t *cfsr = (volatile uint32_t *)0xE000ED28; (gdb) c Continuing. Breakpoint 12, recover_from_task_fault () at ./cortex-m-fault-debug/main.c:181 181\tvoid recover_from_task_fault(void) { (gdb) list *recover_from_task_fault 0x1a8 is in recover_from_task_fault (./cortex-m-fault-debug/main.c:181). 181\tvoid recover_from_task_fault(void) { 182\twhile (1) { 183\tvTaskDelay(1); 184\t} 185\t} If we continue from here we will see the system happily keeps running because the thread which was calling the problematic trigger_crash function is now parked in a while loop. The the while loop could be extended in the future to delete and/or restart the FreeRTOS task if we wanted as well.\nClosing I hope this post gave you a useful overview of how to debug a HardFault on a Cortex-M MCU and that maybe you even learned something new!\nAre there tricks you like to use that I didn’t mention or other topics about faults you’d like to learn more about? Let us know in the discussion area below!\nInterested in learning more about debugging HardFaults? Watch this webinar recording..\nSee anything you\u0026rsquo;d like to change? Submit a pull request or open an issue at GitHub\nReferences The Tower of Terror: A Bug Mystery ↩ ↩2\nSee “A4.1.1 ARMv7-M and interworking support” ↩\nSegger JTrace \u0026amp; Lauterbach Trace32 are both capable of analyzing the ETM ↩\nSee “3.3.9 Auxiliary Bus Fault Status Register” ↩ ↩2\nSee “5.3.6.8 Reset behavior” ↩\nMBed OS fault handler ↩\nZephyr ARM fault handler ↩\nCMSIS-SVD ↩\nCMSIS Software Packs ↩\nPyCortexMDebug ↩\nSee “B1.5.5 Reset behavior” \u0026amp; “B1.4.2 The special-purpose program status registers, xPSR” ↩\nnRF52840 Development Kit ↩\nJLinkGDBServer ↩\nGNU ARM Embedded toolchain for download ↩\nSee B3.5.1 “Relation of the MPU to the system memory map” ↩\nSee “4.2.3 Memory map” ↩\nChris Coleman is a founder and CTO at Memfault. Prior to founding Memfault, Chris worked on the embedded software teams at Sun, Pebble, and Fitbit.\nDiscourseEmbed = { discourseUrl: \u0026lsquo;https://community.memfault.com/', discourseEmbedUrl: \u0026lsquo;https://interrupt.memfault.com/blog/cortex-m-hardfault-debug' }; (function() { var d = document.createElement(\u0026lsquo;script\u0026rsquo;); d.type = \u0026rsquo;text/javascript\u0026rsquo;; d.async = true; d.src = DiscourseEmbed.discourseUrl + \u0026lsquo;javascripts/embed.js\u0026rsquo;; (document.getElementsByTagName(\u0026lsquo;head\u0026rsquo;)[0] || document.getElementsByTagName(\u0026lsquo;body\u0026rsquo;)[0]).appendChild(d); })(); anchors.options.visible = \u0026lsquo;hover\u0026rsquo;; anchors.add(\u0026rsquo;.post-content \u0026gt; h1, h2, h3, h4, h5, h6\u0026rsquo;);\n","permalink":"uildDrafts/posts/p01-cortex-m-fault/","summary":"How to debug a HardFault on an ARM Cortex-M MCU 20 Nov 2019 by Chris Coleman\nFaults happen on embedded devices all the time for a variety of reasons – ranging from something as simple as a NULL pointer dereference to something more unexpected like running a faulty code path only when in a zero-g environment on the Tower of Terror in Disneyland1. It’s important for any embedded engineer to understand how to debug and resolve this class of issue quickly.","title":"How to debug a HardFault on an ARM Cortex-M MCU"},{"content":"32-bit 表示一个单精度浮点数 float\n$V=(-1)^s \\times M \\times 2^E$ 32-bit 分为3部分： S, E, M\nS: 符号位，1bit，0 表示正数， -1 表示负数 E: 指数位，8bit，取值[-127, 128]. M: 尾数位，23bit，取值[0, $2^{23}-1$]. 指数的底固定为2，指数有正数也有负数，但指数部分没有符号位，取一个中间值，小于中间值的表示负数，等于中间值的表示0，大于中间值的表示正数，中间值的定义如下：Bias=$2^{k-1}$-1, k表示E的bit数。实际的E为E-Bias.\n尾数部分隐藏了小数点前的1，实际为1.M。M转换为十进制从高位开始计算： $1+b_{22}\\times\\frac{1}{2}+b_{21}\\times\\frac{1}{4}+\u0026hellip;+b_{0}\\times\\frac{1}{2^{23}}$\n规格化的表示，E不是全0，也不是全1，M任意取值\nE全为0时，表示+0.0, -0.0和接近0.0的值\nE全为1，M全为0时，表示无穷，符号位区分正无穷和负无穷\nE全为1，M不全为0时，表示NaN，不是一个数。\n","permalink":"uildDrafts/posts/ieee745/","summary":"32-bit 表示一个单精度浮点数 float\n$V=(-1)^s \\times M \\times 2^E$ 32-bit 分为3部分： S, E, M\nS: 符号位，1bit，0 表示正数， -1 表示负数 E: 指数位，8bit，取值[-127, 128]. M: 尾数位，23bit，取值[0, $2^{23}-1$]. 指数的底固定为2，指数有正数也有负数，但指数部分没有符号位，取一个中间值，小于中间值的表示负数，等于中间值的表示0，大于中间值的表示正数，中间值的定义如下：Bias=$2^{k-1}$-1, k表示E的bit数。实际的E为E-Bias.\n尾数部分隐藏了小数点前的1，实际为1.M。M转换为十进制从高位开始计算： $1+b_{22}\\times\\frac{1}{2}+b_{21}\\times\\frac{1}{4}+\u0026hellip;+b_{0}\\times\\frac{1}{2^{23}}$\n规格化的表示，E不是全0，也不是全1，M任意取值\nE全为0时，表示+0.0, -0.0和接近0.0的值\nE全为1，M全为0时，表示无穷，符号位区分正无穷和负无穷\nE全为1，M不全为0时，表示NaN，不是一个数。","title":"IEEE745浮点数表示法"},{"content":"AES 对称密钥加密中最流行的算法之一, 除加密以外还可以用于构建消息认证码, 伪随机函数等密码工具\nAES的区块长度固定为128比特，密钥长度则可以是128，192或256比特\n分组密码工作模式 使用同一个区块密码密钥对多于一块的数据进行加密\n区块密码自身只能加密长度等于密码区块长度的单块数据，若要加密变长数据，则数据必须先被划分为一些单独的密码块\n最后一块数据也需要使用合适填充方式将数据扩展到符合密码块大小的长度\n一种工作模式描述了加密每一数据块的过程，并常常使用基于一个通常称为初始化向量的附加输入值以进行随机化，以保证安全。\n初始化向量IV 许多工作模式中用于将加密随机化的一个位块，由此即使同样的明文被多次加密也会产生不同的密文，避免了较慢的重新产生密钥的过程。\n初始化向量与密钥相比有不同的安全性需求，因此IV通常无须保密，然而在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个IV. 对于CBC和CFB，重用IV会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。 对于OFB和CTR而言，重用IV会导致完全失去安全性。\n在CBC模式中，IV在加密时必须是无法预测的. SSL2.0使用的采用上一个消息的最后一块密文作为下一个消息的IV，是不安全的\nPadding ECB和CBC需要最后一块在加密前进行填充\n在明文的最后填充空字符以使其长度为块长度的整数倍 在数据后添加一个1位，再添加足够的0位直到满足块长度的要求 添加一个值为128的字节（十六进制的80），再以0字节填满最后一个块 向最后一个块填充n个值均为n的字节 密文窃取 等等 常用模式 电子密码本（ECB） 需要加密的消息按照块密码的块大小被分为数个块，并对每个块进行独立加密。\n缺点在于同样的明文块会被加密成相同的密文块；它不能很好的隐藏数据模式。在某些场合，这种方法不能提供严格的数据保密性，因此并不推荐用于密码协议中。\n易受到重放攻击的影响，因为每个块是以完全相同的方式解密的.\n密码块链接（CBC） 每个明文块先与前一个密文块进行异或后，再进行加密. 为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。\n主要缺点在于加密过程是串行的，无法被并行化，而且消息必须被填充到块大小的整数倍。在解密时，从两个邻接的密文块中即可得到一个明文块。因此，解密过程可以被并行化.\n填充密码块链接（PCBC） 每个明文块先与前一个明文块和密文块进行异或后再进行加密, 互换两个邻接的密文块不会对后续块的解密造成影响\n密文反馈（CFB，Cipher feedback） 类似于CBC，可以将块密码变为自同步的流密码；工作过程亦非常相似，CFB的解密过程几乎就是颠倒的CBC的加密过程\n输出反馈模式（Output feedback, OFB） 将块密码变成同步的流密码。它产生密钥流的块，然后将其与明文块进行异或，得到密文。 与其它流密码一样，密文中一个位的翻转会使明文中同样位置的位也产生翻转。这种特性使得许多错误校正码，例如奇偶校验位，即使在加密前计算，而在加密后进行校验也可以得出正确结果。 每个使用OFB的输出块与其前面所有的输出块相关，因此不能并行化处理。然而，由于明文和密文只在最终的异或过程中使用，因此可以事先对IV进行加密，最后并行的将明文或密文进行并行的异或处理。\n计数器模式（CTR） CTR模式的特征类似于OFB，但它允许在解密时进行随机存取。由于加密和解密过程均可以进行并行处理，CTR适合运用于多处理器的硬件上。\n其他 消息认证码（MAC）通常由块密码得到，例如CBC-MAC（英语：CBC-MAC），OMAC（英语：One-key_MAC）和PMAC（英语：PMAC_(cryptography)）。\n认证加密也采用块密码作为其中的一部，其同时使用加密和MAC以提供保密性和数据完整性，例如IAPM（英语：IAPM_(mode)），CCM（英语：CCM_mode），CWC（英语：CWC_mode），EAX（英语：EAX_mode），GCM（英语：Galois/Counter_Mode）和OCB（英语：OCB_mode）。\n","permalink":"uildDrafts/posts/aes/","summary":"AES 对称密钥加密中最流行的算法之一, 除加密以外还可以用于构建消息认证码, 伪随机函数等密码工具\nAES的区块长度固定为128比特，密钥长度则可以是128，192或256比特\n分组密码工作模式 使用同一个区块密码密钥对多于一块的数据进行加密\n区块密码自身只能加密长度等于密码区块长度的单块数据，若要加密变长数据，则数据必须先被划分为一些单独的密码块\n最后一块数据也需要使用合适填充方式将数据扩展到符合密码块大小的长度\n一种工作模式描述了加密每一数据块的过程，并常常使用基于一个通常称为初始化向量的附加输入值以进行随机化，以保证安全。\n初始化向量IV 许多工作模式中用于将加密随机化的一个位块，由此即使同样的明文被多次加密也会产生不同的密文，避免了较慢的重新产生密钥的过程。\n初始化向量与密钥相比有不同的安全性需求，因此IV通常无须保密，然而在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个IV. 对于CBC和CFB，重用IV会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。 对于OFB和CTR而言，重用IV会导致完全失去安全性。\n在CBC模式中，IV在加密时必须是无法预测的. SSL2.0使用的采用上一个消息的最后一块密文作为下一个消息的IV，是不安全的\nPadding ECB和CBC需要最后一块在加密前进行填充\n在明文的最后填充空字符以使其长度为块长度的整数倍 在数据后添加一个1位，再添加足够的0位直到满足块长度的要求 添加一个值为128的字节（十六进制的80），再以0字节填满最后一个块 向最后一个块填充n个值均为n的字节 密文窃取 等等 常用模式 电子密码本（ECB） 需要加密的消息按照块密码的块大小被分为数个块，并对每个块进行独立加密。\n缺点在于同样的明文块会被加密成相同的密文块；它不能很好的隐藏数据模式。在某些场合，这种方法不能提供严格的数据保密性，因此并不推荐用于密码协议中。\n易受到重放攻击的影响，因为每个块是以完全相同的方式解密的.\n密码块链接（CBC） 每个明文块先与前一个密文块进行异或后，再进行加密. 为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。\n主要缺点在于加密过程是串行的，无法被并行化，而且消息必须被填充到块大小的整数倍。在解密时，从两个邻接的密文块中即可得到一个明文块。因此，解密过程可以被并行化.\n填充密码块链接（PCBC） 每个明文块先与前一个明文块和密文块进行异或后再进行加密, 互换两个邻接的密文块不会对后续块的解密造成影响\n密文反馈（CFB，Cipher feedback） 类似于CBC，可以将块密码变为自同步的流密码；工作过程亦非常相似，CFB的解密过程几乎就是颠倒的CBC的加密过程\n输出反馈模式（Output feedback, OFB） 将块密码变成同步的流密码。它产生密钥流的块，然后将其与明文块进行异或，得到密文。 与其它流密码一样，密文中一个位的翻转会使明文中同样位置的位也产生翻转。这种特性使得许多错误校正码，例如奇偶校验位，即使在加密前计算，而在加密后进行校验也可以得出正确结果。 每个使用OFB的输出块与其前面所有的输出块相关，因此不能并行化处理。然而，由于明文和密文只在最终的异或过程中使用，因此可以事先对IV进行加密，最后并行的将明文或密文进行并行的异或处理。\n计数器模式（CTR） CTR模式的特征类似于OFB，但它允许在解密时进行随机存取。由于加密和解密过程均可以进行并行处理，CTR适合运用于多处理器的硬件上。\n其他 消息认证码（MAC）通常由块密码得到，例如CBC-MAC（英语：CBC-MAC），OMAC（英语：One-key_MAC）和PMAC（英语：PMAC_(cryptography)）。\n认证加密也采用块密码作为其中的一部，其同时使用加密和MAC以提供保密性和数据完整性，例如IAPM（英语：IAPM_(mode)），CCM（英语：CCM_mode），CWC（英语：CWC_mode），EAX（英语：EAX_mode），GCM（英语：Galois/Counter_Mode）和OCB（英语：OCB_mode）。","title":"AES对称加密"},{"content":"Welcome The first post of hugo\nThis is a second header The third The fouth Fifty Six? amazing\nA math equation: \\(c^2 = a^2 + b^2\\)\nfull line equation: $$ e^e = \\pi $$\nA Table a a b b A complex latex equation $$\\begin{array}{cc} a \u0026amp; b \\\\ c \u0026amp; d \\end{array}$$\n$$\\begin{bmatrix} a \u0026amp; b \\newline c \u0026amp; d \\end{bmatrix}$$\n","permalink":"uildDrafts/posts/my-first-post/","summary":"Welcome The first post of hugo\nThis is a second header The third The fouth Fifty Six? amazing\nA math equation: \\(c^2 = a^2 + b^2\\)\nfull line equation: $$ e^e = \\pi $$\nA Table a a b b A complex latex equation $$\\begin{array}{cc} a \u0026amp; b \\\\ c \u0026amp; d \\end{array}$$\n$$\\begin{bmatrix} a \u0026amp; b \\newline c \u0026amp; d \\end{bmatrix}$$","title":"My First Post"},{"content":"Cyclic Group 定义 $$\\langle\\mathbb{G},q,g \\rangle$$\n\\(\\mathbb{G}=\\langle \\mathbb{Z}_{n}, \\cdot \\rangle\\)\n\\(\\mathbb{Z}_{n} \\)是一个集合, {$0$\u0026hellip;$n-1$}.\n\\(\\cdot\\)是集合中的运算符.\n对\\(\\mathbb{G}\\)中的元素$a$进行$k$次幂运算表示为\\(a^{k}=a \\cdot a \u0026hellip;\\cdot a\\), 即$k$个$a$进行$\\cdot$运算.\n若群$\\mathbb{G}$的每一个元素都是$\\mathbb{G}$的某一个固定元素$a$的幂，则称$\\mathbb{G}$为循环群.\n$q$是$\\mathbb{G}$的order, $q$的值等于$\\mathbb{G}$中元素的个数, 也记为$|\\mathbb{G}|$.\n$g$是$\\mathbb{G}$的generator(生成元), $\\mathbb{G}$中的所有元素都能由$g$通过幂运算生成.\n由群$\\mathbb{G}$, 阶$q$和生成元$g$, 即可定义一个循环群.\n如何寻找一个生成元 如果$\\mathbb{G}$有素数阶$p$, 则$\\mathbb{G}$中除了identity之外的所有元素都是$\\mathbb{G}$的生成元.\n如果$p$是素数, 则$\\mathbb{Z}_{p}^{*}$是阶为$p-1$的循环群.\n假设$\\mathbb{G}$阶非素数$p$, 可以均匀的从$\\mathbb{G}$中采样元素, 直到这个元素是一个生成元.\n$\\mathbb{G}$的阶$q$有素数因数$\\{p_{i}\\}^k_{i=1}$, 检查元素$h$是否为生成元\nfor $i = 1$ to $k$ : if $h^{q/p_{i}}=1$ return \u0026ldquo;$h$ is not a generator\u0026rdquo; return \u0026ldquo;$h$ is a generator\u0026rdquo; $\\mathbb{G}$有阶$q$,生成元$g$, 则任意一个元素可以表示为$h=g^{x}$.\n当gcd($x,q$)=1时, $h$也是$\\mathbb{G}$的一个生成元. Oblivious Transfer from Cyclic Group Reference:\nMore efficient oblivious transfer and extensions for faster secure computation\nAsharov G, Lindell Y, Schneider T, et al.\nProceedings of the 2013 ACM SIGSAC conference on Computer \u0026amp; communications security.\n以下方案基于DDH假设.\nFast Notes Input Sender and Receiver agree on $\\langle\\mathbb{G},q,g \\rangle$. Sender and Receiver agree on Hash. Sender: n个 ($x_{i}^{0}, x_{i}^{1}$) pair Receiver: n个 bit ($\\sigma_{1},\u0026hellip;,\\sigma_{n}$) Receiver do $\\alpha_{i}\\in_{R}\\mathbb{Z}_{q}$ $h_{i}\\in_{R}\\mathbb{G}$ $h_{i}^{0}= (\\sigma_{i} == 0) \\ ?\\ g^{\\alpha_{i}} : h_{i}$ $h_{i}^{1}= (\\sigma_{i} == 0) \\ ?\\ h_{i} : g^{\\alpha_{i}}$ send $n$ pair $(h_{i}^{0}, h_{i}^{1})$ to Sender. Sender do $r\\in_{R}\\mathbb{Z}_{q}$ $u=g^{r}$ $k_{i}^{0}, k_{i}^{1} = (h_{i}^{0})^{r}, (h_{i}^{1})^{r}$ $v_{i}^{0}, v_{i}^{1} = x_{i}^{0} \\oplus \\text{Hash}(k_{i}^{0}), x_{i}^{1} \\oplus \\text{Hash}(k_{i}^{1})$ send $u$ to Receiver. send n pair $(v_{i}^{0}, v_{i}^{1})$. Receiver do $k_{i}^{\\sigma_{i}} = u^{\\alpha_{i}}$ $x_{i}^{\\sigma_{i}} = v_{i}^{\\sigma_{i}} \\oplus \\text{Hash}(k_{i}^{\\sigma_{i}})$ Receiver outputs $\\{x_{i}^{\\sigma_i}\\}$, Sender has no output. Discussion $x$应当和Hash的长度保持一致, 或者小于Hash的长度, 否则$v$的头几位会泄露$x$的信息. 如果Hash的长度与$k$的长度一致, 由于$k$是$\\mathbb{G}$中的元素, $x$也应是$\\mathbb{G}$中的元素, 否则会泄露$x$的信息. 最好的情况是, S和R约定好Hash, 可以从较短的$k$中产生较长的Hash$(k)$, 那么此时也应约定好$x$的bit长度$l$. OT传输的信息长度可能会变, 也可能太长, 如果导致计算的开销过高, 或许可以通过与对称密码结合的方法, 用OT传输秘钥, 用秘钥加密$x$, 从而让Receiver获得秘钥来解密密文. 此时对称加密的秘钥长度就可以固定下来. 不过对称加密如AES本身秘钥的长度就达到了129,192和256, 或许已经超过了$\\mathbb{G}$的长度. MPC中最用的两中有限域是$prime$域和$2k$域$\\mathbb{G}_{p}$和$\\mathbb{G}_{2^k}$, 理论上来说素数域的效率会更高一些, 而2k域正好对应计算时32bit, 64bi的数据范围. ","permalink":"uildDrafts/posts/otandcylicgroup/","summary":"Cyclic Group 定义 $$\\langle\\mathbb{G},q,g \\rangle$$\n\\(\\mathbb{G}=\\langle \\mathbb{Z}_{n}, \\cdot \\rangle\\)\n\\(\\mathbb{Z}_{n} \\)是一个集合, {$0$\u0026hellip;$n-1$}.\n\\(\\cdot\\)是集合中的运算符.\n对\\(\\mathbb{G}\\)中的元素$a$进行$k$次幂运算表示为\\(a^{k}=a \\cdot a \u0026hellip;\\cdot a\\), 即$k$个$a$进行$\\cdot$运算.\n若群$\\mathbb{G}$的每一个元素都是$\\mathbb{G}$的某一个固定元素$a$的幂，则称$\\mathbb{G}$为循环群.\n$q$是$\\mathbb{G}$的order, $q$的值等于$\\mathbb{G}$中元素的个数, 也记为$|\\mathbb{G}|$.\n$g$是$\\mathbb{G}$的generator(生成元), $\\mathbb{G}$中的所有元素都能由$g$通过幂运算生成.\n由群$\\mathbb{G}$, 阶$q$和生成元$g$, 即可定义一个循环群.\n如何寻找一个生成元 如果$\\mathbb{G}$有素数阶$p$, 则$\\mathbb{G}$中除了identity之外的所有元素都是$\\mathbb{G}$的生成元.\n如果$p$是素数, 则$\\mathbb{Z}_{p}^{*}$是阶为$p-1$的循环群.\n假设$\\mathbb{G}$阶非素数$p$, 可以均匀的从$\\mathbb{G}$中采样元素, 直到这个元素是一个生成元.\n$\\mathbb{G}$的阶$q$有素数因数$\\{p_{i}\\}^k_{i=1}$, 检查元素$h$是否为生成元\nfor $i = 1$ to $k$ : if $h^{q/p_{i}}=1$ return \u0026ldquo;$h$ is not a generator\u0026rdquo; return \u0026ldquo;$h$ is a generator\u0026rdquo; $\\mathbb{G}$有阶$q$,生成元$g$, 则任意一个元素可以表示为$h=g^{x}$.\n当gcd($x,q$)=1时, $h$也是$\\mathbb{G}$的一个生成元. Oblivious Transfer from Cyclic Group Reference:\nMore efficient oblivious transfer and extensions for faster secure computation","title":"Oblivious Transfer and Cyclic Group"},{"content":"Control a Bluetooth Device via Bluetoothctl 1. Overview In this tutorial, we’ll learn how to connect to a Bluetooth device via the terminal. This process involves configuring our Bluetooth controller, pairing it to our target device, and then finally connecting.\n2. Using the bluetoothctl Command BlueZ provides support for Bluetooth functionality and protocols through the bluetoothd daemon. To interact with bluetoothd from the terminal, we use the bluetoothctl command.\nLet’s begin by running bluetoothctl without any arguments:\n$ bluetoothctl Agent registered [bluetooth]# Using bluetoothctl by itself will open the interactive shell. This is called interactive mode and is where we can run commands to configure our Bluetooth settings.\nTo get more information about using interactive mode, let’s run the help command in the interactive shell:\nfreestar.config.enabled_slots.push({ placementName: \u0026ldquo;baeldung_leaderboard_mid_1\u0026rdquo;, slotId: \u0026ldquo;baeldung_leaderboard_mid_1\u0026rdquo; });\n[bluetooth]# help Menu main: Available commands: ------------------- advertise Advertise Options Submenu monitor Advertisement Monitor Options Submenu ... Running help in the shell will list all available commands for bluetoothctl interactive mode with a short summary of what they do.\nSometimes, however, we want to run a command outside of the interactive shell. Luckily, there’s also a non-interactive mode in bluetoothctl, which we can use by running an individual command:\n$ bluetoothctl --help bluetoothctl ver 5.64 Usage: bluetoothctl [--options] [commands] Options: --agent Register agent handler: ... 3. Preparing Our Bluetooth Controller Now that we know the basics of using bluetoothctl, let’s begin preparing our Bluetooth controller.\n3.1. Configuring a Bluetooth Controller Let’s begin to configure our Bluetooth controller by using the show command:\n$ bluetoothctl show 00:1A:7D:DA:71:15 Controller 00:1A:7D:DA:71:15 (public) Name: pc-m Alias: pc-m Class: 0x00000000 Powered: no Discoverable: no DiscoverableTimeout: 0x00000000 Pairable: no ... Discovering: no ... Typically, the bluetoothctl show command will output a large amount of information. However, we just need to ensure our controller is powered-on, discoverable, and pairable.\nLet’s start by powering on our controller:\n$ bluetoothctl power on [CHG] Controller 00:1A:7D:DA:71:15 Class: 0x006c0104 Changing power on succeeded We can use the bluetoothctl power on command to power on our controller. It’s important to power on our Bluetooth controller before modifying other controller attributes.\nNext, we should set the controller to be discoverable and pairable:\n$ bluetoothctl discoverable on Changing discoverable on succeeded $ bluetoothctl pairable on Changing pairable on succeeded We set the controller to discoverable using the command bluetoothctl discoverable on, and then we use the bluetoothctl pairable on command to set our controller to pairable. The output of these commands shows that they were successful.\n3.2. Using Multiple Bluetooth Controllers When using multiple Bluetooth controllers, we must ensure we select the correct one before configuring.\nfreestar.config.enabled_slots.push({ placementName: \u0026ldquo;baeldung_leaderboard_mid_3\u0026rdquo;, slotId: \u0026ldquo;baeldung_leaderboard_mid_3\u0026rdquo; });\nLet’s use the bluetoothctl list command to get a list of connected Bluetooth controllers:\n$ bluetoothctl list Controller 00:1A:7D:DA:71:15 pc-m [default] Controller 34:02:86:03:7C:F2 pc-m #2 This command outputs information about the connected Bluetooth controllers, including their MAC addresses and what the default controller is. The default controller is the controller that will be operated on when we run a command.\nTo change the default controller, we use the bluetoothctl select command, passing the MAC address of the controller we want to connect to:\n[bluetooth]# select 34:02:86:03:7C:F2 Controller 34:02:86:03:7C:F2 pc-m [default] [bluetooth]# list Controller 00:1A:7D:DA:71:15 pc-m Controller 34:02:86:03:7C:F2 pc-m #2 [default] In this example, we used the select command in interactive mode. Non-interactive mode opens up a new session per command, but the interactive shell maintains the same session until exited. Since the select command only changes the default controller for the current session, it will only work within interactive mode.\nHowever, there is a way we can use select in a similar way to non-interactive mode:\n$ bluetoothctl \u0026lt;\u0026lt;\u0026lt; $'select 34:02:86:03:7C:F2\\nlist\\n' ... [bluetooth]# select 34:02:86:03:7C:F2 Controller 34:02:86:03:7C:F2 pc-m [default] [bluetooth]# list Controller 00:1A:7D:DA:71:15 pc-m Controller 34:02:86:03:7C:F2 pc-m #2 [default] In this example, we use a here-string to redirect our string to stdin. This causes the bluetoothctl shell to treat the string as user input and allows us to automate the process of using interactive mode. Our string can contain as many commands as want as long as we end each with a newline.\n4. Connect a Bluetooth Device Using the Terminal After configuring our Bluetooth controller, we can begin pairing and connecting our device.\n4.1. Pairing a Bluetooth Device Now, we can begin to pair our Bluetooth device to our controller. To start, we should turn our controller to discovery mode:\n$ bluetoothctl scan on Discovery started [CHG] Controller 00:1A:7D:DA:71:15 Discovering: yes ^Z [1]+ Stopped bluetoothctl scan on To set the controller to discovery mode, we use the bluetoothctl scan on command. However, this command is a foreground job, which means that we won’t be able to use the terminal until it is finished. So, we put it in the background using Ctrl-Z.\nNow, let’s output the discovered devices using bluetoothctl devices:\n$ bluetoothctl devices Device 3C:4D:BE:84:1F:BC MyEarbuds Device 60:B7:6E:35:39:0D MyPhone The output shows us any discovered devices with their names and MAC addresses. The important part is the MAC address, which we use to pair devices.\nOnce we know the MAC address of our device, we can begin pairing. Let’s use the bluetoothctl pair command to pair to our device with the name “MyEarbuds”:\n$ bluetoothctl pair 3C:4D:BE:84:1F:BC Attempting to pair with 3C:4D:BE:84:1F:BC [CHG] Device 3C:4D:BE:84:1F:BC Connected: yes ... [CHG] Device 3C:4D:BE:84:1F:BC Paired: yes Pairing successful We can pair a device by using the device’s MAC address as an argument to the bluetoothctl pair command. The output will tell us if our device paired successfully or not.\nNow that our device is paired, we don’t need to be in discovery mode anymore. To exit discovery mode, we must end the bluetoothctl scan command that we put into the background:\n$ fg bluetoothctl scan on ^C To stop a background job, we use the fg command to bring the bluetoothctl scan into the foreground. Then we press Ctrl-C to stop the program.\n4.2. Connecting a Bluetooth Device Let’s start connecting to our Bluetooth device using bluetoothctl connect:\nfreestar.config.enabled_slots.push({ placementName: \u0026ldquo;baeldung_incontent_2\u0026rdquo;, slotId: \u0026ldquo;baeldung_incontent_2\u0026rdquo; });\n$ bluetoothctl connect 3C:4D:BE:84:1F:BC Attempting to connect to 3C:4D:BE:84:1F:BC ... Connection successful We can connect a paired Bluetooth device by using its MAC address with the bluetoothctl connect command. The output will show whether we successfully connected to our device or not.\n4.3. Disconnecting a Bluetooth Device Likewise, we can disconnect our device using the bluetoothctl disconnect command, again passing the MAC address of the device we want to disconnect:\n$ bluetoothctl disconnect 3C:4D:BE:84:1F:BC Attempting to disconnect from 3C:4D:BE:84:1F:BC ... Successful disconnected The output shows us that our device was successfully disconnected.\n5. Overview In this article, we learned how to connect a Bluetooth device via the Linux terminal. We began by learning the basics of the bluetoothctl command. Then, we learned about configuring a Bluetooth controller. Finally, we learned how to pair and then connect a Bluetooth device.\n","permalink":"uildDrafts/posts/control-bluetooth-device-via-bluetoothctl/","summary":"Control a Bluetooth Device via Bluetoothctl 1. Overview In this tutorial, we’ll learn how to connect to a Bluetooth device via the terminal. This process involves configuring our Bluetooth controller, pairing it to our target device, and then finally connecting.\n2. Using the bluetoothctl Command BlueZ provides support for Bluetooth functionality and protocols through the bluetoothd daemon. To interact with bluetoothd from the terminal, we use the bluetoothctl command.\nLet’s begin by running bluetoothctl without any arguments:","title":""},{"content":"Linux Kernel Module Programming Guide [TOC]\nEasy Begin 内核模块包 编程内核模块首先要安装内核模块包kmod.\nsudo apt-get install build-essential kmod 命令行的内核模块相关命令 sudo lsmod # 查看所有加载进内核的模块 sudo cat /proc/modules # 和lsmod有什么不同 sudo modinfo ABC_x.ko # 查看模块ABC的信息 sudo insmod ABC_x.ko # 向内核中加载模块ABC sudo rmmod ABC-x # 从内核中卸载模块ABC, 注意ABC_x.ko名称中的\u0026#39;_\u0026#39;字符会被内核自动替换成\u0026#39;-\u0026#39;字符 sudo journalctl --since \u0026#34;1 hour ago\u0026#34; | grep kernel # 查看过去一小时内的内核日志 编码前须知 版本. 如果编译模块A时include的内核头文件版本与加载模块A的内核版本不一致, 会导致加载失败. 如果必须要这样做, 例如模块A兼容多个内核版本, 需要启用CONFIG_MODVERSIONS编译制导. 命令行. 内核模块无法打印输出到屏幕,但可以记录日志信息然后读取日志信息到屏幕. SecureBoot. SecureBoot是UEFI的一个设置, 要求只会引导安全密钥签名过的模块. [Shell]ERROR: could not insert module. [dmesg]Lockdown: insmod: unsigned module loading is restricted; see man kernel lockdown.7. SecureBoot - Debian Wiki 内核头文件 编译模块必需内核头文件, 编译时Makefile也需要include内核头文件所在文件夹.\n// 查看系统内核版本 \u0026gt; uname -r 6.1.21-v8+ sudo apt-get update // 查看对于内核头文件是否在源仓库中 sudo apt-cache search linux-headers-`uname -r` // 下载(到/usr/src文件夹下) sudo apt-get install linux-headers-`uname -r` rpi的rpi-os中的Debian源里没有对应版本的内核头文件, 但是rpi自己提供了一份.\n// 不需要指定版本 sudo apt-get install raspberrypi-kernel-headers 编码规范 缩进使用tabs而非spaces. 提交patch到上游时必须遵守. pr_info和pr_debugin include/linux/printk.h kbuild, Documentation/kbuild/modules.rst Makefile, Documentation/kbuild/makefiles.rst 一个极简内核模块示例 #include \u0026lt;linux/module.h\u0026gt; /* needed by all modules */ #include \u0026lt;linux/init.h\u0026gt; /* needed for macros */ #include \u0026lt;linux/printk.h\u0026gt; /* needed for pr_info */ /* __initdata macro修饰下的变量在init完成时会被丢弃并释放内存(适用于built-in driver, 对loadable driver没有影响) */ static int hello_data __initdata = 3; /* 模块接受一个基本类型参数的声明方法 */ static int input_data = 1; module_param(input_data, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP); MODULE_PARM_DESC(input_data, \u0026#34;a int input\u0026#34;); /* 模块接收一个字符串参数的声明方法 */ static char* input_string = \u0026#34;???\u0026#34;; // 字符串的最大长度不需要定义 module_param(input_string, charp, 0000); MODULE_PARM_DESC(input_string, \u0026#34;a string input\u0026#34;); /* 模块接受一个数组类型参数的声明方法 */ static int input_array[2] = {0, 1}; // 预先定义数组的最大长度, 输入数组不足最大长度的位置依然保持这里静态声明的默认值 static int input_array_argc = 0; // number of array elements module_param_array(input_array, int, \u0026amp;input_array_argc, 0000); MODULE_PARM_DESC(input_array, \u0026#34;a int array input\u0026#34;); /* __init macro 修饰下的init函数在完成时会被丢弃并释放内存(适用于built-in driver, 对loadable driver没有影响) 因为built-in driver只加载进内核一次 */ static int __init hello_init(void) { pr_info(\u0026#34;hello %d %d\\n\u0026#34;, hello_data, input_data); return 0; } /* __exit macro 修饰下的exit函数会被忽略(适用于built-in driver, 对loadable driver没有影响) 因为built-in driver不会被卸载出内核 */ static int __exit hello_exit(void) { pr_info(\u0026#34;bey\\n\u0026#34;); return 0; } module_init(hello_init); module_exit(hello_exit); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); MODULE_AUTHOR(\u0026#34;fanyx\u0026#34;); MODULE_DESCRIPTION(\u0026#34;A simple driver\u0026#34;); # 加载内核时, 按照名称赋参数值 sudo insmod hello.ko input_int=1 input_string=\u0026#34;hehe\u0026#34; input_array=-1,-1 编译多个文件组成的模块 \u0026gt; ls start.c stop.c obj-m += hello.o # 增加一个object hello hello-objs := start.o stop.o # 声明hello object包含的文件 PWD := %(CURDIR) all: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean 设备驱动程序视角下的内核模块 Linux Kernel Module的一个重要类型是Device Driver. 物理设备抽象为文件，存放在/dev目录下面。通过 cat /proc/devices 可以查看所有设备。\nDevice分为两种，Char Device和Block Device\n模块如何开始和结束 模块可用的函数 dmesg读取模块日志 Message logging with printk — The Linux Kernel documentation\nName String Alias Function KERN_EMERG \u0026ldquo;0\u0026rdquo; pr_emerg() KERN_ALERT \u0026ldquo;1\u0026rdquo; pr_alert() KERN_CRIT \u0026ldquo;2\u0026rdquo; pr_crit() KERN_ERR \u0026ldquo;3\u0026rdquo; pr_err() KERN_WARNING \u0026ldquo;4\u0026rdquo; pr_warn() KERN_NOTICE \u0026ldquo;5\u0026rdquo; pr_notice() KERN_INFO \u0026ldquo;6\u0026rdquo; pr_info() KERN_DEBUG \u0026ldquo;7\u0026rdquo; pr_debug() and pr_devel() if DEBUG is defined # 查看当前console loglevel $ cat /proc/sys/kernel/printk 4 4 1 7 #current,default,minimun,boot-time-default # 修改当前console loglevel $ dmesg -n 5 优先级高于(越小越高)当前console_loglevel的日志会立刻出现在console上.\nUser Space vs Kernel Space Name Space Code Space Device Driver 字符设备驱动程序 Charactor Device Driver\nstruct file_operation struct file 注册一个设备 注销一个设备 示例程序 兼容多个内核版本 /proc: Module向Process发送信息 struct proc_ops 读、写/proc 文件 通过标准文件系统管理/proc文件 通过seq_file管理/proc文件 /sys：读写Module内部的变量 与设备文件对话 using device file to write things to the physical device write device\u0026rsquo;s commands write data to be sent through the device using device file to read things from the physical device read responses for device\u0026rsquo;s commands read data received through the device Unix ioctl机制实现以上功能\nSystem Calls System Call是真正的process to kernel communication mechanism 一般来说，process不能访问kernel(既不能访问kernel memory也不能调用kernel function)，这是CPU从硬件上保证的(称为protected mode 或者 page protection) system call是一个例外。process向特定的寄存器中填充参数，然后调用一个特别的指令跳转到kernel中预先定义好的位置。当程序跳转到这个位置的时候，硬件就知道程序不再以受限模式运行，而是处于kernel中。这个可以让process跳转到kernel当中的特别的指令就是system_call. system_call的过程是这样的:\n检查system call number, 从而告诉kernel是哪个服务被请求 查看sys_call_table获得对应kernel function的地址 调用查找到的kernel function 等待调用的kernel function返回 做一些system check,然后返回到process当中 如果process时间用完了,会返回到别的process. 这一部分代码在arch/$(architecture)/kernel/entry.S中ENTRY(system_call)的位置. 如果我想改变一个system call的行为, 假设这个system call的符号是system_call_1, 对应的kernel function符号是system_call_1_cb. 我需要自己实现一个函数my_system_call_1_cb(通常只用在my_system_call_1_cb里写一点点定制的代码,然后在末尾调用system_call_1_cb), 然后在sys_call_table中存的system_call_1_cb的指针换成my_system_call_1_cb就可以了. 注意:如果我在module里覆盖了一个system call, 当这个module加载进kernel然后再卸载出kernel之后, sys_call_table中被修改的指针没有改回去, 务必记得在cleanup_module中将sys_call_table恢复到原来的状态.\n如何修改sys_call_table的内容?\n# 不是su权限查看不到kernel中的symbol和address信息, address会返回全零 $\u0026gt; cat /proc/kallsyms | grep sys_call_table 0000000000000000 R sys_call_table 0000000000000000 R compat_sys_call_table $\u0026gt; sudo cat /proc/kallsyms | grep sys_call_table ffffffebcd190938 R sys_call_table ffffffebcd196a38 R compat_sys_call_table 注意:不要在生产用途中篡改任何system call. 举一个导致系统崩溃的例子, 假设module A实现了A_openat用于篡改打开文件的system call openat, module B实现了B_openat用于篡改openat. 如果module A先加载进kernel, module B再加载进kernel, 然后module A先从kernel中卸载, module B再从kernel中卸载. 最终这个system call对应的kernel function pointer指向A_openat, 但是module A已经从kernel中卸载, 就变成了一个野指针, 再次调用这个system call就会导致kernel crash.\n阻塞Processes和Threads Sleep 当module当前无法回应process的请求的时候,可以将这个process sleep, 直到可以回应的时候再唤醒.\nstatic DECLARE_WAIT_QUEUE_HEAD(waitq); wait_event_interruptible(waitq,); wake_up(\u0026amp;waitq); module_put(THIS_MODULE); Completions 在一个module内部,有时需要面对多线程执行的先后顺序的问题. Kernel有一种允许timeout和interrupt的实现方式, 就是Completion.\nstatic struct { struct completion a_comp; struct completion b_comp; } machine; // 声明machine变量(具有匿名类型) static int machine_thread_a(void *arg) { completion_all(\u0026amp;machine.a_comp); kthread_complete_and_exit(\u0026amp;machine.a_comp, 0); } static int machine_thread_b(void *arg) { // 等待completion a_comp完成 wait_for_completion(\u0026amp;machine.a_comp); completion_all(\u0026amp;machine.b_comp); kthread_complete_and_exit(\u0026amp;machine.b_comp, 0); } static int mod_use_completion_init(void) { // 声明两个task struct task_struct *thread_a; struct task_struct *thread_b; pr_info(\u0026#34;example of completion\\n\u0026#34;); // 初始化completion init_completion(\u0026amp;machine.a_comp); init_completion(\u0026amp;machine.b_comp); // 创建thread_a thread_a = kthread_create(machine_thread_a, NULL, \u0026#34;KThread a\u0026#34;); if (IS_ERR(thread_a)) { goto ERROR_THREAD_A; } // 创建thread_b thread_b = kthread_create(machine_thread_b, NULL, \u0026#34;KThread b\u0026#34;); if (IS_ERR(thread_b)) { goto ERROR_THREAD_B; } // wake_up_process(thread_a); wake_up_process(thread_b); return 0; ERROR_THREAD_B: kthread_stop(thread_a); ERROR_THREAD_A: return -1; } static void mod_use_completion_exit(void) { wait_for_completion(\u0026amp;machine.a_comp); wait_for_completion(\u0026amp;machine.b_comp); } module_init(mod_use_completion_init); module_exit(mod_use_completion_exit); 此外还有一些基于wait_for_completion函数而来的变体函数(可以设置timeout或者可以设置interrupt). 一般来说wait_for_completion足以满足绝大部分场景.\n避免Collision和Deadlock Mutex Spinlocks Read and write locks Atomic operations Mutex static DEFINE_MUTEX(my_mutex); mutex_trylock(\u0026amp;my_mutex); mutex_is_locked(\u0026amp;my_mutex); mutex_unlock(\u0026amp;my_mutex); Spinlocks 自旋锁会锁住代码正在运行的CPU, 并占用其100%的资源. 最好只在预期运行时间不超过几毫秒, 并且用户看不出任何事物明显变慢的代码上使用.\nRead and write locks 读写锁是一种特化的自旋锁.\nstatic DEFINE_RWLOCK(my_rwlock); unsigned long flags; read_lock_irqsave(\u0026amp;my_rwlock, flags); read_unlock_irqrestore(\u0026amp;my_rwlock, flags); write_lock_irqsave(\u0026amp;my_rwlock, flags); write_unlock_irqrestore(\u0026amp;my_rwlock, flags); Atomic operations 练习: Replacing Print Macros printk.h中定义的Print Macros将字符串发送到日志当中, 当是有时, 我想让模块将字符串发送到执行了加载这个模块的命令的tty(teletype, text stream abstraction of )当中.\nstatic void print_string(char *str) { /* The tty for the current task */ struct tty_struct *my_tty = get_current_tty(); /* If my_tty is NULL, the current task has no tty you can print to (i.e., * if it is a daemon). If so, there is nothing we can do. */ if (my_tty) { const struct tty_operations *ttyops = my_tty-\u0026gt;driver-\u0026gt;ops; /* my_tty-\u0026gt;driver is a struct which holds the tty\u0026#39;s functions, * one of which (write) is used to write strings to the tty. * It can be used to take a string either from the user\u0026#39;s or * kernel\u0026#39;s memory segment. * * The function\u0026#39;s 1st parameter is the tty to write to, because the * same function would normally be used for all tty\u0026#39;s of a certain * type. * The 2nd parameter is a pointer to a string. * The 3rd parameter is the length of the string. * * As you will see below, sometimes it\u0026#39;s necessary to use * preprocessor stuff to create code that works for different * kernel versions. The (naive) approach we\u0026#39;ve taken here does not * scale well. The right way to deal with this is described in * section 2 of * linux/Documentation/SubmittingPatches */ (ttyops-\u0026gt;write)(my_tty, str, strlen(str)); /* ttys were originally hardware devices, which (usually) strictly * followed the ASCII standard. In ASCII, to move to a new line you * need two characters, a carriage return(回车) and a line feed(换行). * On Unix, the ASCII line feed is used for both purposes - so we can not * just use \\n, because it would not have a carriage return and the * next line will start at the column right after the line feed. * * This is why text files are different between Unix and MS Windows. * In CP/M and derivatives, like MS-DOS and MS Windows, the ASCII * standard was strictly adhered to, and therefore a newline requires * both a LF and a CR. */ (ttyops-\u0026gt;write)(my_tty, \u0026#34;\\015\\012\u0026#34;, 2); } } 练习: Flashing keyboard LEDs #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/kd.h\u0026gt; /* For KDSETLED, */ #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/tty.h\u0026gt; /* For tty_struct */ #include \u0026lt;linux/vt.h\u0026gt; /* For MAX_NR_CONSOLES, the max number of virtual console supported by kerntl */ #include \u0026lt;linux/vt_kern.h\u0026gt; /* for fg_console, fg_console is the current virtual console */ #include \u0026lt;linux/console_struct.h\u0026gt; /* For vc_cons, the list of virtual consoles */ static struct tty_driver *this_tty_driver; static struct timer_list this_timer; #define BLINK_DELAY (HZ / 5) #define ALL_LED_ON 0x07 #define RESTORE_LEDS 0xFF static void timer_fn(struct timer_list *unused) { struct tty_struct *t = vc_cons[fg_console].d-\u0026gt;port.tty; if (kbledstatus == ALL_LEDS_ON){ kbledstatus = RESTORE_LEDS; }else{ kbledstatus = ALL_LEDS_ON; } (this_tty_driver-\u0026gt;ops-\u0026gt;ioctl)(t, KDSETLED, kbledstatus); this_timer.expires = jiffies + BLINK_DELAY; add_timer(\u0026amp;this_timer); } static int __init kbleds_init(void) { int i; pr_info(\u0026#34;kbleds: scanning consoles...\\n\u0026#34;); pr_info(\u0026#34;kbleds: fg_console %x\\n\u0026#34;, fg_console); for (int i = 0; i \u0026lt; MAX_NR_CONSOLES; i++) { if (NULL == vc_cons[i].d){ break; } pr_info(\u0026#34;poet_atkm: console[%i/%i] #%i, tty %p\\n\u0026#34;, i, MAX_NR_CONSOLES, vc_cons[i].d-\u0026gt;vc_num, (void *)vc_cons[i].d-\u0026gt;port.tty); } pr_info(\u0026#34;kbleds: scan consoles ends\u0026#34;); this_tty_driver = vc_cons[fg_console].d-\u0026gt;port.tty-\u0026gt;driver; pr_info(\u0026#34;kbleds: tty driver magic %x\\n\u0026#34;, this_tty_driver-\u0026gt;magic); timer_setup(\u0026amp;this_timer, timer_fn, 0); this_timer.expires = jiffies + BLINK_DELAY; add_timer(\u0026amp;this_timer); return 0; } static int __exit kbleds_exit(void) { pr_info(\u0026#34;kbleds: exit\\n\u0026#34;); del_timer(\u0026amp;this_timer); (this_tty_driver-\u0026gt;ops-\u0026gt;ioctl)(vc_cons[fg_console].d-\u0026gt;port.tty, KDSETLED, RESTORE_LEDS); } Task Schedule Tasklets Work queues Tasklets static void my_task_fn(unsigned long data) { pr_info(\u0026#34;example tasklet starts\\n\u0026#34;); mdelay(5000); pr_info(\u0026#34;example tasklet ends\u0026#34;); } static DECLEARE_TASKLET(my_task, my_task_fn, 0L); static int example_tasklet_init(void) { pr_info(\u0026#34;tasklet example init\\n\u0026#34;); tasklet_schedule(\u0026amp;my_task); mdelay(2000); pr_info(\u0026#34;example tasklet continues...\\n\u0026#34;); return 0; } static void example_tasklet_exit(void) { pr_info(\u0026#34;tasklet example exit\\n\u0026#34;); tasklet_kell(\u0026amp;my_task); } tasklet的callback不能sleep, 并且不能访问user space data. 因为tasklet的callback运行atomic context中运行,在software interrupt里.\n此外, kernel只允许任意时间给定tasklet只有一个instance在运行,多个不同tasklet的callback可以并行运行.\ntasklet可以替换成workqueue、timer、threaded interrupt.\nkernel正在移除tasklet, 但目前保留了tasklet兼容.\nWork queues 一个Work queue中的work由Completely Fair Scheduler(CFS)方式调度.\nstatic struct workqueue_struct *queue = NULL; static struct work_struct work; static void work_handler(struct work_struct *data) { pr_info(\u0026#34;work handler function.\\n\u0026#34;) } static int __init sched_init(void) { queue = alloc_workqueue(\u0026#34;Hello World\u0026#34;, WQ_UNBOUND, 1); INIT_WORK(\u0026amp;work, work_handler); schedule_work(\u0026amp;work); return 0; } static void __exit sched_exit(void) { destory_workqueue(queue); } 大而全的万金油多线程实现.\nInterrupt Handler CPU和其他硬件的交互有两个类型,一种是CPU主动发送命令给硬件,另一种是硬件需要告诉CPU一些东西. 第二种称为interrupt. Interrupt类型的交互更难实现,因为硬件通常RAM数量很少, 必须在硬件方便而非CPU方便的情况下完成处理, 否则当一条信息可访问的时候CPU没有读进来, 这条信息就丢失了.\nLinux的硬件interrupt称为IRQ. IRQ有short和long两种. short IRQ预计花费非常短的时间, 在此期间机器的其余部分将被阻塞,并且不会处理其他中断. long IRQ预计花费更长的时间, 在此期间其他中断可能发生(除了来自同一设备的中断). 如何可能的话, 尽量将中断处理程序声明为long IRQ.\n当CPU收到一个中断, 它停止正在进行的程序(除非正在处理优先级更高的中断), 将某些参数保存在堆栈上, 然后调用中断处理程序. 这意味着在中断处理程序内部, 某些事情是不被允许的, 因为当前系统处于一种未知的状态. Linux通过将中断处理过程分为两部分来解决这个问题. 第一部分立刻执行并屏蔽中断线. 硬件中断必须快速处理, 第二部分处理被推迟的繁重工作. 例如Softirq.\n有关IRQ的更详细内容请参考\u0026quot;APCI\u0026quot;.\n练习: Detecting Button Presses Crypto SHA256 #define SHA256_LENGTH 256 char *plaintext=\u0026#34;this is a test\u0026#34;; char hash_sha256[SHA256_LENGTH]; struct crypto_shash *sha256; struct shash_desc *shash; sha256=crypto_alloc_shash(\u0026#34;sha256\u0026#34;,0,0); shash=kmalloc(sizeof(struct shash_desc)+crypto_shash_descsize(sha256), GFP_KERNEL); shash-\u0026gt;tfm=sha256; crypto_shash_init(shash); crypto_shash_update(shash, plaintex, strlen(plaintext)); crypto_shash_final(shash,hash_sha256); // print plaintext \u0026#34;plaintex\u0026#34; and hash result shash. kfree(shash); crypto_free_shash(sha256); AES256 这个更复杂一些, AES变种太多, 初始化过程很漫长.\n#define SYMMETRIC_KEY_LENGTH 32 #define CIPHER_BLOCK_SIZE 16 Virtual Input Output Device Driver 通过Event的方式与Device交互\nint send(struct vinput *, char *, int); int read(struct vinput *, char *, int); The Device Model 以上介绍了各种各样的模块做各种各样的事, 但是缺少一致性. 一致性要由我自己定义的, 控制设备启动挂起结束等等功能的一致性模型称为设备模型. 以下是一个样例:\n#include \u0026lt;linux/kernel\u0026gt; #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/platform_device.h\u0026gt; struct dm_data{ char *greeting; int number; }; static int dm_probe(struct platform_driver *dev) { struct dm_da *pa = (struct dm_data*)(dev-\u0026gt;dev.platform_data); pr_info(\u0026#34;dm probe\\n\u0026#34;); pr_info(\u0026#34;dm greeting: %s; %d\\n\u0026#34;, pd-\u0026gt;greeting, pd-\u0026gt;number); /* Your device initialization code */ return 0; } static int dm_remove(struct platform_driver *dev) { pr_info(\u0026#34;dm example removed\\n\u0026#34;); /* Your device removal code */ return 0; } static int dm_suspend(struct device *dev) { pr_info(\u0026#34;dm example suspend\\n\u0026#34;); /* Your device suspend code */ return 0; } static int dm_resume(struct device *dev) { pr_info(\u0026#34;dm example resume\\n\u0026#34;); /* Your device resume code */ return 0; } static const struct dev_pm_ops dm_pm_ops = { .suspend = dm_suspend, .resume = dm_resume, .poweroff = dm_suspend, .freeze = dm_suspend, .thaw = dm_resume, .restore = dm_resume, }; static struct platform_driver dm_driver = { .driver = { .name = \u0026#34;dm_example\u0026#34;, .pm = \u0026amp;dm_pm_ops, }, .probe = dm_probe, .remove = dm_remove, }; static int dm_init(void) { int ret; pr_info(\u0026#34;device model init\\n\u0026#34;); ret = platform_driver_register(\u0026amp;dm_driver); if (ret){ pr_err(\u0026#34;Unable to register driver\\n\u0026#34;); return ret; } return 0; } static int dm_exit(void) { pr_info(\u0026#34;dm exit\\n\u0026#34;); platform_driver_unregister(\u0026amp;dm_driver); } module_init(dm_init); module_exit(dm_exit); Optimizations 注意:如果计算性能不是瓶颈, 就不要优化.\nLikely and Unlikely conditions // I know allocating memory always expecting succeed. bvl = bvec_alloc(gfp_mask, nr_iovecs, \u0026amp;idx); if (unlikely(!bvl)){ mempool_free(bio, bio_pool); bio = NULL; goto out; } 编译器会改变生成的机器码, 当使用unlikely的时候, 机器会直接执行false分支, 当condition是true的时候, 才会发生一次跳转. 显然, 正确的情况下避免了一次分支跳转, 错误的情况下延迟也会比分支跳转高.\nStatic Keys How to enable:\ngcc support asm goto inline assembly. CONFIG_JUMP_LABEL=y CONFIG_HAVE_ARCH_JUMP_LABEL=y CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE=y // API DEFINE_STATIC_KEY_FALSE(x); DEFINE_STATIC_KEY_TRUE(x); DEFINE_STATIC_KEY_FALSE_RO(x);// read only DEFINE_STATIC_KEY_TRUE_RO(x); // read only // 在一些情况下, 一个static key在module init阶段disable(或enable)之后就不会再改变, 这种情况可以声明为只读. 这时, 这个static key就只能在init阶段改值. 在运行时修改一个只读的static key的值会导致一个page fault. DEFINE_STATIC_KEY_FALSE(fkey); pr_info(\u0026#34;fastpath 1\\n\u0026#34;); if (static_branch_unlikely(\u0026amp;fkey)){ pr_info(\u0026#34;slowpath\\n\u0026#34;); } pr_info(\u0026#34;fastpath 2\\n\u0026#34;); 以这个例子, fkey是static key, 并且值为false. 那么上述代码在fastpath 1之后会直接进入fastpath 2, 不会再做分支检查(应该是通过asm goto来实现的). 当fkey被修改为true时, 上述代码则一定会做分支检查.\nCommon Pitfalls Using standard libraries You can not do that.\n在kernel module中, 我只能使用kernel function. 所有的kernel function都可以在/proc/kallsyms中看到.\nDisabling interrupts 我可以禁用一小小会儿, 问题不大. 但是在禁用之后必须记得启用, 否则系统会卡死哦, 那就只能重启了.\nWhere To Go From Here? Kernel newbies.org Documentation subdirectory within the kernel source code. (It is not always easy to understand, but is a good starting point for further investigation) Linus said, the best way to learn the kernel is to read the source code yourself. ","permalink":"uildDrafts/posts/linux-kernel-module-programming-guide/","summary":"Linux Kernel Module Programming Guide [TOC]\nEasy Begin 内核模块包 编程内核模块首先要安装内核模块包kmod.\nsudo apt-get install build-essential kmod 命令行的内核模块相关命令 sudo lsmod # 查看所有加载进内核的模块 sudo cat /proc/modules # 和lsmod有什么不同 sudo modinfo ABC_x.ko # 查看模块ABC的信息 sudo insmod ABC_x.ko # 向内核中加载模块ABC sudo rmmod ABC-x # 从内核中卸载模块ABC, 注意ABC_x.ko名称中的\u0026#39;_\u0026#39;字符会被内核自动替换成\u0026#39;-\u0026#39;字符 sudo journalctl --since \u0026#34;1 hour ago\u0026#34; | grep kernel # 查看过去一小时内的内核日志 编码前须知 版本. 如果编译模块A时include的内核头文件版本与加载模块A的内核版本不一致, 会导致加载失败. 如果必须要这样做, 例如模块A兼容多个内核版本, 需要启用CONFIG_MODVERSIONS编译制导. 命令行. 内核模块无法打印输出到屏幕,但可以记录日志信息然后读取日志信息到屏幕. SecureBoot. SecureBoot是UEFI的一个设置, 要求只会引导安全密钥签名过的模块. [Shell]ERROR: could not insert module. [dmesg]Lockdown: insmod: unsigned module loading is restricted; see man kernel lockdown.","title":""}]