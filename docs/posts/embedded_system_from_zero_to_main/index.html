<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Embedded System from Zero to Main() | 福岚溪森</title>
<meta name="keywords" content="Cortex-M, Embedded, Bare matel">
<meta name="description" content="Setup a bare matel C environment, linker scripts, bootloader, libc">
<meta name="author" content="fanyuxin">
<link rel="canonical" href="https://canonical.url/to/page">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8b523f1730c922e314350296d83fd666efa16519ca136320a93df674d00b6325.css" integrity="sha256-i1I/FzDJIuMUNQKW2D/WZu&#43;hZRnKE2MgqT32dNALYyU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://fanyxok.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://fanyxok.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://fanyxok.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://fanyxok.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://fanyxok.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><head>
    
</head><meta property="og:title" content="Embedded System from Zero to Main()" />
<meta property="og:description" content="Setup a bare matel C environment, linker scripts, bootloader, libc" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://fanyxok.github.io/posts/embedded_system_from_zero_to_main/" />
<meta property="og:image" content="https://fanyxok.github.io/%3Cimage%20path/url%3E" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-14T16:40:08&#43;08:00" />
<meta property="article:modified_time" content="2023-10-14T16:40:08&#43;08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://fanyxok.github.io/%3Cimage%20path/url%3E" />
<meta name="twitter:title" content="Embedded System from Zero to Main()"/>
<meta name="twitter:description" content="Setup a bare matel C environment, linker scripts, bootloader, libc"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://fanyxok.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Embedded System from Zero to Main()",
      "item": "https://fanyxok.github.io/posts/embedded_system_from_zero_to_main/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Embedded System from Zero to Main()",
  "name": "Embedded System from Zero to Main()",
  "description": "Setup a bare matel C environment, linker scripts, bootloader, libc",
  "keywords": [
    "Cortex-M", "Embedded", "Bare matel"
  ],
  "articleBody": "Bare metal C Power on There must be behavior intrinsic to the chip that defines how code is executed.\nDigging into the ARMv6-M Technical Reference Manual, which is the underlying architecture manual for the Cortex-M0+, we can find some pseudo-code that describes reset behavior:\n// B1.5.5 TakeReset() // ============ TakeReset() VTOR = Zeros(32); for i = 0 to 12 R[i] = bits(32) UNKNOWN; bits(32) vectortable = VTOR; CurrentMode = Mode_Thread; LR = bits(32) UNKNOWN; // Value must be initialised by software APSR = bits(32) UNKNOWN; // Flags UNPREDICTABLE from reset IPSR\u003c5:0\u003e = Zeros(6); // Exception number cleared at reset PRIMASK.PM = '0'; // Priority mask cleared at reset CONTROL.SPSEL = '0'; // Current stack is Main CONTROL.nPRIV = '0'; // Thread is privileged ResetSCSRegs(); // Catch-all function for System Control Space reset for i = 0 to 511 // All exceptions Inactive ExceptionActive[i] = '0'; ClearEventRegister(); // See WFE instruction for more information SP_main = MemA[vectortable,4] AND 0xFFFFFFFC\u003c31:0\u003e; SP_process = ((bits(30) UNKNOWN):'00'); start = MemA[vectortable+4,4]; // Load address of reset routine BLXWritePC(start); // Start execution of reset routine In short, the chip does the following:\nReset the vector table address to 0x00000000 Disable all interrupts Load the SP from address 0x00000000 Load the PC from address 0x00000004 PC has value 0x00000004, is our main function addressed at 0x00000004?\nLet us check, dump our bin file to see what address 0x0000000 and 0x00000004 contain:\n$ xxd build/minimal/minimal.bin | head 00000000: 0020 0020 c100 0000 b500 0000 bb00 0000 . . ............ 00000010: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000020: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000030: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000040: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000050: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000060: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000070: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000080: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000090: 0000 0000 0000 0000 0000 0000 0000 0000 ................ Initial SP is 0x20002000, and our start address pointer is 0x000000c1.\nLet’s dump our symbols to see which one is at 0x000000c1.\n$ arm-none-eabi-objdump -t build/minimal.elf | sort ... 000000b4 g F .text 00000006 NMI_Handler 000000ba g F .text 00000006 HardFault_Handler 000000c0 g F .text 00000088 Reset_Handler 00000148 l F .text 0000005c system_pinmux_get_group_from_gpio_pin 000001a4 l F .text 00000020 port_get_group_from_gpio_pin 000001c4 l F .text 00000022 port_get_config_defaults 000001e6 l F .text 0000004e port_pin_set_output_level 00000234 l F .text 00000038 port_pin_toggle_output_level 0000026c l F .text 00000040 set_output 000002ac g F .text 0000002c main ... 看起来很奇怪, Our main function is found at 0x000002ac. No symbol at 0x000000c1, but a Reset_Handler symbol at 0x000000c0.\n事实证明, the lowest bit of the PC is used to indicate thumb2 instructions, which is one of the two instruction sets supported by ARM processors, so Reset_Handler is what we’re looking for (for more details check out section A4.1.1 in the ARMv6-M manual).\nWrite a Reset_Handler 不幸的是，Reset_Handler通常是一堆难以理解的汇编代码。这个贴nRF52 SDK的startup file展示:\n/* Copyright (c) 2009-2018 ARM Limited. All rights reserved. SPDX-License-Identifier: Apache-2.0 Licensed under the Apache License, Version 2.0 (the License); you may not use this file except in compliance with the License. You may obtain a copy of the License at www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. NOTICE: This file has been modified by Nordic Semiconductor ASA. */ .syntax unified .arch armv7e-m #ifdef __STARTUP_CONFIG #include \"startup_config.h\" #ifndef __STARTUP_CONFIG_STACK_ALIGNEMENT #define __STARTUP_CONFIG_STACK_ALIGNEMENT 3 #endif #endif .section .stack #if defined(__STARTUP_CONFIG) .align __STARTUP_CONFIG_STACK_ALIGNEMENT .equ Stack_Size, __STARTUP_CONFIG_STACK_SIZE #elif defined(__STACK_SIZE) .align 3 .equ Stack_Size, __STACK_SIZE #else .align 3 .equ Stack_Size, 8192 #endif .globl __StackTop .globl __StackLimit __StackLimit: .space Stack_Size .size __StackLimit, . - __StackLimit __StackTop: .size __StackTop, . - __StackTop .section .heap .align 3 #if defined(__STARTUP_CONFIG) .equ Heap_Size, __STARTUP_CONFIG_HEAP_SIZE #elif defined(__HEAP_SIZE) .equ Heap_Size, __HEAP_SIZE #else .equ Heap_Size, 8192 #endif .globl __HeapBase .globl __HeapLimit __HeapBase: .if Heap_Size .space Heap_Size .endif .size __HeapBase, . - __HeapBase __HeapLimit: .size __HeapLimit, . - __HeapLimit .section .isr_vector .align 2 .globl __isr_vector __isr_vector: .long __StackTop /* Top of Stack */ .long Reset_Handler .long NMI_Handler .long HardFault_Handler .long MemoryManagement_Handler .long BusFault_Handler .long UsageFault_Handler .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long SVC_Handler .long DebugMon_Handler .long 0 /*Reserved */ .long PendSV_Handler .long SysTick_Handler /* External Interrupts */ .long POWER_CLOCK_IRQHandler .long RADIO_IRQHandler .long UARTE0_UART0_IRQHandler .long SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQHandler .long SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQHandler .long NFCT_IRQHandler .long GPIOTE_IRQHandler .long SAADC_IRQHandler .long TIMER0_IRQHandler .long TIMER1_IRQHandler .long TIMER2_IRQHandler .long RTC0_IRQHandler .long TEMP_IRQHandler .long RNG_IRQHandler .long ECB_IRQHandler .long CCM_AAR_IRQHandler .long WDT_IRQHandler .long RTC1_IRQHandler .long QDEC_IRQHandler .long COMP_LPCOMP_IRQHandler .long SWI0_EGU0_IRQHandler .long SWI1_EGU1_IRQHandler .long SWI2_EGU2_IRQHandler .long SWI3_EGU3_IRQHandler .long SWI4_EGU4_IRQHandler .long SWI5_EGU5_IRQHandler .long TIMER3_IRQHandler .long TIMER4_IRQHandler .long PWM0_IRQHandler .long PDM_IRQHandler .long 0 /*Reserved */ .long 0 /*Reserved */ .long MWU_IRQHandler .long PWM1_IRQHandler .long PWM2_IRQHandler .long SPIM2_SPIS2_SPI2_IRQHandler .long RTC2_IRQHandler .long I2S_IRQHandler .long FPU_IRQHandler .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .long 0 /*Reserved */ .size __isr_vector, . - __isr_vector /* Reset Handler */ .text .thumb .thumb_func .align 1 .globl Reset_Handler .type Reset_Handler, %function Reset_Handler: /* Loop to copy data from read only memory to RAM. * The ranges of copy from/to are specified by following symbols: * __etext: LMA of start of the section to copy from. Usually end of text * __data_start__: VMA of start of the section to copy to. * __bss_start__: VMA of end of the section to copy to. Normally __data_end__ is used, but by using __bss_start__ * the user can add their own initialized data section before BSS section with the INTERT AFTER command. * * All addresses must be aligned to 4 bytes boundary. */ ldr r1, =__etext ldr r2, =__data_start__ ldr r3, =__bss_start__ subs r3, r3, r2 ble .L_loop1_done .L_loop1: subs r3, r3, #4 ldr r0, [r1,r3] str r0, [r2,r3] bgt .L_loop1 .L_loop1_done: /* This part of work usually is done in C library startup code. Otherwise, * define __STARTUP_CLEAR_BSS to enable it in this startup. This section * clears the RAM where BSS data is located. * * The BSS section is specified by following symbols * __bss_start__: start of the BSS section. * __bss_end__: end of the BSS section. * * All addresses must be aligned to 4 bytes boundary. */ #ifdef __STARTUP_CLEAR_BSS ldr r1, =__bss_start__ ldr r2, =__bss_end__ movs r0, 0 subs r2, r2, r1 ble .L_loop3_done .L_loop3: subs r2, r2, #4 str r0, [r1, r2] bgt .L_loop3 .L_loop3_done: #endif /* __STARTUP_CLEAR_BSS */ /* Execute SystemInit function. */ bl SystemInit /* Call _start function provided by libraries. * If those libraries are not accessible, define __START as your entry point. */ #ifndef __START #define __START _start #endif bl __START .pool .size Reset_Handler,.-Reset_Handler .section \".text\" /* Dummy Exception Handlers (infinite loops which can be modified) */ .weak NMI_Handler .type NMI_Handler, %function NMI_Handler: b . .size NMI_Handler, . - NMI_Handler .weak HardFault_Handler .type HardFault_Handler, %function HardFault_Handler: b . .size HardFault_Handler, . - HardFault_Handler .weak MemoryManagement_Handler .type MemoryManagement_Handler, %function MemoryManagement_Handler: b . .size MemoryManagement_Handler, . - MemoryManagement_Handler .weak BusFault_Handler .type BusFault_Handler, %function BusFault_Handler: b . .size BusFault_Handler, . - BusFault_Handler .weak UsageFault_Handler .type UsageFault_Handler, %function UsageFault_Handler: b . .size UsageFault_Handler, . - UsageFault_Handler .weak SVC_Handler .type SVC_Handler, %function SVC_Handler: b . .size SVC_Handler, . - SVC_Handler .weak DebugMon_Handler .type DebugMon_Handler, %function DebugMon_Handler: b . .size DebugMon_Handler, . - DebugMon_Handler .weak PendSV_Handler .type PendSV_Handler, %function PendSV_Handler: b . .size PendSV_Handler, . - PendSV_Handler .weak SysTick_Handler .type SysTick_Handler, %function SysTick_Handler: b . .size SysTick_Handler, . - SysTick_Handler /* IRQ Handlers */ .globl Default_Handler .type Default_Handler, %function Default_Handler: b . .size Default_Handler, . - Default_Handler .macro IRQ handler .weak \\handler .set \\handler, Default_Handler .endm IRQ POWER_CLOCK_IRQHandler IRQ RADIO_IRQHandler IRQ UARTE0_UART0_IRQHandler IRQ SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQHandler IRQ SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQHandler IRQ NFCT_IRQHandler IRQ GPIOTE_IRQHandler IRQ SAADC_IRQHandler IRQ TIMER0_IRQHandler IRQ TIMER1_IRQHandler IRQ TIMER2_IRQHandler IRQ RTC0_IRQHandler IRQ TEMP_IRQHandler IRQ RNG_IRQHandler IRQ ECB_IRQHandler IRQ CCM_AAR_IRQHandler IRQ WDT_IRQHandler IRQ RTC1_IRQHandler IRQ QDEC_IRQHandler IRQ COMP_LPCOMP_IRQHandler IRQ SWI0_EGU0_IRQHandler IRQ SWI1_EGU1_IRQHandler IRQ SWI2_EGU2_IRQHandler IRQ SWI3_EGU3_IRQHandler IRQ SWI4_EGU4_IRQHandler IRQ SWI5_EGU5_IRQHandler IRQ TIMER3_IRQHandler IRQ TIMER4_IRQHandler IRQ PWM0_IRQHandler IRQ PDM_IRQHandler IRQ MWU_IRQHandler IRQ PWM1_IRQHandler IRQ PWM2_IRQHandler IRQ SPIM2_SPIS2_SPI2_IRQHandler IRQ RTC2_IRQHandler IRQ I2S_IRQHandler IRQ FPU_IRQHandler .end let’s see if we can write a minimal Reset_Handler from first principles. ARM’s Technical Reference Manuals are useful. Section 5.9.2 of the Cortex-M3 TRM contains the following table: | Reset boot-up behavior|\nAction Description Initialize variables Any global/static variables must be setup. This includes initializing the BSS variable to 0, and copying initial values from ROM to RAM for non-constant variables. [Setup stacks] If more than one stack is be used, the other banked SPs must be initialized. The current SP can also be changed to Process from Main. [Initialize any runtime] Optionally make calls to C/C++ runtime init code to enable use of heap, floating point, or other features. This is normally done by __main from the C/C++ library. So, our ResetHandler is responsible for initializing static and global variables, and starting our program. We rely on the compiler (technically, the linker) to put all those variables in the same place so we can initialize them in one fell swoop.\nFor static variables that must be zeroed, the linker gives us\n_sbss as the start addresses the static variables live at _ebss as the end addresses the static variables live at We can do\n/* Clear the zero segment */ for (uint32_t *bss_ptr = \u0026_sbss; bss_ptr \u003c \u0026_ebss;) { *bss_ptr++ = 0; } For static variables with an init value, the linker gives us:\n_etext as the address the init values are stored at _sdata as the address the static variables live at _edata as the end of the static variables memory We can do\nuint32_t *init_values_ptr = \u0026_etext; uint32_t *data_ptr = \u0026_sdata; if (init_values_ptr != data_ptr) { for (; data_ptr \u003c \u0026_edata;) { *data_ptr++ = *init_values_ptr++; } } Putting it together, and with a call to main() to start our program, we write our Reset_Handler:\nvoid Reset_Handler(void) { /* Copy init values from text to data */ uint32_t *init_values_ptr = \u0026_etext; uint32_t *data_ptr = \u0026_sdata; if (init_values_ptr != data_ptr) { for (; data_ptr \u003c \u0026_edata;) { *data_ptr++ = *init_values_ptr++; } } /* Clear the zero segment */ for (uint32_t *bss_ptr = \u0026_sbss; bss_ptr \u003c \u0026_ebss;) { *bss_ptr++ = 0; } /* Overwriting the default value of the NVMCTRL.CTRLB.MANW bit (errata reference 13134) */ NVMCTRL-\u003eCTRLB.bit.MANW = 1; /* Branch to main function */ main(); /* Infinite loop */ while (1); } We add two more things:\nAn infinite loop after main(), so we do not run off into the weeds if the main function returns Workaround for chip bugs which are best taken care of before our program starts. Sometimes these are wrapped in a SystemInit function called by the Reset_Handler before main. Firmware Linker Scripts Linking is the last stage in compiling a program. It takes a number of compiled object files and merges them into a single program, filling in addresses so that everything is in the right place.\nPrior to linking, the compiler will have taken your source files one by one and compiled them into machine code. In the process, it leaves placeholders for addresses as (1) it does not know where the code will end up within the broader structure of the program and (2) it knows nothing about symbols outside of the current file or compilation unit.\nThe linker takes all of those object files and merges them together along with external dependencies like the C Standard Library into your program. To figure out which bits go where, the linker relies on a linker script - a blueprint for your program. Lastly, all placeholders are replaced by addresses.\nAnatomy of a Linker Script A linker script contains four things:\nMemory layout: what memory is available where Section definitions: what part of a program should go where Options: commands to specify architecture, entry point, …etc. if needed Symbols: variables to inject into the program at link time Memory Layout In order to allocate program space, the linker needs to know how much memory is available, and at what addresses that memory exists. This is what the MEMORY definition in the linker script is for.\nThe syntax for MEMORY is defined in the binutils docs and is as follow:\nMEMORY { name [(attr)] : ORIGIN = origin, LENGTH = len … } name is a name you want to use for this region. Names do not carry meaning, so you’re free to use anything you want. You’ll often find “flash”, and “ram” as region names. (attr) are optional attributes for the region, like whether it’s writable (w), readable (r), or executable (x). Flash memory is usually (rx), while ram is rwx. Marking a region as non-writable does not magically make it write protected: these attributes are meant to describe the properties of the memory, not set it. origin is the start address of the memory region. len is the size of the memory region, in bytes. Translate SAMD21G18 Chip Memory Map\nMemory Start Address Size Internal Flash 0x00000000 256 Kbytes Internal SRAM 0x20000000 32 Kbytes as\nMEMORY { rom (rx) : ORIGIN = 0x00000000, LENGTH = 0x00040000 ram (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00008000 } Section Definitions Code and data are bucketed into sections, which are contiguous areas of memory. There are no hard rules about how many sections you should have, or what they should be, but you typically want to put symbols in the same section if:\nThey should be in the same region of memory, or They need to be initialized together. In our previous post, we learned about two types of symbols that are initialized in bulk:\nInitialized static variables which must be copied from flash Uninitialized static variables which must be zeroed. Our linker script concerns itself with two more things:\nCode and constant data, which can live in read-only memory (e.g. flash) Reserved sections of RAM, like a stack or a heap By convention, we name those sections as follow:\n.text for code \u0026 constants .bss for uninitialized data .stack for our stack .data for initialized data The elf spec holds a full list. Your firmware will work just fine if you call them anything else, but your colleagues may be confused and some tools may fail in odd ways. The only constraint is that you may not call your section /DISCARD/, which is a reserved keyword.\nFirst, let’s look at what happens to our symbols if we do not define any of those sections in the linker script.\nMEMORY { rom (rx) : ORIGIN = 0x00000000, LENGTH = 0x00040000 ram (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00008000 } SECTIONS { /* empty! */ } The linker is perfectly happy to link our program with this. Probing the resulting elf file with objdump, we see the following:\n$ arm-none-eabi-objdump -h build/minimal.elf build/minimal.elf: file format elf32-littlearm SYMBOL TABLE: no symbols No symbols! While the linker is able to make assumptions that will allow it to link in symbols with little information, but it at least needs to know either what the entry point should be, or what symbols to put in the text section.\n.text Section Let’s start by adding our .text section. We want that section in ROM. The syntax is simple:\nSECTIONS { .text : { } \u003e rom } This defines a section named .text, and adds it to the ROM. We now need to tell the linker what to put in that section. This is accomplished by listing all of the sections from our input object files we want in .text.\nTo find out what sections are in our object file, we can once again use objdump:\n$ arm-none-eabi-objdump -h build/objs/a/b/c/minimal.o: file format elf32-littlearm Sections: Idx Name Size VMA LMA File off Algn 0 .text 00000000 00000000 00000000 00000034 2**1 CONTENTS, ALLOC, LOAD, READONLY, CODE 1 .data 00000000 00000000 00000000 00000034 2**0 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000000 00000000 00000000 00000034 2**0 ALLOC 3 .bss.cpu_irq_critical_section_counter 00000004 00000000 00000000 00000034 2**2 ALLOC 4 .bss.cpu_irq_prev_interrupt_state 00000001 00000000 00000000 00000034 2**0 ALLOC 5 .text.system_pinmux_get_group_from_gpio_pin 0000005c 00000000 00000000 00000034 2**2 CONTENTS, ALLOC, LOAD, READONLY, CODE 6 .text.port_get_group_from_gpio_pin 00000020 00000000 00000000 00000090 2**1 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 7 .text.port_get_config_defaults 00000022 00000000 00000000 000000b0 2**1 CONTENTS, ALLOC, LOAD, READONLY, CODE 8 .text.port_pin_set_output_level 0000004e 00000000 00000000 000000d2 2**1 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 9 .text.port_pin_toggle_output_level 00000038 00000000 00000000 00000120 2**1 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 10 .text.set_output 00000040 00000000 00000000 00000158 2**1 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 11 .text.main 0000002c 00000000 00000000 00000198 2**2 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE We see that each of our symbol has a section. This is due to the fact that we compiled our firmware with the -ffunction-sections and -fdata-sections flags. Had we not included them, the compiler would have been free to merge several functions into a single text. section.\nTo put all of our functions in the .text section in our linker script, we use the following syntax: (), where filename is the name of the input files whose symbols we want to include, and section is the name of the input sections. Since we want all .text... sections in all files, we use the wildcard *:\n.text : { KEEP(*(.vector*)) *(.text*) } \u003e rom Note the .vector input section, which contains functions we want to keep at the very start of our .text section. This is so the Reset_Handler is where the MCU expects it to be. We’ll talk more about the vector table in a future post.\nDumping our elf file, we now see all of our functions (but no data)!\n$ arm-none-eabi-objdump -t build/minimal.elf build/minimal.elf: file format elf32-littlearm SYMBOL TABLE: 00000000 l d .text 00000000 .text ... 00000000 l df *ABS* 00000000 minimal.c 00000000 l F .text 0000005c system_pinmux_get_group_from_gpio_pin 0000005c l F .text 00000020 port_get_group_from_gpio_pin 0000007c l F .text 00000022 port_get_config_defaults 0000009e l F .text 0000004e port_pin_set_output_level 000000ec l F .text 00000038 port_pin_toggle_output_level 00000124 l F .text 00000040 set_output 00000000 l df *ABS* 00000000 port.c 00000190 l F .text 00000028 system_pinmux_get_config_defaults 00000000 l df *ABS* 00000000 pinmux.c 00000208 l F .text 0000005c system_pinmux_get_group_from_gpio_pin 00000264 l F .text 00000110 _system_pinmux_config 00000164 g F .text 0000002c main 000001b8 g F .text 0000004e port_pin_set_config 00000374 g F .text 00000040 system_pinmux_pin_set_config ... .bss Section Now, let’s take care of our .bss. Remember, this is the section we put uninitialized static memory in. .bss must be reserved in the memory map, but there is nothing to load, as all variables are initialized to zero. As such, this is what it should look like:\nSECTION { ... .bss (NOLOAD) : { *(.bss*) *(COMMON) } \u003e ram } You’ll note that the .bss section also includes *(COMMON). This is a special input section where the compiler puts global uninitialized variables that go beyond file scope. int foo; goes there, while static int foo; does not. This allows the linker to merge multiple definitions into one symbol if they have the same name.\nWe indicate that this section is not loaded with the NOLOAD property. This is the only section property used in modern linker scripts.\n.stack Section We do the same thing for our .stack memory, since it is in RAM and not loaded. As the stack contains no symbols, we must explicitly reserve space for it by indicating its size. We also must align the stack on an 8-byte boundary per ARM Procedure Call Standards (AAPCS).\nIn order to achieve these goals, we turn to a special variable ., also known as the “location counter”. The location counter tracks the current offset into a given memory region. As sections are added, the location counter increments accordingly. You can force alignment or gaps by setting the location counter forward. You may not set it backwards, and the linker will throw an error if you try.\nWe set the location counter with the ALIGN function, to align the section, and use simple assignment and arithmetic to set the section size:\nSTACK_SIZE = 0x2000; /* 8 kB */ SECTION { ... .stack (NOLOAD) : { . = ALIGN(8); . = . + STACK_SIZE; . = ALIGN(8); } \u003e ram ... } Only one more section to go!\n.data Section The .data section contains static variables which have an initial value at boot. You will remember from our previous article that since RAM isn’t persisted while power is off, those sections need to be loaded from flash. At boot, the Reset_Handler copies the data from flash to RAM before the main function is called.\nTo make this possible, every section in our linker script has two addresses, its load address (LMA) and its virtual address (VMA). In a firmware context, the LMA is where your JTAG loader needs to place the section and the VMA is where the section is found during execution.\nYou can think of the LMA as the address “at rest” and the VMA the address during execution i.e. when the device is on and the program is running.\nThe syntax to specify the LMA and VMA is relatively straightforward: every address is two part: AT . In our case it looks like this:\n.data : { *(.data*); } \u003e ram AT \u003e rom /* \"\u003e ram\" is the VMA, \"\u003e rom\" is the LMA */ Note that instead of appending a section to a memory region, you could also explicitly specify an address like so:\n.data ORIGIN(ram) /* VMA */ : AT(ORIGIN(rom)) /* LMA */ { . = ALIGN(4); _sdata = .; *(.data*); . = ALIGN(4); _edata = .; } Where ORIGIN() is a simple way to specify the start of a region. You can enter an address in hex as well.\nAnd we’re done! Here’s our complete linker script with every section:\nComplete Linker Script MEMORY { rom (rx) : ORIGIN = 0x00000000, LENGTH = 0x00040000 ram (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00008000 } STACK_SIZE = 0x2000; /* Section Definitions */ SECTIONS { .text : { KEEP(*(.vectors .vectors.*)) *(.text*) *(.rodata*) } \u003e rom /* .bss section which is used for uninitialized data */ .bss (NOLOAD) : { *(.bss*) *(COMMON) } \u003e ram .data : { *(.data*); } \u003e ram AT \u003erom /* stack section */ .stack (NOLOAD): { . = ALIGN(8); . = . + STACK_SIZE; . = ALIGN(8); } \u003e ram _end = . ; } You can find the full details on linker script sections syntax in the ld manual.\nVariables In the first post, our ResetHandler relied on seemingly magic variables to know the address of each of our sections of memory. It turns out, those variable came\nIn order to make section addresses available to code, the linker is able to generate symbols and add them to the program.\nYou can find the syntax in the linker documentation, it looks exactly like a C assignment: symbol = expression;\nHere, we need:\n_etext the end of the code in .text section in flash. _sdata the start of the .data section in RAM _edata the end of the .data section in RAM _sbss the start of the .bss section in RAM _ebss the end of the .bss section in RAM They are all relatively straightforward: we can assign our symbols to the value of the location counter (.) at the start and at the end of each section definition.\nThe code is below:\n.text : { KEEP(*(.vectors .vectors.*)) *(.text.*) *(.rodata.*) _etext = .; } \u003e rom .bss (NOLOAD) : { _sbss = . ; *(.bss .bss.*) *(COMMON) _ebss = . ; } \u003e ram .data : { _sdata = .; *(.data*); _edata = .; } \u003e ram AT \u003erom One quirk of these linker-provided symbols: you must use a reference to them, never the variable themselves. For example, the following gets us a pointer to the start of the .data section:\nuint8_t *data_byte = \u0026_sdata; You can read more details about this in the binutils docs.\nWrite a Bootloader from Scratch Previously, we\nwrote a startup file to bootstrap our C environment, and a linker script to get the right data at the right addresses. These two will allow us to write a monolithic firmware which we can load and run on our microcontrollers.\nIn practice, this is not how most firmware is structured. Digging through vendor SDKs, you’ll notice that they all recommend using a bootloader to load your applications. A bootloader is a small program which is responsible for loading and starting your application.\nIn this part, we will explain why you may want a bootloader, how to implement one, and cover a few advanced techniques you may use to make your bootloader more useful.\nWhy you may need a bootloader Bootloaders serve many purposes, ranging from security to software architecture.\nMost commonly, you may need a bootloader to load your software. Some microcontrollers like Dialog’s DA14580 have little to no onboard flash and instead rely on an external device to store firmware code. In that case, it is the bootloader’s job to copy code from non-executable storage, such as a SPI flash, to an area of memory that can be executed from, such as RAM.\nBootloaders also allow you to decouple parts of the program that are mission critical, or that have security implications, from application code which changes regularly. For example, your bootloader may contain firmware update logic so your device can recover no matter how bad a bug ships in your application firmware.\nLast but certainly not least, bootloaders are an essential component of a trusted boot architecture. Your bootloader can, for example, verify a cryptographic signature to make sure the application has not been replaced or tampered with.\nA minimal bootloader Let’s build a simple bootloader together. To start, our bootloader must do two things:\nExecute on MCU boot Jump to our application code We’ll need to decide on a memory map, write some bootloader code, and update our application to make it bootload-able.\nSetting the stage For this example, we’ll be using the same setup as we did in our previous Zero to Main posts:\nAdafruit’s Metro M0 Express as our development board, a simple CMSIS-DAP Adapter OpenOCD (the Arduino fork) for programming Deciding on a memory map We must first decide on how much space we want to dedicate to our bootloader. Code space is precious - your application may come to need more of it - and you will not be able to change this without updating your bootloader, so make this as small as you possibly can.\nAnother important factor is your flash sector size: you want to make sure you can erase app sectors without erasing bootloader data, or vice versa. Consequently, your bootloader region must end on a flash sector boundary (typically 4kB).\nI decided to go with a 16kB region, leading to the following memory map:\n0x0 +---------------------+ | | | Bootloader | | | 0x4000 +---------------------+ | | | | | Application | | | | | 0x30000 +---------------------+ We can transcribe that memory into a linker script:\n/* memory_map.ld */ MEMORY { bootrom (rx) : ORIGIN = 0x00000000, LENGTH = 0x00004000 approm (rx) : ORIGIN = 0x00004000, LENGTH = 0x0003C000 ram (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00008000 } __bootrom_start__ = ORIGIN(bootrom); __bootrom_size__ = LENGTH(bootrom); __approm_start__ = ORIGIN(approm); __approm_size__ = LENGTH(approm); Since linker scripts are composable, we will be able to include that memory map into the linker scripts we write for our bootloader and our application.\nYou’ll notice that the linker script above declares some variables. We’ll need those for our bootloader to know where to find the application. To make them accessible in C code, we declare them in a header file:\n/* memory_map.h */ #pragma once extern int __bootrom_start__; extern int __bootrom_size__; extern int __approm_start__; extern int __approm_size__; Implementing the bootloader itself Let’s write some bootloader code. Our bootloader needs to start executing on boot and then jump to our app.\nWe know how to do the first part from our previous post: we need a valid stack pointer at address 0x0 , and a valid Reset_Handler function setting up our environment at address 0x4. We can reuse our previous startup file and linker script, with one change: we use memory_map.ld rather than define our own MEMORY section.\nWe also need to put our code in the bootrom region from our memory rather than the rom region in our previous post.\nOur linker script therefore looks like this:\n/* bootloader.ld */ INCLUDE memory_map.ld /* Section Definitions */ SECTIONS { .text : { KEEP(*(.vectors .vectors.*)) *(.text*) *(.rodata*) _etext = .; } \u003e bootrom ... } To jump into our application, we need to know where the Reset_Handler of the app is, and what stack pointer to load. Again, we know from our previous post that those should be the first two 32-bit words in our binary, so we just need to dereference those addresses using the __approm_start__ variable from our memory map.\n/* bootloader.c */ #include #include \"memory_map.h\" int main(void) { uint32_t *app_code = (uint32_t *)__approm_start__; uint32_t app_sp = app_code[0]; uint32_t app_start = app_code[1]; /* TODO: Start app */ /* Not Reached */ while (1) {} } Next we must load that stack pointer and jump to the code. This will require a bit of assembly code.\nARM MCUs use the msr instruction to load immediate or register data into system registers, in this case the MSP register or “Main Stack Pointer”.\nJumping to an address is done with a branch, in our case with a bx instruction.\nWe wrap those two into a start_app function which accepts our pc and sp as arguments, and get our minimal bootloader:\n/* bootloader.c */ #include #include \"memory_map.h\" static void start_app(uint32_t pc, uint32_t sp) __attribute__((naked)) { __asm(\" \\n\\ msr msp, r1 /* load r1 into MSP */\\n\\ bx r0 /* branch to the address at r0 */\\n\\ \"); } int main(void) { uint32_t *app_code = (uint32_t *)__approm_start__; uint32_t app_sp = app_code[0]; uint32_t app_start = app_code[1]; start_app(app_start, app_sp); /* Not Reached */ while (1) {} } Note: hardware resources initialized in the bootloader must be de-initialized before control is transferred to the app. Otherwise, you risk breaking assumptions the app code is making about the state of the system\nMaking our app bootloadable We must update our app to take advantage of our new memory map. This is again done by updating our linker script to include memory_map.ld and changing our sections to go to the approm region rather than rom.\n/* app.ld */ INCLUDE memory_map.ld /* Section Definitions */ SECTIONS { .text : { KEEP(*(.vectors .vectors.*)) *(.text*) *(.rodata*) _etext = .; } \u003e approm ... } We also need to update the vector table used by the microcontroller. The vector table contains the address of every exception and interrupt handler in our system. When an interrupt signal comes in, the ARM core will call the address at the corresponding offset in the vector table.\nFor example, the offset for the Hard fault handler is 0xc, so when a hard fault is hit, the ARM core will jump to the address contained in the table at that offset.\nBy default, the vector table is at address 0x0, which means that when our chip powers up, only the bootloader can handle exceptions or interrupts! Fortunately, ARM provides the Vector Table Offset Register to dynamically change the address of the vector table. The register is at address 0xE000ED08 and has a simple layout:\n31 7 0 +-----------------------------------+--------------+ | | | | TBLOFF | Reserved | | | | +-----------------------------------+--------------+ Where TBLOFF is the address of the vector table. In our case, that’s the start of our text section, or _stext. To set it in our app, we add the following to our Reset_Handler:\n/* startup_samd21.c */ /* Set the vector table base address */ uint32_t *vector_table = (uint32_t *) \u0026_stext; uint32_t *vtor = (uint32_t *)0xE000ED08; *vtor = ((uint32_t) vector_table \u0026 0xFFFFFFF8); One quirk of the ARMv7-m architecture is the alignment requirement for the vector table, as specified in section B1.5.3 of the reference manual:\nThe Vector table must be naturally aligned to a power of two whose alignment value is greater than or equal to (Number of Exceptions supported x 4), with a minimum alignment of 128 bytes.The entry at offset 0 is used to initialize the value for SP_main, see The SP registers on page B1-8. All other entries must have bit [0] set, as the bit is used to define the EPSR T-bit on exception entry (see Reset behavior on page B1-20 and Exception entry behavior on page B1-21 for details).\nOur SAMD21 MCU has 28 interrupts on top of the 16 system reserved exceptions, for a total of 44 entries in the table. Multiply that by 4 and you get 176. The next power of 2 is 256, so our vector table must be 256-byte aligned.\nPutting it all together Because it is hard to witness the bootloader execute, we add a print line to each of our programs:\n/* boootloader.c */ #include #include \"memory_map.h\" static void start_app(uint32_t pc, uint32_t sp) { __asm(\" \\n\\ msr msp, r1 /* load r1 into MSP */\\n\\ bx r0 /* branch to the address at r0 */\\n\\ \"); } int main() { serial_init(); printf(\"Bootloader!\\n\"); serial_deinit(); uint32_t *app_code = (uint32_t *)__approm_start__; uint32_t app_sp = app_code[0]; uint32_t app_start = app_code[1]; start_app(app_start, app_sp); // should never be reached while (1); } and:\n/* app.c */ int main() { serial_init(); set_output(LED_0_PIN); printf(\"App!\\n\"); while (true) { port_pin_toggle_output_level(LED_0_PIN); for (int i = 0; i \u003c 100000; ++i) {} } } Note that the bootloader must deinitialize the serial peripheral before starting the app, or you’ll have a hard time trying to initialize it again.\nYou can compile both these programs and load the resulting elf files with gdb which will put them at the correct address. However, the more convenient thing to do is to build a single binary which contains both programs.\nTo do that, you must go through the following steps:\nPad the bootloader binary to the full 0x4000 bytes Create the app binary Concatenate the two Creating a binary from an elf file is done with objcopy . To accommodate our use case, objcopy has some handy options:\n$ arm-none-eabi-objcopy --help | grep -C 2 pad -b --byte Select byte in every interleaved block --gap-fill Fill gaps between sections with --pad-to Pad the last section up to address --set-start Set the start address to {--change-start|--adjust-start} The —pad-to option will pad the binary up to an address, and —gap-fill will allow you to specify the byte value to fill the gap with. Since we are writing our firmware to flash memory, we should fill with 0xFF which is the erase value of flash, and pad to the max address of our bootloader.\nWe implement those rule in our Makefile, to avoid having to type them out each time:\n# Makefile $(BUILD_DIR)/$(PROJECT)-app.bin: $(BUILD_DIR)/$(PROJECT)-app.elf $(OCPY) $\u003c $@ -O binary $(SZ) $\u003c $(BUILD_DIR)/$(PROJECT)-boot.bin: $(BUILD_DIR)/$(PROJECT)-boot.elf $(OCPY) --pad-to=0x4000 --gap-fill=0xFF -O binary $\u003c $@ $(SZ) $\u003c Last but not least, we need to concatenate our two binaries. As funny as that may sound, this is best achieved with cat:\n# Makefile $(BUILD_DIR)/$(PROJECT).bin: $(BUILD_DIR)/$(PROJECT)-boot.bin $(BUILD_DIR)/$(PROJECT)-app.bin cat $^ \u003e $@ Beyond the MVP Now, this bootloader isn’t too useful, it only loads our application. We could do just as well without it.\nIn the following sections, I will go through a few useful things you can do with a bootloader.\nMessage passing to catch reboot loops A common thing to do with a bootloader is monitor stability. This can be done with a relatively simple setup:\nOn boot, the bootloader increments a persistent counter After the app has been stable for a while (e.g. 1 minute), it resets the counter to 0 If the counter gets to 3, the bootloader does not start the app but instead signals an error. This requires shared, persistent data between the application and the bootloader which is retained across reboots. On some architectures, non volatile registers are available which make this easy. This is the case on all STM32 microcontrollers which have RTC backup registers.\n大多数情况下, we can use a region of RAM to get the same result. As long as the system remains powered, the RAM will keep its state even if the device reboots.\nFirst, we carve some RAM for shared data in our memory map:\n/* memory_map.ld */ MEMORY { bootrom (rx) : ORIGIN = 0x00000000, LENGTH = 0x00004000 approm (rx) : ORIGIN = 0x00004000, LENGTH = 0x0003C000 shared (rwx) : ORIGIN = 0x20000000, LENGTH = 0x1000 # new added memory region ram (rwx) : ORIGIN = 0x20001000, LENGTH = 0x00007000 } /* shared data starts point at the origin of the shared region */ _shared_data_start = ORIGIN(shared); We can then create a data structure and assign it to this section, with getters to read it:\n/* shared.h */ #include uint8_t shared_data_get_boot_count(void); void shared_data_increment_boot_count(void); void shared_data_reset_boot_count(void); /* shared.c */ #include \"shared.h\" extern uint32_t _shared_data_start; #pragma pack (push) struct shared_data { uint8_t boot_count; }; #pragma pack (pop) struct shared_data *sd = (struct shared_data *)\u0026_shared_data_start; uint8_t shared_data_get_boot_count(void) { return sd-\u003eboot_count; } void shared_data_increment_boot_count(void) { sd-\u003eboot_count++; } void shared_data_reset_boot_count(void) { sd-\u003eboot_count = 0; } We compile the shared module into both our app and our bootloader, and can read the boot count in both programs.\nRelocating our app from flash to RAM More commonly, bootloaders are used to relocate applications before they are executed. Relocations involves copying the application code from one place to another in order to execute it. This is useful when your application is stored in non-executable memory like a SPI flash.\nConsider the following memory map:\n/* memory_map.ld */ MEMORY { bootrom (rx) : ORIGIN = 0x00000000, LENGTH = 0x00010000 approm (rx) : ORIGIN = 0x00010000, LENGTH = 0x00004000 ram (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00004000 eram (rwx) : ORIGIN = 0x20004000, LENGTH = 0x00004000 } __bootrom_start__ = ORIGIN(bootrom); __bootrom_size__ = LENGTH(bootrom); __approm_start__ = ORIGIN(approm); __approm_size__ = LENGTH(approm); __eram_start__ = ORIGIN(eram); __eram_size__ = LENGTH(eram); In this case, approm is our app storage and eram is our executable RAM, where we want to copy our program. Our bootloader needs to copy the code from approm to eram before executing it.\nWe know from our previous blog post that executable code typically ends up in the .text section so we must tell the linker that this section is stored in approm but executed from eram so our program can execute correctly.\nThis is similar to our .data section, which is stored in rom but lives in ram while the program is running. We use the AT linker command to specify the storage region and the \u003e operator to specify the load region. This is the resulting linker script section:\n/* app.ld */ SECTIONS { .text : { KEEP(*(.vectors .vectors.*)) *(.text*) *(.rodata*) } \u003e eram AT \u003e approm ... } We then update our bootloader to copy our code from one to the other before starting the app:\n/* booloader.c */ /* copy app code to eram */ uint32_t *src = (uint32_t*) \u0026__approm_start__; uint32_t *dst = (uint32_t*) \u0026__eram_start__; int size = (int) \u0026__approm_size__; printf(\"Copying firmware from %p to %p\\n\", src, dst); memcpy(dst, src, size); /* find app start \u0026 SP */ uint32_t app_sp = dst[0]; uint32_t app_start = dst[1]; /* cleanup peripherals here we may have initialized */ /* start the app */ start_app(app_start, app_sp); Locking the bootloader with the MPU Memory Protect Unit\nLast but not least, we can protect the bootloader using the memory protection unit to make it inaccessible from the app. This prevents accidentally erasing the bootloader during execution.\nIf you do not know about the MPU, check out Chris’s excellent blog post from a few weeks ago.\nRemember that our MPU regions must be power-of-2 sized. Thankfully, our bootloader already is! 0x4000 is 2^14 bytes.\nWe add the following MPU code to our bootloader:\n/* bootloader.c */ int main(void) { /* ... */ base_addr = 0x0; *mpu_rbar = (base_addr | 1 \u003c\u003c 4 | 1); // AP=0b110 to make the region read-only regardless of privilege // TEXSCB=0b000010 because the Code is in \"Flash memory\" // SIZE=13 because we want to cover 16kiB // ENABLE=1 *mpu_rasr = (0b110 \u003c\u003c 24) | (0b000010 \u003c\u003c 16) | (13 \u003c\u003c 1) | 0x1; start_app(app_start, app_sp); /* Not reached */ while (1) {} } Bootstrapping libc with Newlib So far, we bootstrapped a C environment, wrote a linker script from scratch, and implemented our own bootloader.\nAnd yet, we cannot even write a hello world program! Consider the following main.c file:\n#include int main() { printf(\"Hello, World\\n\"); while (1) {} } Compiling this using our Makefile and linker script from previous posts, we hit the following error:\n$ make ... Linking build/minimal.elf arm-none-eabi/bin/ld: build/objs/a/b/c/minimal.o: in function `main': /minimal/minimal.c:4: undefined reference to `printf' collect2: error: ld returned 1 exit status make: *** [build/minimal.elf] Error 1 Undefined reference to printf! How could this be?\nOur firmware’s C environment doesn’t contains a working C standard library. This means that commonly used functions such as printf, memcpy, or strncpy are all out of reach of our program so far.\nIn firmware-land, nothing comes free with the system: just like we had to explicitly zero out the bss region to initialize some of our static variables, we’ll have to port a printf implementation alongside a C standard library if we want to use it.\nIn this post, we will\nadd RedHat’s Newlib to our firmware and highlight some of its features. implement syscalls, learn about constructors, and finally print out “Hello, World”! also learn how to replace parts or all of the standard C library. Setup As we did in previous sections, we are using Adafruit’s Metro M0 development board to run our examples. We use a cheap CMSIS-DAP adapter and openOCD to program it.\nYou can find a step by step guide in our previous post.\nAs with previous examples, we start with our “minimal” example which you can find on GitHub. I’ve reproduced the source code for main.c below:\n#include #include #include #define LED_0_PIN PIN_PA17 static void set_output(const uint8_t pin) { struct port_config config_port_pin; port_get_config_defaults(\u0026config_port_pin); config_port_pin.direction = PORT_PIN_DIR_OUTPUT; port_pin_set_config(pin, \u0026config_port_pin); port_pin_set_output_level(pin, false); } int main() { memcpy(NULL, NULL, 0); set_output(LED_0_PIN); while (true) { port_pin_toggle_output_level(LED_0_PIN); for (int i = 0; i \u003c 100000; ++i) {} } } Implementing Newlib Why Newlib? There are several implementations of the C Standard Library, starting with the venerable glibc found on most GNU/Linux systems. Alternative implementations include Musl libc1, Bionic libc2, ucLibc3, and dietlibc4.\nNewlib is an implementation of the C Standard Library targeted at bare-metal embedded systems that is maintained by RedHat. It has become the de-facto standard in embedded software because it is complete, has optimizations for a wide range of architectures, and produces relatively small code.\nToday Newlib is bundled alongside toolchains and SDK provided by vendors such as ARM (arm-none-eabi-gcc) and Espressif (ESP-IDF for ESP32).\nNote: when code-size constrained, you may choose to use a variant of newlib, called newlib-nano, which does away with some C99 features, and some printf bells and whistles to deliver a more compact standard library. Newlib-nano is enabled with the —specs=nano.specs CFLAG. You can read more about it in our code size blog post\nEnabling Newlib Newlib is enabled by default when you build a project with arm-none-eabi-gcc. Indeed, you must explicitly opt-out with -nostdlib if you prefer to build your firmware without it.\nThis is what we do for our “minimal” example, to guarantee we do not include any libc functionality by mistake.\nPROJECT := minimal BUILD_DIR ?= build CFLAGS += -nostdlib SRCS = \\ startup_samd21.c \\ $(PROJECT).c include ../common-standalone.mk It is very easy to add a dependency on the C standard library without meaning to, as GCC will sometimes use standard C functions implicitly. For example, consider this code used to zero-initialize a struct:\nint main() { int b[50] = {0}; // zero initialize a struct /* ... */ } We added no new #include, nor any call to C library functions. Yet if we compile this code with -nostdlib, we’ll get the following error:\n... Linking build/minimal.elf /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/bin/ld: build/objs/a/b/c/minimal.o: in function `main': /minimal/minimal.c:16: undefined reference to `memset' collect2: error: ld returned 1 exit status make: *** [build/minimal.elf] Error 1 If we remove -nostdlib, the program compiles and link without problems.\nLinking build/minimal.elf arm-none-eabi-objdump -D build/minimal.elf \u003e build/minimal.lst arm-none-eabi-objcopy build/minimal.elf build/minimal.bin -O binary arm-none-eabi-size build/minimal.elf text data bss dec hex filename 1292 0 8192 9484 250c build/minimal.elf So here we are, using Newlib, and we did not have to do anything. Could it really be this simple?\nNote: the variant of Newlib bundled with arm-none-eabi-gcc is not compiled with -g, which can make debugging difficult. For that reason, you may chose to replace it with your own build of Newlib. You can read more about that process in the Implementing our own C standard library section of this article.\nSystem Calls Let’s go back to our “Hello World” example:\nint main() { printf(\"Hello World!\\n\"); while(1) {} } Removing -nostdlib is not quite enough. Instead of printf being undefined, we now see a whole mess of undefined symbols:\nLinking build/minimal.elf /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/bin/ld: /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/lib/thumb/v6-m/nofp/libg_nano. a(lib_a-sbrkr.o): in function `_sbrk_r': sbrkr.c:(.text._sbrk_r+0xc): undefined reference to `_sbrk' /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/bin/ld: /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/lib/thumb/v6-m/nofp/libg_nano. a(lib_a-writer.o): in function `_write_r': writer.c:(.text._write_r+0x10): undefined reference to `_write' /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/bin/ld: /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/lib/thumb/v6-m/nofp/libg_nano. a(lib_a-closer.o): in function `_close_r': closer.c:(.text._close_r+0xc): undefined reference to `_close' /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/bin/ld: /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/lib/thumb/v6-m/nofp/libg_nano. a(lib_a-lseekr.o): in function `_lseek_r': lseekr.c:(.text._lseek_r+0x10): undefined reference to `_lseek' /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/bin/ld: /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/lib/thumb/v6-m/nofp/libg_nano. a(lib_a-readr.o): in function `_read_r': readr.c:(.text._read_r+0x10): undefined reference to `_read' /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/bin/ld: /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/lib/thumb/v6-m/nofp/libg_nano. a(lib_a-fstatr.o): in function `_fstat_r': fstatr.c:(.text._fstat_r+0xe): undefined reference to `_fstat' /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/bin/ld: /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/lib/thumb/v6-m/nofp/libg_nano. a(lib_a-isattyr.o): in function `_isatty_r': isattyr.c:(.text._isatty_r+0xc): undefined reference to `_isatty' collect2: error: ld returned 1 exit status Specifically, the compiler is asking for _fstat, _read, _lseek, _close, _write, and _sbrk.\nThe newlib documentation5 calls these functions “system calls”. In short, they are the handful of things newlib expects the underlying “operating system”. The complete list of them is provided below:\n_exit, close, environ, execve, fork, fstat, getpid, isatty, kill, link, lseek, open, read, sbrk, stat, times, unlink, wait, write You’ll notice that several of the syscalls relate to filesystem operation or process control. These do not make much sense in a firmware context, so we’ll often simply provide a stub that returns an error code.\nLet’s look at the ones our “Hello, World” example requires.\nfstat fstat returns the status of an open file. The minimal version of this should identify all files as character special devices. This forces one-byte-read at a time.\n#include int fstat(int file, struct stat *st) { st-\u003est_mode = S_IFCHR; return 0; } lseek lseek repositions the file offset of the open file associated with the file descriptor fd to the argument offset according to the directive whence.\nHere we can simply return 0, which implies the file is empty.\nint lseek(int file, int offset, int whence) { return 0; } close close closes a file descriptor fd.\nSince no file should have gotten open-ed, we can just return an error on close:\nint close(int fd) { return -1; } write This is where things get interesting! write writes up to count bytes from the buffer starting at buf to the file referred to by the file descriptor fd.\nFunctions like printf rely on write to write bytes to STDOUT. In our case, we will want those bytes to be written to serial instead.\nOn the SAMD21 chip we are using, writing bytes to serial is done using the usart_serial_putchar function. We can use it to implement write:\nstatic struct usart_module stdio_uart_module; int _write (int fd, char *buf, int count) { int written = 0; for (; count != 0; --count) { if (usart_serial_putchar(\u0026stdio_uart_module, (uint8_t)*buf++)) { return -1; } ++written; } return written; } We’ll also need to initialize the USART peripheral prior to calling printf:\nstatic void serial_init(void) { struct usart_config usart_conf; usart_get_config_defaults(\u0026usart_conf); usart_conf.mux_setting = USART_RX_3_TX_2_XCK_3; usart_conf.pinmux_pad0 = PINMUX_UNUSED; usart_conf.pinmux_pad1 = PINMUX_UNUSED; usart_conf.pinmux_pad2 = PINMUX_PB22D_SERCOM5_PAD2; usart_conf.pinmux_pad3 = PINMUX_PB23D_SERCOM5_PAD3; usart_serial_init(\u0026stdio_uart_module, SERCOM5, \u0026usart_conf); usart_enable(\u0026stdio_uart_module); } int main() { serial_init(); printf(\"Hello, World!\\n\"); while (1) {} } read read attempts to read up to count bytes from file descriptor fd into the buffer at buf.\nSimilarly to write, we want read to read bytes from serial:\nint _read (int fd, char *buf, int count) { int read = 0; for (; count \u003e 0; --count) { usart_serial_getchar(\u0026stdio_uart_module, (uint8_t *)buf++); read++; } return read; } sbrk sbrk increases the program’s data space by increment bytes. In other words, it increases the size of the heap.\nWhat does printf have to do with the heap, you will justly ask? It turns out that newlib’s printf implementations allocates data on the heap and depends on a working malloc implementation.\nThe source for printf is hard to follow, but you will find that indeed it calls malloc!\nHere’s a simple implementation of sbrk:\nvoid *_sbrk(int incr) { static unsigned char *heap = HEAP_START; unsigned char *prev_heap = heap; heap += incr; return prev_heap; } More often than not, we want the heap to use all the RAM not used by anything else. We therefore set HEAP_START to the first address not spoken for in our linker script. In our previous post, we had added the _end variable in our linker script to that end.\nWe replace HEAP_START with _end and get:\nvoid *_sbrk(int incr) { static unsigned char *heap = NULL; unsigned char *prev_heap; if (heap == NULL) { heap = (unsigned char *)\u0026_end; } prev_heap = heap; heap += incr; return prev_heap; } Putting it all together, we get the following main.c file:\nstatic struct usart_module stdio_uart_module; // LIBC SYSCALLS ///////////////////// extern int _end; void *_sbrk(int incr) { static unsigned char *heap = NULL; unsigned char *prev_heap; if (heap == NULL) { heap = (unsigned char *)\u0026_end; } prev_heap = heap; heap += incr; return prev_heap; } int _close(int file) { return -1; } int _fstat(int file, struct stat *st) { st-\u003est_mode = S_IFCHR; return 0; } int _isatty(int file) { return 1; } int _lseek(int file, int ptr, int dir) { return 0; } void _exit(int status) { __asm(\"BKPT #0\"); } void _kill(int pid, int sig) { return; } int _getpid(void) { return -1; } int _write (int file, char * ptr, int len) { int written = 0; if ((file != 1) \u0026\u0026 (file != 2) \u0026\u0026 (file != 3)) { return -1; } for (; len != 0; --len) { if (usart_serial_putchar(\u0026stdio_uart_module, (uint8_t)*ptr++)) { return -1; } ++written; } return written; } int _read (int file, char * ptr, int len) { int read = 0; if (file != 0) { return -1; } for (; len \u003e 0; --len) { usart_serial_getchar(\u0026stdio_uart_module, (uint8_t *)ptr++); read++; } return read; } // APP //////////////////// static void __attribute__((constructor)) serial_init(void) { struct usart_config usart_conf; usart_get_config_defaults(\u0026usart_conf); usart_conf.mux_setting = USART_RX_3_TX_2_XCK_3; usart_conf.pinmux_pad0 = PINMUX_UNUSED; usart_conf.pinmux_pad1 = PINMUX_UNUSED; usart_conf.pinmux_pad2 = PINMUX_PB22D_SERCOM5_PAD2; usart_conf.pinmux_pad3 = PINMUX_PB23D_SERCOM5_PAD3; usart_serial_init(\u0026stdio_uart_module, SERCOM5, \u0026usart_conf); usart_enable(\u0026stdio_uart_module); } int main() { serial_init(); printf(\"Hello, World!\\n\"); } This compiles fine, and can be run on our MCU. Hello, World!\nInitializing State with Constructors \u0026 Destructors Although we could perfectly well stop here, we can improve a bit over the above.\nIn our example, printf depends implicitly on serial_init being called. This isn’t the end of the world, but it goes against the spirit of a standard library function which should be usable anywhere in our program.\nInstead, let’s see what we can do so that this works:\nint main() { printf(\"Hello, World\\n\"); } Can you think of a solution?\nIf we want printf to work anywhere in our main function, then serial_init must be run before main. What runs before main? We know from our previous post that it is the Reset_Handler. A simple solution might therefore be:\nvoid Reset_Handler(void) { /* ... */ /* Hardware Initialization */ serial_init(); /* Branch to main function */ main(); /* Infinite loop */ while (1); } The GNU compiler collection and Newlib offer an alternative solution: constructors.\nConstructors are functions which should be run before main. Conceptually, they are similar to the constructors of statically allocated C++ objects.\nA function is marked as a constructor using the attribute syntax: __attribute__((constructor)). We can thus update serial_init:\nstatic void __attribute__((constructor)) serial_init(void) { struct usart_config usart_conf; usart_get_config_defaults(\u0026usart_conf); usart_conf.mux_setting = USART_RX_3_TX_2_XCK_3; usart_conf.pinmux_pad0 = PINMUX_UNUSED; usart_conf.pinmux_pad1 = PINMUX_UNUSED; usart_conf.pinmux_pad2 = PINMUX_PB22D_SERCOM5_PAD2; usart_conf.pinmux_pad3 = PINMUX_PB23D_SERCOM5_PAD3; usart_serial_init(\u0026stdio_uart_module, SERCOM5, \u0026usart_conf); usart_enable(\u0026stdio_uart_module); } But how do these constructors get invoked? We know that in firmware, we do not get anything for free. This is where newlib comes in.\nBy default, GCC will put every constructor into an array in their own section of flash. Newlib then offers a function, __libc_init_array which iterates over the array and invokes every constructor. You can find out more about it by reading the source code.\nAll we need to do is call __libc_init_array prior to main in our Reset_Handler, and we are good to go.\nvoid Reset_Handler(void) { /* ... */ /* Run constructors / initializers */ __libc_init_array(); /* Branch to main function */ main(); /* Infinite loop */ while (1); } Newlib and Multi-threading We have not yet talked much about multi-threading (e.g. with an RTOS) in this series, and going into details is outside of the scope of this article. However, there are a few things worth knowing when using Newlib in a multi-threaded environment.\n_impure_ptr and the _reent struct Most Newlib functions are reentrant. This means that they can be called by multiple processes safely.\nFor the functions that cannot be easily made re-entrant, newlib depends on the operating system correctly setting the _impure_ptr variable whenever a context switch occur. That variable is expected to hold a struct _reent for the current thread. That struct is used to store state for standard library functions being used by that thread.\nLocking shared memory Some standard library functions depend on global memory which would not make sense to hold in the _reent struct. This is especially important when using malloc to allocate memory out of the heap. If mutliple threads try modifying the heap at the same time, they risk corrupting it.\nTo allow multiple threads to call malloc, Newlib provides the __malloc_lock and __malloc_unlock APIs6. A good implementation of these APIs would lock and unlock a recursive mutex.\nImplementing our own C standard library In some cases, you may want to take different tradeoffs than the ones taken by the implementers of Newlib. Perhaps you are willing to sacrifice some functionality for code space, or are willing to trade performance for security. In most cases it is easier to replace a few functions, though you may end up with a fully custom C library.\nReplacing a function Because Newlib is a static library with a separate object file for every function, all you need to do to replace a function is define it in your program. The linker won’t go looking for it in static libraries if it finds it in your code.\nFor example, we may want to replace Newlib’s printf implementation, either because it is too large or because it depends on dynamic memory management. Using Marco Paland’s excellent alternative7 is as simple as a Makefile change.\nWe first clone it in our firmware’s folder under lib/printf, and update our Makefile to reflect the change:\nPROJECT := with-libc BUILD_DIR ?= build INCLUDES = \\ ... \\ lib/printf SRCS = \\ ... \\ lib/printf/printf.c \\ startup_samd21.c \\ $(PROJECT).c include ../common-standalone.mk Full replacement In some cases, you may want to do away with Newlib altogether. Perhaps you don’t want any dynamic memory allocation, in which case you could use Embedded Artistry’s solid alternative8. Another good reason to replace the version of Newlib provided by your toolchain is to use your own build of it because you would like to use different compile-time flags.\nOnce we have copied the static lib (.a) for our selected libc, we disable Newlib with -nostdlib and explicitly link in our substitute library. You can find the resulting Makefile below:\nPROJECT := with-libc BUILD_DIR ?= build CFLAGS += -nostdlib LDFLAGS += -L../lib/embeddedartistry_libc -lc INCLUDES = \\ $(ASF_PATH)/sam0/drivers/sercom \\ $(ASF_PATH)/sam0/drivers/sercom/usart \\ $(ASF_PATH)/common/services/serial \\ $(ASF_PATH)/common/services/serial/sam0_usart SRCS = \\ $(ASF_PATH)/sam0/drivers/sercom/usart/usart.c \\ $(ASF_PATH)/sam0/drivers/sercom/sercom.c \\ startup_samd21.c \\ $(PROJECT).c include ../common-standalone.mk Note that the __libc_init_array functionality is not found in every standard C library. You will either need to avoid using it, or bring in Newlib’s implementation.\nReference Links musl libc ↩\nbionic libc ↩\nucLibc ↩\ndietlibc ↩\nnewlib documentation ↩\n__malloc_lock documentation ↩\nMarco Paland’s printf ↩\nEmbedded Artistry’s libc ↩\nBare metal Rust For the past thirty years or so, the choice of languages for embedded systems developers has been relatively slim. Languages like C++ and Ada have found a home in some niche areas, such as telecommunications and safety critical fields, while higher level languages like Lua, Python, and JavaScript have found a home for scripting and prototyping.\nDespite these options, most developers working on bare metal systems have been using the same two languages as long as I can remember: Assembly and C.\nBut not for no reason! Languages often make trade-offs to fit the needs of the developers working with them: an interpreter to allow for rapid iteration, a heap for ease of memory management, exceptions for simplifying control flow, etc. These trade-offs usually come with a price: whether it is code size, RAM usage, low level control, power usage, latency, or determinism.\nSince 2015, Rust has been redefining what it means to combine the best-in-class aspects of performance, correctness, and developer convenience into one language, without compromise. In this post, we’ll bootstrap a Rust environment on a Cortex-M microcontroller from scratch, and explain a few of the language concepts you might not have seen before.\nAs a compiled systems language (based on LLVM), it is also capable of reaching down to the lowest levels of embedded programming as well, without losing built-in features that feel more at home in higher level languages, like a package manager, helpful compile time diagnostics, correctness through powerful static analysis, or documentation tooling.\nThis post is meant as a complement to the original Zero to main() post on the Interrupt blog, and will elide some of the explanations of hardware level concepts. If you’re new to embedded development, or haven’t seen that post, go read it now!\nSetting the stage Most of the concepts and code presented in this series should work for all Cortex-M series MCUs, though these examples target the nRF52 processor by Nordic. This is a Cortex-M4F chip found on several affordable development boards.\nSpecifically, we are using:\nDecawave’s DWM1001-DEV as our development board The built-in JLink capabilities of the board Segger’s JLinkGDBServer for programming Software wise, we will be using:\nThe 1.39.0 version of Rust, though any stable version 1.31.0 or newer should work We’ll also use some of the arm-none-eabi binutils, such as arm-none-eabi-gdb and arm-none-eabi-objdump, which are compatible with the binaries produced by Rust We’ll also be implementing a simple blinking LED application. The full Rust source used for this blog post is available here, on GitHub. This is what the source code looks like for our application:\n#![no_std] #![no_main] use nrf52::gpio::{Level, Pins}; fn main() -\u003e ! { let gpios = Pins::take(); let mut led = gpios.p0_31; led.set_push_pull_output(Level::Low); loop { led.set_high(); delay(2_000_000); led.set_low(); delay(6_000_000); } } Power on Let’s build our Rust application, and see what the binary contains:\ncargo build --release Compiling from-scratch v0.1.0 (/home/james/memfault/blog-1/examples/from-scratch) Finished release [optimized] target(s) in 0.62s arm-none-eabi-objcopy -O binary target/thumbv7em-none-eabihf/release/from-scratch target/thumbv7em-none-eabihf/release/from-scratch.bin xxd target/thumbv7em-none-eabihf/release/from-scratch.bin | head -n 5 00000000: 0000 0120 dd00 0000 0000 0000 0000 0000 ... ............ 00000010: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000020: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000030: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000040: 0000 0000 0000 0000 0000 0000 0000 0000 ................ Reading this, our initial stack pointer is 0x20010000, and our start address pointer is 0x000000dd. Let’s see what symbol is there. We will also pass -C to objdump, which will demangle our symbols (we’ll explain demangling a bit more later):\narm-none-eabi-objdump -Ct target/thumbv7em-none-eabihf/release/from-scratch | sort ... 00000004 g O .vector_table 00000004 __RESET_VECTOR 000000dc g .vector_table 00000000 _stext 000000dc l F .text 0000005c from_scratch::reset_handler 00000138 l F .text 0000006a from_scratch::main 000001a4 g *ABS* 00000000 __sidata ... Same as in the original post, our compiler has set the lowest bit of our reset handler to one to indicate a thumb2 function, so from_scratch::reset_handler is what we’re looking for.\nWriting a Reset_Handler The Cortex-M processor on our board doesn’t actually know the difference between C and Rust, so our responsibilities for starting the firmware are the same when we build a Rust program, we need to:\nProvide an entry point, stored in the second word of flash Zero-initialize the .bss section Set items with static storage duration to their initial values. In Rust the destination (in RAM) is referred to as .data, and the source values (in Flash) is referred to as .rodata Let’s go through the code required to write this reset handler, one chunk at a time.\nStarting at the top The first line in many embedded applications and libraries in Rust will look like this:\n#![no_std] This is called a “global attribute”, and it is stating that this Rust code will not be using the Rust Standard Library. Attributes in Rust are sometimes used similarly to #pragma in C, in that they can change certain behaviors of the compiler.\nRust provides a number of built-in library components, but the two main ones are:\nThe Rust Standard Library The Rust Core Library While the Standard Library contains a number of useful components, such as data structures, and interfaces for opening files and sockets, it generally requires your target to have these things! For bare metal applications, we can instead forego this library and only use the Rust Core Library, which does not have these requirements.\nRust as a language has a concept of “modules”, which can be used to organize and provide namespaces for your code. Libraries or applications in Rust are called “Crates”, and each has its own namespace. This is why we saw the symbol from_scratch::reset_handler in our linker script: It was referring to the reset_handler function in the from_scratch crate (which is the application crate in this example).\nTo use items from another crate, including the core library, you can import these items in using the use syntax:\nuse core::{ mem::zeroed, panic::PanicInfo, ptr::{read, write_volatile}, }; This imports the symbols into the current context so that they can be used. Most symbols in Rust are not available in a global namespace, which helps to avoid naming collisions.\nHowever in some cases, it is important to have a globally defined symbol. As part of the ABI of the Cortex-M platform, we need to provide the address of the reset handler in a very specific location. Let’s look at how we do that in Rust:\nSetting the Reset Vector #[link_section = \".vector_table.reset_vector\"] #[no_mangle] pub static __RESET_VECTOR: fn() -\u003e ! = reset_handler; Let’s unpack that from the bottom up:\npub static __RESET_VECTOR: fn() -\u003e ! = reset_handler; This line defines a symbol called __RESET_VECTOR at static scope. The type of this symbol is fn() -\u003e !, which is a pointer to a function that takes no arguments and that never returns, or that “diverges”. The value of this symbol is reset_handler, which is the name of a function in our program. Functions are a first class items in Rust (similar to Python), so we can use the names of functions as a value that represents a function pointer.\n#[no_mangle] This is another attribute, like our #![no_std]. By starting with #[ instead of #![, we can tell this is a local attribute instead of a global attribute, which means it only applies to the next item, instead of the whole module.\nThe #[no_mangle] attribute tells the compiler not to mangle this symbol, so it will show up as __RESET_VECTOR, not from_scratch::__RESET_VECTOR. Name mangling is a technique used by languages like C++ and Rust to emit unique names for things like functions, generic data type parameters, or symbols for data at static scope, no matter where or how often they are used in the resulting binary.\n#[link_section = \".vector_table.reset_vector\"] This is another attribute that is informing the compiler to place this symbol in the .vector_table.reset_vector section of our linker script, which will place it right where we need it. This is similar to gcc’s __attribute__((section(...))).\nThe Reset Handler, for real Now let’s look at our actual reset handler, from top to bottom:\npub fn reset_handler() -\u003e ! { extern \"C\" { // These symbols come from `linker.ld` static mut __sbss: u32; // Start of .bss section static mut __ebss: u32; // End of .bss section static mut __sdata: u32; // Start of .data section static mut __edata: u32; // End of .data section static __sidata: u32; // Start of .rodata section } // Initialize (Zero) BSS unsafe { let mut sbss: *mut u32 = \u0026mut __sbss; let ebss: *mut u32 = \u0026mut __ebss; while sbss \u003c ebss { write_volatile(sbss, zeroed()); sbss = sbss.offset(1); } } // Initialize Data unsafe { let mut sdata: *mut u32 = \u0026mut __sdata; let edata: *mut u32 = \u0026mut __edata; let mut sidata: *const u32 = \u0026__sidata; while sdata \u003c edata { write_volatile(sdata, read(sidata)); sdata = sdata.offset(1); sidata = sidata.offset(1); } } // Call user's main function main() } Phew! That was a lot at once, especially if you aren’t familiar with Rust! Let’s break that down one chunk at a time to explain the concepts in a little more detail:\nDefining a function in Rust pub fn reset_handler() -\u003e ! { This defines a function that is public, named reset_handler, that takes no arguments (), and that never returns -\u003e !.\nIn Rust, functions normally either don’t return a value like this:\n/// Returns nothing fn foo() { /* ... */ } Or do return a value like this:\n/// Returns a 32-bit unsigned integer fn bar() -\u003e u32 { /* ... */ } The ! type, called the “Never type”, means that this function will never return, or diverges. Since our reset handler never will return (where would it go?) we can tell Rust this, which may allow it to make certain optimizations at compile time.\nA little help from the linker extern \"C\" { // These symbols come from `linker.ld` static mut __sbss: u32; // Start of .bss section static mut __ebss: u32; // End of .bss section static mut __sdata: u32; // Start of .data section static mut __edata: u32; // End of .data section static __sidata: u32; // Start of .rodata section } This section defines a number of static symbols which will be provided by our linker, namely the start and end of the sections that are important for our reset handler to know about. These symbols are defined in an extern \"C\" scope, which means two things:\nThey will be provided sometime later, by another piece of code, or in this case, the linker itself They will be defined using the “C” style of ABI and naming conventions, which means they are implicitly #[no_mangle] Some of these symbols are also declared as mut, or “mutable”. By default in Rust, all variables are immutable, or read-only. To make a variable mutable in Rust, you must explicitly mark it as mut. This is the opposite of languages like C and C++, where variables are by default mutable, and must be marked with const to prevent them from being modified.\nZeroing the BSS section // Initialize (Zero) BSS unsafe { let mut sbss: *mut u32 = \u0026mut __sbss; let ebss: *mut u32 = \u0026mut __ebss; while sbss \u003c ebss { write_volatile(sbss, zeroed()); sbss = sbss.offset(1); } } As a language, Rust makes some pretty strong guarantees around memory safety, correctness, and freedom from Undefined Behavior. However, when working directly with the hardware, which has no knowledge of Rust’s guarantees, it is necessary to work in Rust’s unsafe mode, which allows some additional behaviors, but requires the developer to uphold certain correctness guarantees manually.\nRust has two ways of referring to data by reference:\nReferences Raw Pointers In most Rust code, we use references, which can be statically guaranteed for correctness and memory safety. However in this case, we are given the raw integers, which we want to treat as pointers.\nIn this code, we take a mutable reference to the __sbss and __ebss symbols provided by the linker, and convert these Rust references into raw pointers.\nWe then use these pointers to make volatile writes of zero across the range, one 32-bit word at a time.\nThis section zeros our entire .bss section, as defined by the linker.\nInitializing static data // Initialize Data unsafe { let mut sdata: *mut u32 = \u0026mut __sdata; let edata: *mut u32 = \u0026mut __edata; let mut sidata: *const u32 = \u0026__sidata; while sdata \u003c edata { write_volatile(sdata, read(sidata)); sdata = sdata.offset(1); sidata = sidata.offset(1); } } This section of code initializes our .data section, copying directly from the .rodata section. This is similar to the code above, however we also walk the pointer in the initializer section as well as the pointer in the destination section.\nReady for launch Finally, at the end of our reset handler, we get to call main!\n// Call user's main function main() Since the main function we defined above is also divergent (fn main() -\u003e !), we can simply call the function. If we had called a non-divergent function, we would get a compile error here!\nSomething just for Rust Rust does have one additional requirement for a bare metal program: You must define the panic handler.\n/// This function is called on panic. #[panic_handler] fn panic(_info: \u0026PanicInfo) -\u003e ! { // On a panic, loop forever loop { continue; } } Rust has a concept of a panic, which is like failing an assert in C. This happens when the program has hit an unrecoverable error case, and must be stopped in some way.\nUnlike Exceptions in C++, panics are usually not designed to be recovered from gracefully, and therefore do not require the overhead necessary to unwind.\nStill, we must define a “panic handler” in case our program ever panics. For this example, we go into an endless loop, though you could choose to do something different, like logging the error to flash, or soft-rebooting the system immediately.\nProgramming without Compromise Earlier I mentioned that Rust brings convenience without compromise. To demonstrate this, let’s take a quick look at the size and total contents of our code once we compile for opt-level = \"s\", which is equivalent to -Os in C or C++:\narm-none-eabi-size target/thumbv7em-none-eabihf/release/from-scratch text data bss dec hex filename 420 0 8 428 1ac target/thumbv7em-none-eabihf/release/from-scratch arm-none-eabi-nm -nSC target/thumbv7em-none-eabihf/release/from-scratch 00000004 00000004 R __RESET_VECTOR 00000008 R __reset_vector 000000dc R _stext 000000dc 0000005c t from_scratch::reset_handler 00000138 0000006a t from_scratch::main 000001a4 T __erodata 000001a4 T __etext 000001a4 A __sidata 20000000 T __edata 20000000 B __sbss 20000000 T __sdata 20000000 00000004 b from_scratch::delay::DUMMY 20000004 00000001 b from_scratch::nrf52::gpio::Pins::take::TAKEN 20000008 B __ebss 20000008 B __sheap 20010000 A _stack_start This is 420 bytes of .text, which boils down to 220 bytes for the vector table, and 198 bytes of actual code.\nWrapping up Although we spent this post talking about how to write support for scratch in Rust, we almost never need to actually do this in practice!\nInstead we can leverage Cargo, the package manager and build system for Rust, to use existing libraries that support Cortex-M and Nordic components, a board support crate that handles configuration for our specific development board, and provide a panic handler.\nThese libraries include an initialization runtime with pre-init hooks, a template linker script that can be modified and extended, access to common Cortex-M components like the NVIC, and more, without having to copy and paste boilerplate reference code into our project.\nNow we instead end up with a program that looks like this:\n#![no_std] #![no_main] // Panic provider crate use panic_reset as _; // Provides definitions for our development board use dwm1001::{ cortex_m_rt::entry, nrf52832_hal::prelude::*, DWM1001 }; #[entry] fn main() -\u003e ! { // Set up the board, initializing the LEDs on the board let mut board = DWM1001::take().unwrap(); // Obtain a microsecond precision timer let mut timer = board.TIMER0.constrain(); loop { // board.leds.D10 - Bottom LED BLUE board.leds.D10.enable(); timer.delay(2_000_000); board.leds.D10.disable(); timer.delay(6_000_000); } } All of the code used in this blog post is available on GitHub. If you’re looking for information on how to get started with embedded Rust, check out the Embedded Working Group’s bookshelf for documentation on how to install Rust, connect to your device, and build and run your first application.\nIn future posts we’ll talk about how libraries like r0, cortex-m, and cortex-m-rt provide common functionality when writing embedded programs, and how libraries like nrf52832-pac, nrf52832-hal, and dwm1001 provide compile-time safe abstractions over hardware interfaces!\n",
  "wordCount" : "12415",
  "inLanguage": "en",
  "image":"https://fanyxok.github.io/%3Cimage%20path/url%3E","datePublished": "2023-10-14T16:40:08+08:00",
  "dateModified": "2023-10-14T16:40:08+08:00",
  "author":{
    "@type": "Person",
    "name": "fanyuxin"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://fanyxok.github.io/posts/embedded_system_from_zero_to_main/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "福岚溪森",
    "logo": {
      "@type": "ImageObject",
      "url": "https://fanyxok.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://fanyxok.github.io" accesskey="h" title="福岚溪森 (Alt + H)">福岚溪森</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://fanyxok.github.io">Home</a>&nbsp;»&nbsp;<a href="https://fanyxok.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      Embedded System from Zero to Main()
    </h1>
    <div class="post-description">
      Setup a bare matel C environment, linker scripts, bootloader, libc
    </div>
    <div class="post-meta"><span title='2023-10-14 16:40:08 +0800 CST'>October 14, 2023</span>&nbsp;·&nbsp;59 min&nbsp;·&nbsp;12415 words&nbsp;·&nbsp;fanyuxin&nbsp;|&nbsp;<a href="https://github.com/%3cpath_to_repo%3e/content/posts/embedded_system_from_zero_to_main.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#bare-metal-c">Bare metal C</a>
      <ul>
        <li><a href="#power-on">Power on</a></li>
        <li><a href="#write-a-reset_handler">Write a Reset_Handler</a></li>
      </ul>
    </li>
    <li><a href="#firmware-linker-scripts">Firmware Linker Scripts</a>
      <ul>
        <li><a href="#anatomy-of-a-linker-script">Anatomy of a Linker Script</a></li>
        <li><a href="#memory-layout">Memory Layout</a></li>
        <li><a href="#section-definitions">Section Definitions</a>
          <ul>
            <li><a href="#text-section"><code>.text</code> Section</a></li>
            <li><a href="#bss-section"><code>.bss</code> Section</a></li>
            <li><a href="#stack-section"><code>.stack</code> Section</a></li>
            <li><a href="#data-section"><code>.data</code> Section</a></li>
          </ul>
        </li>
        <li><a href="#complete-linker-script">Complete Linker Script</a></li>
        <li><a href="#variables">Variables</a></li>
      </ul>
    </li>
    <li><a href="#write-a-bootloader-from-scratch">Write a Bootloader from Scratch</a>
      <ul>
        <li><a href="#why-you-may-need-a-bootloader">Why you may need a bootloader</a></li>
        <li><a href="#a-minimal-bootloader">A minimal bootloader</a>
          <ul>
            <li><a href="#setting-the-stage">Setting the stage</a></li>
            <li><a href="#deciding-on-a-memory-map">Deciding on a memory map</a></li>
            <li><a href="#implementing-the-bootloader-itself">Implementing the bootloader itself</a></li>
            <li><a href="#making-our-app-bootloadable">Making our app bootloadable</a></li>
            <li><a href="#putting-it-all-together">Putting it all together</a></li>
          </ul>
        </li>
        <li><a href="#beyond-the-mvp">Beyond the MVP</a>
          <ul>
            <li><a href="#message-passing-to-catch-reboot-loops">Message passing to catch reboot loops</a></li>
            <li><a href="#relocating-our-app-from-flash-to-ram">Relocating our app from flash to RAM</a></li>
            <li><a href="#locking-the-bootloader-with-the-mpu">Locking the bootloader with the MPU</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#bootstrapping-libc-with-newlib">Bootstrapping libc with Newlib</a>
      <ul>
        <li><a href="#setup">Setup</a></li>
        <li><a href="#implementing-newlib">Implementing Newlib</a>
          <ul>
            <li><a href="#why-newlib">Why Newlib?</a></li>
            <li><a href="#enabling-newlib">Enabling Newlib</a></li>
          </ul>
        </li>
        <li><a href="#system-calls">System Calls</a>
          <ul>
            <li><a href="#fstat">fstat</a></li>
            <li><a href="#lseek">lseek</a></li>
            <li><a href="#close">close</a></li>
            <li><a href="#write">write</a></li>
            <li><a href="#read">read</a></li>
            <li><a href="#sbrk">sbrk</a></li>
          </ul>
        </li>
        <li><a href="#initializing-state-with-constructors--destructors">Initializing State with Constructors &amp; Destructors</a></li>
        <li><a href="#newlib-and-multi-threading">Newlib and Multi-threading</a>
          <ul>
            <li><a href="#_impure_ptr-and-the-_reent-struct"><code>_impure_ptr</code> and the <code>_reent</code> struct</a></li>
            <li><a href="#locking-shared-memory">Locking shared memory</a></li>
          </ul>
        </li>
        <li><a href="#implementing-our-own-c-standard-library">Implementing our own C standard library</a>
          <ul>
            <li><a href="#replacing-a-function">Replacing a function</a></li>
            <li><a href="#full-replacement">Full replacement</a></li>
          </ul>
        </li>
        <li><a href="#reference-links">Reference Links</a></li>
      </ul>
    </li>
    <li><a href="#bare-metal-rust">Bare metal Rust</a>
      <ul>
        <li><a href="#setting-the-stage-1">Setting the stage</a></li>
        <li><a href="#power-on-1">Power on</a></li>
        <li><a href="#writing-a-reset_handler">Writing a Reset_Handler</a>
          <ul>
            <li><a href="#starting-at-the-top">Starting at the top</a></li>
            <li><a href="#setting-the-reset-vector">Setting the Reset Vector</a></li>
            <li><a href="#the-reset-handler-for-real">The Reset Handler, for real</a></li>
            <li><a href="#defining-a-function-in-rust">Defining a function in Rust</a></li>
            <li><a href="#a-little-help-from-the-linker">A little help from the linker</a></li>
            <li><a href="#zeroing-the-bss-section">Zeroing the BSS section</a></li>
            <li><a href="#initializing-static-data">Initializing static data</a></li>
            <li><a href="#ready-for-launch">Ready for launch</a></li>
            <li><a href="#something-just-for-rust">Something just for Rust</a></li>
            <li><a href="#programming-without-compromise">Programming without Compromise</a></li>
          </ul>
        </li>
        <li><a href="#wrapping-up">Wrapping up</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="bare-metal-c">Bare metal C<a hidden class="anchor" aria-hidden="true" href="#bare-metal-c">#</a></h1>
<h2 id="power-on">Power on<a hidden class="anchor" aria-hidden="true" href="#power-on">#</a></h2>
<p>There must be behavior intrinsic to the chip that defines how code is executed.</p>
<p>Digging into the <a href="https://static.docs.arm.com/ddi0419/d/DDI0419D_armv6m_arm.pdf">ARMv6-M Technical Reference Manual</a>, which is the underlying architecture manual for the Cortex-M0+, we can find some pseudo-code that describes reset behavior:</p>
<pre tabindex="0"><code>// B1.5.5 TakeReset()
// ============
TakeReset()
    VTOR = Zeros(32);
    for i = 0 to 12
        R[i] = bits(32) UNKNOWN;
    bits(32) vectortable = VTOR;
    CurrentMode = Mode_Thread;
    LR = bits(32) UNKNOWN; // Value must be initialised by software
    APSR = bits(32) UNKNOWN; // Flags UNPREDICTABLE from reset
    IPSR&lt;5:0&gt; = Zeros(6); // Exception number cleared at reset
    PRIMASK.PM = &#39;0&#39;; // Priority mask cleared at reset
    CONTROL.SPSEL = &#39;0&#39;; // Current stack is Main
    CONTROL.nPRIV = &#39;0&#39;; // Thread is privileged
    ResetSCSRegs(); // Catch-all function for System Control Space reset
    for i = 0 to 511 // All exceptions Inactive
        ExceptionActive[i] = &#39;0&#39;;
    ClearEventRegister(); // See WFE instruction for more information
    SP_main = MemA[vectortable,4] AND 0xFFFFFFFC&lt;31:0&gt;;
    SP_process = ((bits(30) UNKNOWN):&#39;00&#39;);
    start = MemA[vectortable+4,4]; // Load address of reset routine
    BLXWritePC(start); // Start execution of reset routine
</code></pre><p>In short, the chip does the following:</p>
<ul>
<li>Reset the vector table address to 0x00000000</li>
<li>Disable all interrupts</li>
<li>Load the SP from address 0x00000000</li>
<li>Load the PC from address 0x00000004</li>
</ul>
<p>PC has value 0x00000004, is our <code>main</code> function addressed at 0x00000004?</p>
<p>Let us check, dump our <code>bin</code> file to see what address 0x0000000 and 0x00000004 contain:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ xxd build/minimal/minimal.bin  | head
</span></span><span style="display:flex;"><span>00000000: <span style="color:#ae81ff">0020</span> <span style="color:#ae81ff">0020</span> c100 <span style="color:#ae81ff">0000</span> b500 <span style="color:#ae81ff">0000</span> bb00 <span style="color:#ae81ff">0000</span>  . . ............
</span></span><span style="display:flex;"><span>00000010: <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span>  ................
</span></span><span style="display:flex;"><span>00000020: <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span>  ................
</span></span><span style="display:flex;"><span>00000030: <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span>  ................
</span></span><span style="display:flex;"><span>00000040: <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span>  ................
</span></span><span style="display:flex;"><span>00000050: <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span>  ................
</span></span><span style="display:flex;"><span>00000060: <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span>  ................
</span></span><span style="display:flex;"><span>00000070: <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span>  ................
</span></span><span style="display:flex;"><span>00000080: <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span>  ................
</span></span><span style="display:flex;"><span>00000090: <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span>  ................
</span></span></code></pre></div><p>Initial SP is <code>0x20002000</code>, and our start address pointer is <code>0x000000c1</code>.</p>
<p>Let’s dump our symbols to see which one is at <code>0x000000c1</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ arm-none-eabi-objdump -t build/minimal.elf | sort
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>000000b4 g     F .text  <span style="color:#ae81ff">00000006</span> NMI_Handler
</span></span><span style="display:flex;"><span>000000ba g     F .text  <span style="color:#ae81ff">00000006</span> HardFault_Handler
</span></span><span style="display:flex;"><span>000000c0 g     F .text  <span style="color:#ae81ff">00000088</span> Reset_Handler
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000148</span> l     F .text  0000005c system_pinmux_get_group_from_gpio_pin
</span></span><span style="display:flex;"><span>000001a4 l     F .text  <span style="color:#ae81ff">00000020</span> port_get_group_from_gpio_pin
</span></span><span style="display:flex;"><span>000001c4 l     F .text  <span style="color:#ae81ff">00000022</span> port_get_config_defaults
</span></span><span style="display:flex;"><span>000001e6 l     F .text  0000004e port_pin_set_output_level
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000234</span> l     F .text  <span style="color:#ae81ff">00000038</span> port_pin_toggle_output_level
</span></span><span style="display:flex;"><span>0000026c l     F .text  <span style="color:#ae81ff">00000040</span> set_output
</span></span><span style="display:flex;"><span>000002ac g     F .text  0000002c main
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>看起来很奇怪, Our <code>main</code> function is found at <code>0x000002ac</code>. No symbol at <code>0x000000c1</code>, but a <code>Reset_Handler</code> symbol at <code>0x000000c0</code>.</p>
<p>事实证明, the lowest bit of the PC is used to indicate thumb2 instructions, which is one of the two instruction sets supported by ARM processors, so <code>Reset_Handler</code> is what we’re looking for (for more details check out section A4.1.1 in the ARMv6-M manual).</p>
<h2 id="write-a-reset_handler">Write a Reset_Handler<a hidden class="anchor" aria-hidden="true" href="#write-a-reset_handler">#</a></h2>
<p>不幸的是，Reset_Handler通常是一堆难以理解的汇编代码。这个贴nRF52 SDK的startup file展示:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-S" data-lang="S"><span style="display:flex;"><span><span style="color:#f92672">/*</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Copyright </span>(c) <span style="color:#ae81ff">2009-2018</span> ARM Limited. All rights reserved.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    SPDX<span style="color:#f92672">-</span>License<span style="color:#f92672">-</span>Identifier<span style="color:#f92672">:</span> Apache<span style="color:#ae81ff">-2.0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Licensed under the Apache License, Version <span style="color:#ae81ff">2.0</span> (the License); you may
</span></span><span style="display:flex;"><span>not use this file except in compliance with the License.
</span></span><span style="display:flex;"><span>You may obtain a copy of the License at
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    www.apache.org<span style="color:#f92672">/</span>licenses<span style="color:#f92672">/</span>LICENSE<span style="color:#ae81ff">-2.0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Unless required by applicable law or agreed to in writing, software
</span></span><span style="display:flex;"><span>distributed under the License is distributed on an AS IS BASIS, WITHOUT
</span></span><span style="display:flex;"><span>WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</span></span><span style="display:flex;"><span>See the License for the specific language governing permissions and
</span></span><span style="display:flex;"><span>limitations under the License.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NOTICE<span style="color:#f92672">:</span> This file has been modified by Nordic Semiconductor ASA.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    .syntax unified
</span></span><span style="display:flex;"><span>    .arch armv7e<span style="color:#f92672">-</span>m
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef __STARTUP_CONFIG</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include &#34;startup_config.h&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef __STARTUP_CONFIG_STACK_ALIGNEMENT</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define __STARTUP_CONFIG_STACK_ALIGNEMENT 3</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    .section .stack
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(__STARTUP_CONFIG)</span>
</span></span><span style="display:flex;"><span>    .align __STARTUP_CONFIG_STACK_ALIGNEMENT
</span></span><span style="display:flex;"><span>    .equ    Stack_Size, __STARTUP_CONFIG_STACK_SIZE
</span></span><span style="display:flex;"><span><span style="color:#75715e">#elif defined(__STACK_SIZE)</span>
</span></span><span style="display:flex;"><span>    .align <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>    .equ    Stack_Size, __STACK_SIZE
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else</span>
</span></span><span style="display:flex;"><span>    .align <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>    .equ    Stack_Size, <span style="color:#ae81ff">8192</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif</span>
</span></span><span style="display:flex;"><span>    .globl __StackTop
</span></span><span style="display:flex;"><span>    .globl __StackLimit
</span></span><span style="display:flex;"><span>__StackLimit<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    .space Stack_Size
</span></span><span style="display:flex;"><span>    .size __StackLimit, . <span style="color:#f92672">-</span> __StackLimit
</span></span><span style="display:flex;"><span>__StackTop<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    .size __StackTop, . <span style="color:#f92672">-</span> __StackTop
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    .section .heap
</span></span><span style="display:flex;"><span>    .align <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(__STARTUP_CONFIG)</span>
</span></span><span style="display:flex;"><span>    .equ Heap_Size, __STARTUP_CONFIG_HEAP_SIZE
</span></span><span style="display:flex;"><span><span style="color:#75715e">#elif defined(__HEAP_SIZE)</span>
</span></span><span style="display:flex;"><span>    .equ Heap_Size, __HEAP_SIZE
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else</span>
</span></span><span style="display:flex;"><span>    .equ Heap_Size, <span style="color:#ae81ff">8192</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif</span>
</span></span><span style="display:flex;"><span>    .globl __HeapBase
</span></span><span style="display:flex;"><span>    .globl __HeapLimit
</span></span><span style="display:flex;"><span>__HeapBase<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    .if Heap_Size
</span></span><span style="display:flex;"><span>    .space Heap_Size
</span></span><span style="display:flex;"><span>    .endif
</span></span><span style="display:flex;"><span>    .size __HeapBase, . <span style="color:#f92672">-</span> __HeapBase
</span></span><span style="display:flex;"><span>__HeapLimit<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    .size __HeapLimit, . <span style="color:#f92672">-</span> __HeapLimit
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    .section .isr_vector
</span></span><span style="display:flex;"><span>    .align <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    .globl __isr_vector
</span></span><span style="display:flex;"><span>__isr_vector<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    .long   __StackTop                  <span style="color:#f92672">/*</span> Top of Stack <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   Reset_Handler
</span></span><span style="display:flex;"><span>    .long   NMI_Handler
</span></span><span style="display:flex;"><span>    .long   HardFault_Handler
</span></span><span style="display:flex;"><span>    .long   MemoryManagement_Handler
</span></span><span style="display:flex;"><span>    .long   BusFault_Handler
</span></span><span style="display:flex;"><span>    .long   UsageFault_Handler
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   SVC_Handler
</span></span><span style="display:flex;"><span>    .long   DebugMon_Handler
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   PendSV_Handler
</span></span><span style="display:flex;"><span>    .long   SysTick_Handler
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">/*</span> External Interrupts <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   POWER_CLOCK_IRQHandler
</span></span><span style="display:flex;"><span>    .long   RADIO_IRQHandler
</span></span><span style="display:flex;"><span>    .long   UARTE0_UART0_IRQHandler
</span></span><span style="display:flex;"><span>    .long   SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQHandler
</span></span><span style="display:flex;"><span>    .long   SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQHandler
</span></span><span style="display:flex;"><span>    .long   NFCT_IRQHandler
</span></span><span style="display:flex;"><span>    .long   GPIOTE_IRQHandler
</span></span><span style="display:flex;"><span>    .long   SAADC_IRQHandler
</span></span><span style="display:flex;"><span>    .long   TIMER0_IRQHandler
</span></span><span style="display:flex;"><span>    .long   TIMER1_IRQHandler
</span></span><span style="display:flex;"><span>    .long   TIMER2_IRQHandler
</span></span><span style="display:flex;"><span>    .long   RTC0_IRQHandler
</span></span><span style="display:flex;"><span>    .long   TEMP_IRQHandler
</span></span><span style="display:flex;"><span>    .long   RNG_IRQHandler
</span></span><span style="display:flex;"><span>    .long   ECB_IRQHandler
</span></span><span style="display:flex;"><span>    .long   CCM_AAR_IRQHandler
</span></span><span style="display:flex;"><span>    .long   WDT_IRQHandler
</span></span><span style="display:flex;"><span>    .long   RTC1_IRQHandler
</span></span><span style="display:flex;"><span>    .long   QDEC_IRQHandler
</span></span><span style="display:flex;"><span>    .long   COMP_LPCOMP_IRQHandler
</span></span><span style="display:flex;"><span>    .long   SWI0_EGU0_IRQHandler
</span></span><span style="display:flex;"><span>    .long   SWI1_EGU1_IRQHandler
</span></span><span style="display:flex;"><span>    .long   SWI2_EGU2_IRQHandler
</span></span><span style="display:flex;"><span>    .long   SWI3_EGU3_IRQHandler
</span></span><span style="display:flex;"><span>    .long   SWI4_EGU4_IRQHandler
</span></span><span style="display:flex;"><span>    .long   SWI5_EGU5_IRQHandler
</span></span><span style="display:flex;"><span>    .long   TIMER3_IRQHandler
</span></span><span style="display:flex;"><span>    .long   TIMER4_IRQHandler
</span></span><span style="display:flex;"><span>    .long   PWM0_IRQHandler
</span></span><span style="display:flex;"><span>    .long   PDM_IRQHandler
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   MWU_IRQHandler
</span></span><span style="display:flex;"><span>    .long   PWM1_IRQHandler
</span></span><span style="display:flex;"><span>    .long   PWM2_IRQHandler
</span></span><span style="display:flex;"><span>    .long   SPIM2_SPIS2_SPI2_IRQHandler
</span></span><span style="display:flex;"><span>    .long   RTC2_IRQHandler
</span></span><span style="display:flex;"><span>    .long   I2S_IRQHandler
</span></span><span style="display:flex;"><span>    .long   FPU_IRQHandler
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>    .long   <span style="color:#ae81ff">0</span>                           <span style="color:#f92672">/*</span>Reserved <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    .size __isr_vector, . <span style="color:#f92672">-</span> __isr_vector
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">/*</span> Reset Handler <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    .text
</span></span><span style="display:flex;"><span>    .thumb
</span></span><span style="display:flex;"><span>    .thumb_func
</span></span><span style="display:flex;"><span>    .align <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    .globl Reset_Handler
</span></span><span style="display:flex;"><span>    .type Reset_Handler, <span style="color:#f92672">%function
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">Reset_Handler:
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">/* Loop to copy data from read only memory to RAM.
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"> * The ranges of copy from/to are specified by following symbols:
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"> *      __etext: LMA of start of the section to copy from. Usually end of text
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"> *      __data_start__: VMA of start of the section to copy to.
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"> *      __bss_start__: VMA of end of the section to copy to. Normally __data_end__ is used, but by using __bss_start__
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"> *                    the user can add their own initialized data section before BSS section with the INTERT AFTER command.
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"> *
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"> * All addresses must be aligned to 4 bytes boundary.
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"> */
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    ldr r1, =__etext
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    ldr r2, =__data_start__
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    ldr r3, =__bss_start__
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    subs r3, r3, r2
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    ble .L_loop1_done
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">.L_loop1:
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    subs r3, r3, #4
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    ldr r0, [r1,r3]
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    str r0, [r2,r3]
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    bgt .L_loop1
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">.L_loop1_done:
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">/* This part of work usually is done in C library startup code. Otherwise,
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"> * define __STARTUP_CLEAR_BSS to enable it in this startup. This section
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"> * clears the RAM where BSS data is located.
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"> *
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"> * The BSS section is specified by following symbols
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"> *    __bss_start__: start of the BSS section.
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"> *    __bss_end__: end of the BSS section.
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"> *
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"> * All addresses must be aligned to 4 bytes boundary.
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"> */
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">#ifdef __STARTUP_CLEAR_BSS
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    ldr r1, =__bss_start__
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    ldr r2, =__bss_end__
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    movs r0, 0
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    subs r2, r2, r1
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    ble .L_loop3_done
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">.L_loop3:
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    subs r2, r2, #4
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    str r0, [r1, r2]
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    bgt .L_loop3
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">.L_loop3_done:
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">#endif /* __STARTUP_CLEAR_BSS */
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">/* Execute SystemInit function. */
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    bl SystemInit
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">/* Call _start function provided by libraries.
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"> * If those libraries are not accessible, define __START as your entry point.
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"> */
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">#ifndef __START
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">#define __START _start
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    bl __START
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    .pool
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    .size   Reset_Handler,.-Reset_Handler
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    .section &#34;.text&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">/* Dummy Exception Handlers (infinite loops which can be modified) */
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    .weak   NMI_Handler
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    .type   NMI_Handler, %</span>function
</span></span><span style="display:flex;"><span>NMI_Handler<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    b       .
</span></span><span style="display:flex;"><span>    .size   NMI_Handler, . <span style="color:#f92672">-</span> NMI_Handler
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    .weak   HardFault_Handler
</span></span><span style="display:flex;"><span>    .type   HardFault_Handler, <span style="color:#f92672">%function
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">HardFault_Handler:
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    b       .
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    .size   HardFault_Handler, . - HardFault_Handler
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    .weak   MemoryManagement_Handler
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    .type   MemoryManagement_Handler, %</span>function
</span></span><span style="display:flex;"><span>MemoryManagement_Handler<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    b       .
</span></span><span style="display:flex;"><span>    .size   MemoryManagement_Handler, . <span style="color:#f92672">-</span> MemoryManagement_Handler
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    .weak   BusFault_Handler
</span></span><span style="display:flex;"><span>    .type   BusFault_Handler, <span style="color:#f92672">%function
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">BusFault_Handler:
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    b       .
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    .size   BusFault_Handler, . - BusFault_Handler
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    .weak   UsageFault_Handler
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    .type   UsageFault_Handler, %</span>function
</span></span><span style="display:flex;"><span>UsageFault_Handler<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    b       .
</span></span><span style="display:flex;"><span>    .size   UsageFault_Handler, . <span style="color:#f92672">-</span> UsageFault_Handler
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    .weak   SVC_Handler
</span></span><span style="display:flex;"><span>    .type   SVC_Handler, <span style="color:#f92672">%function
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">SVC_Handler:
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    b       .
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    .size   SVC_Handler, . - SVC_Handler
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    .weak   DebugMon_Handler
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    .type   DebugMon_Handler, %</span>function
</span></span><span style="display:flex;"><span>DebugMon_Handler<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    b       .
</span></span><span style="display:flex;"><span>    .size   DebugMon_Handler, . <span style="color:#f92672">-</span> DebugMon_Handler
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    .weak   PendSV_Handler
</span></span><span style="display:flex;"><span>    .type   PendSV_Handler, <span style="color:#f92672">%function
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">PendSV_Handler:
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    b       .
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    .size   PendSV_Handler, . - PendSV_Handler
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    .weak   SysTick_Handler
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">    .type   SysTick_Handler, %</span>function
</span></span><span style="display:flex;"><span>SysTick_Handler<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    b       .
</span></span><span style="display:flex;"><span>    .size   SysTick_Handler, . <span style="color:#f92672">-</span> SysTick_Handler
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">/*</span> IRQ Handlers <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    .globl  Default_Handler
</span></span><span style="display:flex;"><span>    .type   Default_Handler, %function
</span></span><span style="display:flex;"><span>Default_Handler<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    b       .
</span></span><span style="display:flex;"><span>    .size   Default_Handler, . <span style="color:#f92672">-</span> Default_Handler
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    .macro  IRQ handler
</span></span><span style="display:flex;"><span>    .weak   \handler
</span></span><span style="display:flex;"><span>    .set    \handler, Default_Handler
</span></span><span style="display:flex;"><span>    .endm
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    IRQ  POWER_CLOCK_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  RADIO_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  UARTE0_UART0_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  NFCT_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  GPIOTE_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  SAADC_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  TIMER0_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  TIMER1_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  TIMER2_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  RTC0_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  TEMP_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  RNG_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  ECB_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  CCM_AAR_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  WDT_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  RTC1_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  QDEC_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  COMP_LPCOMP_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  SWI0_EGU0_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  SWI1_EGU1_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  SWI2_EGU2_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  SWI3_EGU3_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  SWI4_EGU4_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  SWI5_EGU5_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  TIMER3_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  TIMER4_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  PWM0_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  PDM_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  MWU_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  PWM1_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  PWM2_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  SPIM2_SPIS2_SPI2_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  RTC2_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  I2S_IRQHandler
</span></span><span style="display:flex;"><span>    IRQ  FPU_IRQHandler
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  .end
</span></span></code></pre></div><p>let’s see if we can write a minimal Reset_Handler from first principles.
ARM’s Technical Reference Manuals are useful. <a href="https://developer.arm.com/docs/ddi0337/e/exceptions/resets/intended-boot-up-sequence">Section 5.9.2 of the Cortex-M3 TRM</a> contains the following table:
| Reset boot-up behavior|</p>
<table>
<thead>
<tr>
<th>Action</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Initialize variables</td>
<td>Any global/static variables must be setup. This includes initializing the BSS variable to 0, and copying initial values from ROM to RAM for non-constant variables.</td>
</tr>
<tr>
<td>[Setup stacks]</td>
<td>If more than one stack is be used, the other banked SPs must be initialized. The current SP can also be changed to Process from Main.</td>
</tr>
<tr>
<td>[Initialize any runtime]</td>
<td>Optionally make calls to C/C++ runtime init code to enable use of heap, floating point, or other features. This is normally done by __main from the C/C++ library.</td>
</tr>
</tbody>
</table>
<p>So, our ResetHandler is responsible for initializing static and global variables, and starting our program.
We rely on the compiler (technically, the linker) to put all those variables in the same place so we can initialize them in one fell swoop.</p>
<p>For static variables that must be zeroed, the linker gives us</p>
<ul>
<li><code>_sbss</code> as the start addresses the static variables live at</li>
<li><code>_ebss</code> as the end addresses the static variables live at</li>
</ul>
<p>We can do</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Clear the zero segment */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>bss_ptr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_sbss; bss_ptr <span style="color:#f92672">&lt;</span> <span style="color:#f92672">&amp;</span>_ebss;) {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>bss_ptr<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>For static variables with an init value, the linker gives us:</p>
<ul>
<li><code>_etext</code> as the address the init values are stored at</li>
<li><code>_sdata</code> as the address the static variables live at</li>
<li><code>_edata</code> as the end of the static variables memory</li>
</ul>
<p>We can do</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>init_values_ptr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_etext;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>data_ptr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_sdata;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (init_values_ptr <span style="color:#f92672">!=</span> data_ptr) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (; data_ptr <span style="color:#f92672">&lt;</span> <span style="color:#f92672">&amp;</span>_edata;) {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>data_ptr<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>init_values_ptr<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Putting it together, and with a call to <code>main()</code> to start our program, we write our Reset_Handler:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Reset_Handler</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Copy init values from text to data */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>init_values_ptr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_etext;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>data_ptr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_sdata;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (init_values_ptr <span style="color:#f92672">!=</span> data_ptr) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (; data_ptr <span style="color:#f92672">&lt;</span> <span style="color:#f92672">&amp;</span>_edata;) {
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">*</span>data_ptr<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>init_values_ptr<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Clear the zero segment */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>bss_ptr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_sbss; bss_ptr <span style="color:#f92672">&lt;</span> <span style="color:#f92672">&amp;</span>_ebss;) {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>bss_ptr<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Overwriting the default value of the NVMCTRL.CTRLB.MANW bit (errata reference 13134) */</span>
</span></span><span style="display:flex;"><span>    NVMCTRL<span style="color:#f92672">-&gt;</span>CTRLB.bit.MANW <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Branch to main function */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">main</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Infinite loop */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We add two more things:</p>
<ol>
<li>An infinite loop after main(), so we do not run off into the weeds if the main function returns</li>
<li>Workaround for chip bugs which are best taken care of before our program starts. Sometimes these are wrapped in a <code>SystemInit</code> function called by the <code>Reset_Handler</code> before <code>main</code>.</li>
</ol>
<h1 id="firmware-linker-scripts">Firmware Linker Scripts<a hidden class="anchor" aria-hidden="true" href="#firmware-linker-scripts">#</a></h1>
<p>Linking is the last stage in compiling a program. It takes a number of compiled object files and merges them into a single program, filling in addresses so that everything is in the right place.</p>
<p>Prior to linking, the compiler will have taken your source files one by one and compiled them into machine code. In the process, it leaves placeholders for addresses as (1) it does not know where the code will end up within the broader structure of the program and (2) it knows nothing about symbols outside of the current file or compilation unit.</p>
<p>The linker takes all of those object files and merges them together along with external dependencies like the C Standard Library into your program. To figure out which bits go where, the linker relies on a linker script - a blueprint for your program. Lastly, all placeholders are replaced by addresses.</p>
<h2 id="anatomy-of-a-linker-script">Anatomy of a Linker Script<a hidden class="anchor" aria-hidden="true" href="#anatomy-of-a-linker-script">#</a></h2>
<p>A linker script contains four things:</p>
<ol>
<li>Memory layout: what memory is available where</li>
<li>Section definitions: what part of a program should go where</li>
<li>Options: commands to specify architecture, entry point, …etc. if needed</li>
<li>Symbols: variables to inject into the program at link time</li>
</ol>
<h2 id="memory-layout">Memory Layout<a hidden class="anchor" aria-hidden="true" href="#memory-layout">#</a></h2>
<p>In order to allocate program space, the linker needs to know how much memory is available, and at what addresses that memory exists. This is what the MEMORY definition in the linker script is for.</p>
<p>The syntax for MEMORY is defined in the binutils docs and is as follow:</p>
<pre tabindex="0"><code class="language-ld" data-lang="ld">MEMORY
  {
    name [(attr)] : ORIGIN = origin, LENGTH = len
    …
  }
</code></pre><ul>
<li><code>name</code> is a name you want to use for this region. Names do not carry meaning, so you’re free to use anything you want. You’ll often find “flash”, and “ram” as region names.</li>
<li><code>(attr)</code> are optional attributes for the region, like whether it’s writable (w), readable (r), or executable (x). Flash memory is usually (rx), while ram is rwx. Marking a region as non-writable does not magically make it write protected: these attributes are meant to describe the properties of the memory, not set it.</li>
<li><code>origin</code> is the start address of the memory region.</li>
<li><code>len</code> is the size of the memory region, in bytes.</li>
</ul>
<p>Translate SAMD21G18 Chip Memory Map</p>
<table>
<thead>
<tr>
<th>Memory</th>
<th>Start</th>
<th>Address Size</th>
</tr>
</thead>
<tbody>
<tr>
<td>Internal Flash</td>
<td>0x00000000</td>
<td>256 Kbytes</td>
</tr>
<tr>
<td>Internal SRAM</td>
<td>0x20000000</td>
<td>32 Kbytes</td>
</tr>
</tbody>
</table>
<p>as</p>
<pre tabindex="0"><code class="language-ld" data-lang="ld">MEMORY
{
  rom      (rx)  : ORIGIN = 0x00000000, LENGTH = 0x00040000
  ram      (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00008000
}
</code></pre><h2 id="section-definitions">Section Definitions<a hidden class="anchor" aria-hidden="true" href="#section-definitions">#</a></h2>
<p>Code and data are bucketed into sections, which are contiguous areas of memory. There are no hard rules about how many sections you should have, or what they should be, but you typically want to put symbols in the same section if:</p>
<ol>
<li>They should be in the same region of memory, or</li>
<li>They need to be initialized together.</li>
</ol>
<p>In our previous post, we learned about two types of symbols that are initialized in bulk:</p>
<ol>
<li>Initialized static variables which must be copied from flash</li>
<li>Uninitialized static variables which must be zeroed.</li>
</ol>
<p>Our linker script concerns itself with two more things:</p>
<ol>
<li>Code and constant data, which can live in read-only memory (e.g. flash)</li>
<li>Reserved sections of RAM, like a stack or a heap</li>
</ol>
<p>By convention, we name those sections as follow:</p>
<ol>
<li><code>.text</code> for code &amp; constants</li>
<li><code>.bss</code> for uninitialized data</li>
<li><code>.stack</code> for our stack</li>
<li><code>.data</code> for initialized data</li>
</ol>
<p>The <a href="http://refspecs.linuxbase.org/elf/elf.pdf">elf spec</a> holds a full list. Your firmware will work just fine if you call them anything else, but your colleagues may be confused and some tools may fail in odd ways. The only constraint is that you may not call your section <code>/DISCARD/</code>, which is a reserved keyword.</p>
<p>First, let’s look at what happens to our symbols if we do not define any of those sections in the linker script.</p>
<pre><code>MEMORY
{
  rom      (rx)  : ORIGIN = 0x00000000, LENGTH = 0x00040000
  ram      (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00008000
}

SECTIONS
{
    /* empty! */
}
</code></pre>
<p>The linker is perfectly happy to link our program with this. Probing the resulting elf file with objdump, we see the following:</p>
<pre><code>$ arm-none-eabi-objdump -h build/minimal.elf
build/minimal.elf:     file format elf32-littlearm

SYMBOL TABLE:
no symbols
</code></pre>
<p>No symbols! While the linker is able to make assumptions that will allow it to link in symbols with little information, but it at least needs to know either what the entry point should be, or what symbols to put in the text section.</p>
<h3 id="text-section"><code>.text</code> Section<a hidden class="anchor" aria-hidden="true" href="#text-section">#</a></h3>
<p>Let’s start by adding our <code>.text</code> section. We want that section in ROM. The syntax is simple:</p>
<pre><code>SECTIONS
{
    .text :
    {

    } &gt; rom
}
</code></pre>
<p>This defines a section named <code>.text</code>, and adds it to the ROM. We now need to tell the linker what to put in that section. This is accomplished by listing all of the sections from our input object files we want in <code>.text</code>.</p>
<p>To find out what sections are in our object file, we can once again use <code>objdump</code>:</p>
<pre><code>$ arm-none-eabi-objdump -h
build/objs/a/b/c/minimal.o:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .bss.cpu_irq_critical_section_counter 00000004  00000000  00000000  00000034
2**2
                  ALLOC
  4 .bss.cpu_irq_prev_interrupt_state 00000001  00000000  00000000  00000034
2**0
                  ALLOC
  5 .text.system_pinmux_get_group_from_gpio_pin 0000005c  00000000  00000000
00000034  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text.port_get_group_from_gpio_pin 00000020  00000000  00000000  00000090
2**1
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.port_get_config_defaults 00000022  00000000  00000000  000000b0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text.port_pin_set_output_level 0000004e  00000000  00000000  000000d2  2**1
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.port_pin_toggle_output_level 00000038  00000000  00000000  00000120
2**1
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.set_output 00000040  00000000  00000000  00000158  2**1
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text.main    0000002c  00000000  00000000  00000198  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
</code></pre>
<p>We see that each of our symbol has a section. This is due to the fact that we compiled our firmware with the <code>-ffunction-sections</code> and <code>-fdata-sections</code> flags. Had we not included them, the compiler would have been free to merge several functions into a single <code>text.&lt;some identifier&gt;</code> section.</p>
<p>To put all of our functions in the <code>.text</code> section in our linker script, we use the following syntax: <code>&lt;filename&gt;(&lt;section&gt;)</code>, where <code>filename</code> is the name of the input files whose symbols we want to include, and <code>section</code> is the name of the input sections. Since we want all <code>.text...</code> sections in all files, we use the wildcard <code>*</code>:</p>
<pre><code>.text :
{
    KEEP(*(.vector*))
    *(.text*)
} &gt; rom
</code></pre>
<p>Note the <code>.vector</code> input section, which contains functions we want to keep at the very start of our <code>.text</code> section. This is so the <code>Reset_Handler</code> is where the MCU expects it to be. We’ll talk more about the vector table in a future post.</p>
<p>Dumping our elf file, we now see all of our functions (but no data)!</p>
<pre><code>$ arm-none-eabi-objdump -t build/minimal.elf

build/minimal.elf:     file format elf32-littlearm

SYMBOL TABLE:
00000000 l    d  .text  00000000 .text
...
00000000 l    df *ABS*  00000000 minimal.c
00000000 l     F .text  0000005c system_pinmux_get_group_from_gpio_pin
0000005c l     F .text  00000020 port_get_group_from_gpio_pin
0000007c l     F .text  00000022 port_get_config_defaults
0000009e l     F .text  0000004e port_pin_set_output_level
000000ec l     F .text  00000038 port_pin_toggle_output_level
00000124 l     F .text  00000040 set_output
00000000 l    df *ABS*  00000000 port.c
00000190 l     F .text  00000028 system_pinmux_get_config_defaults
00000000 l    df *ABS*  00000000 pinmux.c
00000208 l     F .text  0000005c system_pinmux_get_group_from_gpio_pin
00000264 l     F .text  00000110 _system_pinmux_config
00000164 g     F .text  0000002c main
000001b8 g     F .text  0000004e port_pin_set_config
00000374 g     F .text  00000040 system_pinmux_pin_set_config
...
</code></pre>
<h3 id="bss-section"><code>.bss</code> Section<a hidden class="anchor" aria-hidden="true" href="#bss-section">#</a></h3>
<p>Now, let’s take care of our <code>.bss</code>. Remember, this is the section we put uninitialized static memory in. <code>.bss</code> must be reserved in the memory map, but there is nothing to load, as all variables are initialized to zero. As such, this is what it should look like:</p>
<pre><code>SECTION {
    ...
    .bss (NOLOAD) :
    {
        *(.bss*)
        *(COMMON)
    } &gt; ram
}
</code></pre>
<p>You’ll note that the <code>.bss</code> section also includes <code>*(COMMON)</code>. This is a special input section where the compiler puts global uninitialized variables that go beyond file scope. <code>int foo;</code> goes there, while <code>static int foo;</code> does not. This allows the linker to merge multiple definitions into one symbol if they have the same name.</p>
<p>We indicate that this section is not loaded with the <code>NOLOAD</code> property. This is the only section property used in modern linker scripts.</p>
<h3 id="stack-section"><code>.stack</code> Section<a hidden class="anchor" aria-hidden="true" href="#stack-section">#</a></h3>
<p>We do the same thing for our <code>.stack</code> memory, since it is in RAM and not loaded. As the stack contains no symbols, we must explicitly reserve space for it by indicating its size. We also must align the stack on an 8-byte boundary per ARM Procedure Call Standards (<a href="https://static.docs.arm.com/ddi0403/ec/DDI0403E_c_armv7m_arm.pdf">AAPCS</a>).</p>
<p>In order to achieve these goals, we turn to a special variable <code>.</code>, also known as the “location counter”. The location counter tracks the current offset into a given memory region. As sections are added, the location counter increments accordingly. You can force alignment or gaps by setting the location counter forward. You may not set it backwards, and the linker will throw an error if you try.</p>
<p>We set the location counter with the <code>ALIGN</code> function, to align the section, and use simple assignment and arithmetic to set the section size:</p>
<pre><code>STACK_SIZE = 0x2000; /* 8 kB */

SECTION {
    ...
    .stack (NOLOAD) :
    {
        . = ALIGN(8);
        . = . + STACK_SIZE;
        . = ALIGN(8);
    } &gt; ram
    ...
}
</code></pre>
<p>Only one more section to go!</p>
<h3 id="data-section"><code>.data</code> Section<a hidden class="anchor" aria-hidden="true" href="#data-section">#</a></h3>
<p>The <code>.data</code> section contains static variables which have an initial value at boot. You will remember from our previous article that since RAM isn’t persisted while power is off, those sections need to be loaded from flash. At boot, the <code>Reset_Handler</code> copies the data from flash to RAM before the <code>main</code> function is called.</p>
<p>To make this possible, every section in our linker script has two addresses, its <em>load</em> address (LMA) and its <em>virtual</em> address (VMA). In a firmware context, the LMA is where your JTAG loader needs to place the section and the VMA is where the section is found during execution.</p>
<p>You can think of the LMA as the address “at rest” and the VMA the address during execution i.e. when the device is on and the program is running.</p>
<p>The syntax to specify the LMA and VMA is relatively straightforward: every address is two part: AT . In our case it looks like this:</p>
<pre tabindex="0"><code class="language-ld" data-lang="ld">    .data :
    {
        *(.data*);
    } &gt; ram AT &gt; rom  /* &#34;&gt; ram&#34; is the VMA, &#34;&gt; rom&#34; is the LMA */
</code></pre><p>Note that instead of appending a section to a memory region, you could also explicitly specify an address like so:</p>
<pre tabindex="0"><code class="language-ld" data-lang="ld">    .data ORIGIN(ram) /* VMA */ : AT(ORIGIN(rom)) /* LMA */
    {
        . = ALIGN(4);
        _sdata = .;
        *(.data*);
        . = ALIGN(4);
        _edata = .;
    }
</code></pre><p>Where <code>ORIGIN(&lt;region&gt;)</code> is a simple way to specify the start of a region. You can enter an address in hex as well.</p>
<p>And we’re done! Here’s our complete linker script with every section:</p>
<h2 id="complete-linker-script">Complete Linker Script<a hidden class="anchor" aria-hidden="true" href="#complete-linker-script">#</a></h2>
<pre><code>MEMORY
{
  rom      (rx)  : ORIGIN = 0x00000000, LENGTH = 0x00040000
  ram      (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00008000
}

STACK_SIZE = 0x2000;

/* Section Definitions */
SECTIONS
{
    .text :
    {
        KEEP(*(.vectors .vectors.*))
        *(.text*)
        *(.rodata*)
    } &gt; rom

    /* .bss section which is used for uninitialized data */
    .bss (NOLOAD) :
    {
        *(.bss*)
        *(COMMON)
    } &gt; ram

    .data :
    {
        *(.data*);
    } &gt; ram AT &gt;rom

    /* stack section */
    .stack (NOLOAD):
    {
        . = ALIGN(8);
        . = . + STACK_SIZE;
        . = ALIGN(8);
    } &gt; ram

    _end = . ;
}
</code></pre>
<p>You can find the full details on linker script sections syntax in the <a href="https://sourceware.org/binutils/docs/ld/SECTIONS.html#SECTIONS">ld manual</a>.</p>
<h2 id="variables">Variables<a hidden class="anchor" aria-hidden="true" href="#variables">#</a></h2>
<p>In the first post, our <code>ResetHandler</code> relied on seemingly magic variables to know the address of each of our sections of memory. It turns out, those variable came</p>
<p>In order to make section addresses available to code, the linker is able to generate symbols and add them to the program.</p>
<p>You can find the syntax in the <a href="https://sourceware.org/binutils/docs/ld/Simple-Assignments.html#Simple-Assignments">linker documentation</a>, it looks exactly like a C assignment: <code>symbol = expression;</code></p>
<p>Here, we need:</p>
<ol>
<li><code>_etext</code> the end of the code in <code>.text</code> section in flash.</li>
<li><code>_sdata</code> the start of the <code>.data</code> section in RAM</li>
<li><code>_edata</code> the end of the <code>.data</code> section in RAM</li>
<li><code>_sbss</code> the start of the <code>.bss</code> section in RAM</li>
<li><code>_ebss</code> the end of the <code>.bss</code> section in RAM</li>
</ol>
<p>They are all relatively straightforward: we can assign our symbols to the value of the location counter (<code>.</code>) at the start and at the end of each section definition.</p>
<p>The code is below:</p>
<pre><code>    .text :
    {
        KEEP(*(.vectors .vectors.*))
        *(.text.*)
        *(.rodata.*)
        _etext = .;
    } &gt; rom

    .bss (NOLOAD) :
    {
        _sbss = . ;
        *(.bss .bss.*)
        *(COMMON)
        _ebss = . ;
    } &gt; ram

    .data :
    {
        _sdata = .;
        *(.data*);
        _edata = .;
    } &gt; ram AT &gt;rom
</code></pre>
<p>One quirk of these linker-provided symbols: you must use a reference to them, never the variable themselves. For example, the following gets us a pointer to the start of the <code>.data</code> section:</p>
<pre><code>uint8_t *data_byte = &amp;_sdata;
</code></pre>
<p>You can read more details about this in the <a href="https://sourceware.org/binutils/docs/ld/Source-Code-Reference.html">binutils docs</a>.</p>
<hr>
<h1 id="write-a-bootloader-from-scratch">Write a Bootloader from Scratch<a hidden class="anchor" aria-hidden="true" href="#write-a-bootloader-from-scratch">#</a></h1>
<p>Previously, we</p>
<ol>
<li>wrote a startup file to bootstrap our C environment, and</li>
<li>a linker script to get the right data at the right addresses.</li>
</ol>
<p>These two will allow us to write a monolithic firmware which we can load and run on our microcontrollers.</p>
<p>In practice, this is not how most firmware is structured. Digging through vendor SDKs, you’ll notice that they all recommend using a <em>bootloader</em> to load your applications. A bootloader is a small program which is responsible for loading and starting your application.</p>
<p>In this part, we will explain why you may want a bootloader, how to implement one, and cover a few advanced techniques you may use to make your bootloader more useful.</p>
<h2 id="why-you-may-need-a-bootloader">Why you may need a bootloader<a hidden class="anchor" aria-hidden="true" href="#why-you-may-need-a-bootloader">#</a></h2>
<p>Bootloaders serve many purposes, ranging from security to software architecture.</p>
<p>Most commonly, you may need a bootloader to load your software. Some microcontrollers like Dialog’s <a href="https://www.dialog-semiconductor.com/products/connectivity/bluetooth-low-energy/smartbond-da14580-and-da14583">DA14580</a> have little to no onboard flash and instead rely on an external device to store firmware code. In that case, it is the bootloader’s job to copy code from non-executable storage, such as a SPI flash, to an area of memory that can be executed from, such as RAM.</p>
<p>Bootloaders also allow you to decouple parts of the program that are mission critical, or that have security implications, from application code which changes regularly. For example, your bootloader may contain firmware update logic so your device can recover no matter how bad a bug ships in your application firmware.</p>
<p>Last but certainly not least, bootloaders are an essential component of a trusted boot architecture. Your bootloader can, for example, verify a cryptographic signature to make sure the application has not been replaced or tampered with.</p>
<h2 id="a-minimal-bootloader">A minimal bootloader<a hidden class="anchor" aria-hidden="true" href="#a-minimal-bootloader">#</a></h2>
<p>Let’s build a simple bootloader together. To start, our bootloader must do two things:</p>
<ol>
<li>Execute on MCU boot</li>
<li>Jump to our application code</li>
</ol>
<p>We’ll need to decide on a memory map, write some bootloader code, and update our application to make it bootload-able.</p>
<h3 id="setting-the-stage">Setting the stage<a hidden class="anchor" aria-hidden="true" href="#setting-the-stage">#</a></h3>
<p>For this example, we’ll be using the same setup as we did in our previous Zero to Main posts:</p>
<ul>
<li>Adafruit’s <a href="https://www.adafruit.com/product/3505">Metro M0 Express</a> as our development board,</li>
<li>a simple <a href="https://www.adafruit.com/product/2764">CMSIS-DAP Adapter</a></li>
<li>OpenOCD (the <a href="https://github.com/arduino/OpenOCD">Arduino fork</a>) for programming</li>
</ul>
<h3 id="deciding-on-a-memory-map">Deciding on a memory map<a hidden class="anchor" aria-hidden="true" href="#deciding-on-a-memory-map">#</a></h3>
<p>We must first decide on how much space we want to dedicate to our bootloader. Code space is precious - your application may come to need more of it - and you will not be able to change this without updating your bootloader, so make this as small as you possibly can.</p>
<p>Another important factor is your flash sector size: you want to make sure you can erase app sectors without erasing bootloader data, or vice versa. Consequently, your bootloader region must end on a flash sector boundary (typically 4kB).</p>
<p>I decided to go with a 16kB region, leading to the following memory map:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>            0x0 +---------------------+
</span></span><span style="display:flex;"><span>                |                     |
</span></span><span style="display:flex;"><span>                |     Bootloader      |
</span></span><span style="display:flex;"><span>                |                     |
</span></span><span style="display:flex;"><span>         0x4000 +---------------------+
</span></span><span style="display:flex;"><span>                |                     |
</span></span><span style="display:flex;"><span>                |                     |
</span></span><span style="display:flex;"><span>                |     Application     |
</span></span><span style="display:flex;"><span>                |                     |
</span></span><span style="display:flex;"><span>                |                     |
</span></span><span style="display:flex;"><span>        0x30000 +---------------------+
</span></span></code></pre></div><p>We can transcribe that memory into a linker script:</p>
<pre tabindex="0"><code class="language-ld" data-lang="ld">    /* memory_map.ld */
    MEMORY
    {
      bootrom  (rx)  : ORIGIN = 0x00000000, LENGTH = 0x00004000
      approm   (rx)  : ORIGIN = 0x00004000, LENGTH = 0x0003C000
      ram      (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00008000
    }
    
    __bootrom_start__ = ORIGIN(bootrom);
    __bootrom_size__ = LENGTH(bootrom);
    __approm_start__ = ORIGIN(approm);
    __approm_size__ = LENGTH(approm);
</code></pre><p>Since linker scripts are composable, we will be able to <code>include</code> that memory map into the linker scripts we write for our bootloader and our application.</p>
<p>You’ll notice that the linker script above declares some variables. We’ll need those for our bootloader to know where to find the application. To make them accessible in C code, we declare them in a header file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#75715e">/* memory_map.h */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#pragma once
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> __bootrom_start__;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> __bootrom_size__;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> __approm_start__;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> __approm_size__;
</span></span></code></pre></div><h3 id="implementing-the-bootloader-itself">Implementing the bootloader itself<a hidden class="anchor" aria-hidden="true" href="#implementing-the-bootloader-itself">#</a></h3>
<p>Let’s write some bootloader code.
Our bootloader needs to start executing on boot and then jump to our app.</p>
<p>We know how to do the first part from our previous post: we need a valid stack pointer at address <code>0x0</code> , and a valid <code>Reset_Handler</code> function setting up our environment at address <code>0x4</code>. We can reuse our previous startup file and linker script, with one change: we use <code>memory_map.ld</code> rather than define our own <code>MEMORY</code> section.</p>
<p>We also need to put our code in the <code>bootrom</code> region from our memory rather than the <code>rom</code> region in our previous post.</p>
<p>Our linker script therefore looks like this:</p>
<pre><code>/* bootloader.ld */
INCLUDE memory_map.ld

/* Section Definitions */
SECTIONS
{
    .text :
    {
        KEEP(*(.vectors .vectors.*))
        *(.text*)
        *(.rodata*)
        _etext = .;
    } &gt; bootrom
  ...
}
</code></pre>
<p>To jump into our application, we need to know where the <code>Reset_Handler</code> of the app is, and what stack pointer to load. Again, we know from our previous post that those should be the first two 32-bit words in our binary, so we just need to dereference those addresses using the <code>__approm_start__</code> variable from our memory map.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#75715e">/* bootloader.c */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;inttypes.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;memory_map.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>app_code <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>)__approm_start__;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">uint32_t</span> app_sp <span style="color:#f92672">=</span> app_code[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">uint32_t</span> app_start <span style="color:#f92672">=</span> app_code[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">/* TODO: Start app */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">/* Not Reached */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {}
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Next we must load that stack pointer and jump to the code. This will require a bit of assembly code.</p>
<p>ARM MCUs use the <a href="http://www.keil.com/support/man/docs/armasm/armasm_dom1361289882044.htm"><code>msr</code> instruction</a> to load immediate or register data into system registers, in this case the MSP register or “Main Stack Pointer”.</p>
<p>Jumping to an address is done with a branch, in our case with a <a href="http://www.keil.com/support/man/docs/armasm/armasm_dom1361289866466.htm"><code>bx</code> instruction</a>.</p>
<p>We wrap those two into a <code>start_app</code> function which accepts our <code>pc</code> and <code>sp</code> as arguments, and get our minimal bootloader:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#75715e">/* bootloader.c */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;inttypes.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;memory_map.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">start_app</span>(<span style="color:#66d9ef">uint32_t</span> pc, <span style="color:#66d9ef">uint32_t</span> sp) <span style="color:#a6e22e">__attribute__</span>((<span style="color:#66d9ef">naked</span>)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">__asm</span>(<span style="color:#e6db74">&#34;           </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">              msr msp, r1 /* load r1 into MSP */</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">              bx r0       /* branch to the address at r0 */</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>app_code <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>)__approm_start__;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">uint32_t</span> app_sp <span style="color:#f92672">=</span> app_code[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">uint32_t</span> app_start <span style="color:#f92672">=</span> app_code[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">start_app</span>(app_start, app_sp);
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">/* Not Reached */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {}
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><blockquote>
<p>Note: hardware resources initialized in the bootloader must be de-initialized before control is transferred to the app. Otherwise, you risk breaking assumptions the app code is making about the state of the system</p>
</blockquote>
<h3 id="making-our-app-bootloadable">Making our app bootloadable<a hidden class="anchor" aria-hidden="true" href="#making-our-app-bootloadable">#</a></h3>
<p>We must update our app to take advantage of our new memory map. This is again done by updating our linker script to include <code>memory_map.ld</code> and changing our sections to go to the <code>approm</code> region rather than <code>rom</code>.</p>
<pre><code>/* app.ld */
INCLUDE memory_map.ld

/* Section Definitions */
SECTIONS
{
    .text :
    {
        KEEP(*(.vectors .vectors.*))
        *(.text*)
        *(.rodata*)
        _etext = .;
    } &gt; approm
  ...
}
</code></pre>
<p>We also need to update the <a href="https://developer.arm.com/docs/dui0552/latest/the-cortex-m3-processor/exception-model/vector-table"><em>vector table</em></a> used by the microcontroller. The vector table contains the address of every exception and interrupt handler in our system. When an interrupt signal comes in, the ARM core will call the address at the corresponding offset in the vector table.</p>
<p>For example, the offset for the Hard fault handler is <code>0xc</code>, so when a hard fault is hit, the ARM core will jump to the address contained in the table at that offset.</p>
<p>By default, the vector table is at address <code>0x0</code>, which means that when our chip powers up, only the bootloader can handle exceptions or interrupts! Fortunately, ARM provides the <a href="https://developer.arm.com/docs/dui0552/latest/cortex-m3-peripherals/system-control-block/vector-table-offset-register">Vector Table Offset Register</a> to dynamically change the address of the vector table. The register is at address <code>0xE000ED08</code> and has a simple layout:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>    31                                  7              0
</span></span><span style="display:flex;"><span>    +-----------------------------------+--------------+
</span></span><span style="display:flex;"><span>    |                                   |              |
</span></span><span style="display:flex;"><span>    |              TBLOFF               |   Reserved   |
</span></span><span style="display:flex;"><span>    |                                   |              |
</span></span><span style="display:flex;"><span>    +-----------------------------------+--------------+
</span></span></code></pre></div><p>Where <code>TBLOFF</code> is the address of the vector table. In our case, that’s the start of our text section, or <code>_stext</code>. To set it in our app, we add the following to our <code>Reset_Handler</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#75715e">/* startup_samd21.c */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Set the vector table base address */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>vector_table <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>) <span style="color:#f92672">&amp;</span>_stext;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>vtor <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>)<span style="color:#ae81ff">0xE000ED08</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>vtor <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">uint32_t</span>) vector_table <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xFFFFFFF8</span>);
</span></span></code></pre></div><p>One quirk of the ARMv7-m architecture is the alignment requirement for the vector table, as specified in section B1.5.3 of the <a href="https://static.docs.arm.com/ddi0403/eb/DDI0403E_B_armv7m_arm.pdf">reference manual</a>:</p>
<blockquote>
<p>The Vector table must be naturally aligned to a power of two whose alignment value is greater than or equal to (Number of Exceptions supported x 4), with a minimum alignment of 128 bytes.The entry at offset 0 is used to initialize the value for SP_main, see The SP registers on page B1-8. All other entries must have bit [0] set, as the bit is used to define the EPSR T-bit on exception entry (see Reset behavior on page B1-20 and Exception entry behavior on page B1-21 for details).</p>
</blockquote>
<p>Our SAMD21 MCU has 28 interrupts on top of the 16 system reserved exceptions, for a total of 44 entries in the table. Multiply that by 4 and you get 176. The next power of 2 is 256, so our vector table must be 256-byte aligned.</p>
<h3 id="putting-it-all-together">Putting it all together<a hidden class="anchor" aria-hidden="true" href="#putting-it-all-together">#</a></h3>
<p>Because it is hard to witness the bootloader execute, we add a print line to each of our programs:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#75715e">/* boootloader.c */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;inttypes.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;memory_map.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">start_app</span>(<span style="color:#66d9ef">uint32_t</span> pc, <span style="color:#66d9ef">uint32_t</span> sp) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">__asm</span>(<span style="color:#e6db74">&#34;           </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">              msr msp, r1 /* load r1 into MSP */</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">              bx r0       /* branch to the address at r0 */</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">serial_init</span>();
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Bootloader!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">serial_deinit</span>();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>app_code <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>)__approm_start__;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">uint32_t</span> app_sp <span style="color:#f92672">=</span> app_code[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">uint32_t</span> app_start <span style="color:#f92672">=</span> app_code[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">start_app</span>(app_start, app_sp);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// should never be reached
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>and:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#75715e">/* app.c */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">serial_init</span>();
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">set_output</span>(LED_0_PIN);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;App!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">while</span> (true) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">port_pin_toggle_output_level</span>(LED_0_PIN);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">100000</span>; <span style="color:#f92672">++</span>i) {}
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><blockquote>
<p>Note that the bootloader <em>must</em> deinitialize the serial peripheral before starting the app, or you’ll have a hard time trying to initialize it again.</p>
</blockquote>
<p>You can compile both these programs and load the resulting elf files with <code>gdb</code> which will put them at the correct address. However, the more convenient thing to do is to build a single binary which contains both programs.</p>
<p>To do that, you must go through the following steps:</p>
<ol>
<li>Pad the bootloader binary to the full 0x4000 bytes</li>
<li>Create the app binary</li>
<li>Concatenate the two</li>
</ol>
<p>Creating a binary from an elf file is done with <code>objcopy</code> . To accommodate our use case, <code>objcopy</code> has some handy options:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>    $ arm-none-eabi-objcopy --help | grep -C <span style="color:#ae81ff">2</span> pad
</span></span><span style="display:flex;"><span>      -b --byte &lt;num&gt;                  Select byte &lt;num&gt; in every interleaved block
</span></span><span style="display:flex;"><span>         --gap-fill &lt;val&gt;              Fill gaps between sections with &lt;val&gt;
</span></span><span style="display:flex;"><span>         --pad-to &lt;addr&gt;               Pad the last section up to address &lt;addr&gt;
</span></span><span style="display:flex;"><span>         --set-start &lt;addr&gt;            Set the start address to &lt;addr&gt;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">{</span>--change-start|--adjust-start<span style="color:#f92672">}</span> &lt;incr&gt;
</span></span></code></pre></div><p>The <code>—pad-to</code> option will pad the binary up to an address, and <code>—gap-fill</code> will allow you to specify the byte value to fill the gap with. Since we are writing our firmware to flash memory, we should fill with <code>0xFF</code> which is the erase value of flash, and pad to the max address of our bootloader.</p>
<p>We implement those rule in our Makefile, to avoid having to type them out each time:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span>    <span style="color:#75715e"># Makefile</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">$(</span>BUILD_DIR<span style="color:#66d9ef">)</span>/<span style="color:#66d9ef">$(</span>PROJECT<span style="color:#66d9ef">)</span>-app.bin: <span style="color:#66d9ef">$(</span>BUILD_DIR<span style="color:#66d9ef">)</span>/<span style="color:#66d9ef">$(</span>PROJECT<span style="color:#66d9ef">)</span>-app.elf
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">$(</span>OCPY<span style="color:#66d9ef">)</span> $&lt; $@ -O binary
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">$(</span>SZ<span style="color:#66d9ef">)</span> $&lt;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">$(</span>BUILD_DIR<span style="color:#66d9ef">)</span>/<span style="color:#66d9ef">$(</span>PROJECT<span style="color:#66d9ef">)</span>-boot.bin: <span style="color:#66d9ef">$(</span>BUILD_DIR<span style="color:#66d9ef">)</span>/<span style="color:#66d9ef">$(</span>PROJECT<span style="color:#66d9ef">)</span>-boot.elf
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">$(</span>OCPY<span style="color:#66d9ef">)</span> --pad-to<span style="color:#f92672">=</span>0x4000 --gap-fill<span style="color:#f92672">=</span>0xFF -O binary $&lt; $@
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">$(</span>SZ<span style="color:#66d9ef">)</span> $&lt;
</span></span></code></pre></div><p>Last but not least, we need to concatenate our two binaries. As funny as that may sound, this is best achieved with <code>cat</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span>    <span style="color:#75715e"># Makefile</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">$(</span>BUILD_DIR<span style="color:#66d9ef">)</span>/<span style="color:#66d9ef">$(</span>PROJECT<span style="color:#66d9ef">)</span>.bin: <span style="color:#66d9ef">$(</span>BUILD_DIR<span style="color:#66d9ef">)</span>/<span style="color:#66d9ef">$(</span>PROJECT<span style="color:#66d9ef">)</span>-boot.bin <span style="color:#66d9ef">$(</span>BUILD_DIR<span style="color:#66d9ef">)</span>/<span style="color:#66d9ef">$(</span>PROJECT<span style="color:#66d9ef">)</span>-app.bin
</span></span><span style="display:flex;"><span>      cat $^ &gt; $@
</span></span></code></pre></div><h2 id="beyond-the-mvp">Beyond the MVP<a hidden class="anchor" aria-hidden="true" href="#beyond-the-mvp">#</a></h2>
<p>Now, this bootloader isn’t too useful, it only loads our application. We could do just as well without it.</p>
<p>In the following sections, I will go through a few useful things you can do with a bootloader.</p>
<h3 id="message-passing-to-catch-reboot-loops">Message passing to catch reboot loops<a hidden class="anchor" aria-hidden="true" href="#message-passing-to-catch-reboot-loops">#</a></h3>
<p>A common thing to do with a bootloader is monitor stability. This can be done with a relatively simple setup:</p>
<ol>
<li>On boot, the bootloader increments a persistent counter</li>
<li>After the app has been stable for a while (e.g. 1 minute), it resets the counter to 0</li>
<li>If the counter gets to 3, the bootloader does not start the app but instead signals an error.</li>
</ol>
<p>This requires shared, persistent data between the application and the bootloader which is retained across reboots. On some architectures, non volatile registers are available which make this easy. This is the case on all STM32 microcontrollers which have RTC backup registers.</p>
<p>大多数情况下, we can use a region of RAM to get the same result. As long as the system remains powered, the RAM will keep its state even if the device reboots.</p>
<p>First, we carve some RAM for shared data in our memory map:</p>
<pre tabindex="0"><code class="language-ld" data-lang="ld">    /* memory_map.ld */
    MEMORY
    {
      bootrom  (rx)  : ORIGIN = 0x00000000, LENGTH = 0x00004000
      approm   (rx)  : ORIGIN = 0x00004000, LENGTH = 0x0003C000
      shared   (rwx) : ORIGIN = 0x20000000, LENGTH = 0x1000 # new added memory region
      ram      (rwx) : ORIGIN = 0x20001000, LENGTH = 0x00007000
    }
    
    /* shared data starts point at the origin of the shared region */
    _shared_data_start = ORIGIN(shared);
</code></pre><p>We can then create a data structure and assign it to this section, with getters to read it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#75715e">/* shared.h */</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;inttypes.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> <span style="color:#a6e22e">shared_data_get_boot_count</span>(<span style="color:#66d9ef">void</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">shared_data_increment_boot_count</span>(<span style="color:#66d9ef">void</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">shared_data_reset_boot_count</span>(<span style="color:#66d9ef">void</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* shared.c */</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;shared.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">uint32_t</span> _shared_data_start;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#pragma pack (push)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> shared_data {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">uint8_t</span> boot_count;
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#pragma pack (pop)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> shared_data <span style="color:#f92672">*</span>sd <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> shared_data <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>_shared_data_start;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> <span style="color:#a6e22e">shared_data_get_boot_count</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> sd<span style="color:#f92672">-&gt;</span>boot_count;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">shared_data_increment_boot_count</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>      sd<span style="color:#f92672">-&gt;</span>boot_count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">shared_data_reset_boot_count</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>      sd<span style="color:#f92672">-&gt;</span>boot_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>We compile the <code>shared</code> module into both our app and our bootloader, and can read the boot count in both programs.</p>
<h3 id="relocating-our-app-from-flash-to-ram">Relocating our app from flash to RAM<a hidden class="anchor" aria-hidden="true" href="#relocating-our-app-from-flash-to-ram">#</a></h3>
<p>More commonly, bootloaders are used to relocate applications before they are executed. Relocations involves copying the application code from one place to another in order to execute it. This is useful when your application is stored in non-executable memory like a SPI flash.</p>
<p>Consider the following memory map:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#75715e">/* memory_map.ld */</span>
</span></span><span style="display:flex;"><span>    MEMORY
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">bootrom</span>  (rx)  <span style="color:#f92672">:</span> ORIGIN <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00000000</span>, LENGTH <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00010000</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">approm</span>   (rx)  <span style="color:#f92672">:</span> ORIGIN <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00010000</span>, LENGTH <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00004000</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">ram</span>      (rwx) <span style="color:#f92672">:</span> ORIGIN <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x20000000</span>, LENGTH <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00004000</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">eram</span>     (rwx) <span style="color:#f92672">:</span> ORIGIN <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x20004000</span>, LENGTH <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00004000</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    __bootrom_start__ <span style="color:#f92672">=</span> <span style="color:#a6e22e">ORIGIN</span>(bootrom);
</span></span><span style="display:flex;"><span>    __bootrom_size__ <span style="color:#f92672">=</span> <span style="color:#a6e22e">LENGTH</span>(bootrom);
</span></span><span style="display:flex;"><span>    __approm_start__ <span style="color:#f92672">=</span> <span style="color:#a6e22e">ORIGIN</span>(approm);
</span></span><span style="display:flex;"><span>    __approm_size__ <span style="color:#f92672">=</span> <span style="color:#a6e22e">LENGTH</span>(approm);
</span></span><span style="display:flex;"><span>    __eram_start__ <span style="color:#f92672">=</span> <span style="color:#a6e22e">ORIGIN</span>(eram);
</span></span><span style="display:flex;"><span>    __eram_size__ <span style="color:#f92672">=</span> <span style="color:#a6e22e">LENGTH</span>(eram);
</span></span></code></pre></div><p>In this case, <code>approm</code> is our app storage and <code>eram</code> is our executable RAM, where we want to copy our program. Our bootloader needs to copy the code from <code>approm</code> to <code>eram</code> before executing it.</p>
<p>We know from our previous blog post that executable code typically ends up in the <code>.text</code> section so we must tell the linker that this section is <strong>stored</strong> in <code>approm</code> but executed from <code>eram</code> so our program can execute correctly.</p>
<p>This is similar to our <code>.data</code> section, which is stored in <code>rom</code> but lives in <code>ram</code> while the program is running. We use the <code>AT</code> linker command to specify the storage region and the <code>&gt;</code> operator to specify the load region. This is the resulting linker script section:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#75715e">/* app.ld */</span>
</span></span><span style="display:flex;"><span>    SECTIONS {
</span></span><span style="display:flex;"><span>        .text :
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">KEEP</span>(<span style="color:#f92672">*</span>(.vectors .vectors.<span style="color:#f92672">*</span>))
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">*</span>(.text<span style="color:#f92672">*</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">*</span>(.rodata<span style="color:#f92672">*</span>)
</span></span><span style="display:flex;"><span>        } <span style="color:#f92672">&gt;</span> eram AT <span style="color:#f92672">&gt;</span> approm
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>We then update our bootloader to copy our code from one to the other before starting the app:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>      <span style="color:#75715e">/* booloader.c */</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">/* copy app code to eram */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>src <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uint32_t</span><span style="color:#f92672">*</span>) <span style="color:#f92672">&amp;</span>__approm_start__;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>dst <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uint32_t</span><span style="color:#f92672">*</span>) <span style="color:#f92672">&amp;</span>__eram_start__;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>) <span style="color:#f92672">&amp;</span>__approm_size__;
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Copying firmware from %p to %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, src, dst);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">memcpy</span>(dst, src, size);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">/* find app start &amp; SP */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">uint32_t</span> app_sp <span style="color:#f92672">=</span> dst[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">uint32_t</span> app_start <span style="color:#f92672">=</span> dst[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">/* cleanup peripherals here we may have initialized */</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">/* start the app */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">start_app</span>(app_start, app_sp);
</span></span></code></pre></div><h3 id="locking-the-bootloader-with-the-mpu">Locking the bootloader with the MPU<a hidden class="anchor" aria-hidden="true" href="#locking-the-bootloader-with-the-mpu">#</a></h3>
<blockquote>
<p>Memory Protect Unit</p>
</blockquote>
<p>Last but not least, we can protect the bootloader using the memory protection unit to make it inaccessible from the app. This prevents accidentally erasing the bootloader during execution.</p>
<p>If you do not know about the MPU, check out <a href="/blog/fix-bugs-and-secure-firmware-with-the-mpu">Chris’s excellent blog post from a few weeks ago</a>.</p>
<p>Remember that our MPU regions must be power-of-2 sized. Thankfully, our bootloader already is! <code>0x4000</code> is 2^14 bytes.</p>
<p>We add the following MPU code to our bootloader:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#75715e">/* bootloader.c */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">/* ... */</span>
</span></span><span style="display:flex;"><span>      base_addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">*</span>mpu_rbar <span style="color:#f92672">=</span> (base_addr <span style="color:#f92672">|</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//  AP=0b110 to make the region read-only regardless of privilege
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">//  TEXSCB=0b000010 because the Code is in &#34;Flash memory&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">//  SIZE=13 because we want to cover 16kiB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">//  ENABLE=1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#f92672">*</span>mpu_rasr <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>b110 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">24</span>) <span style="color:#f92672">|</span> (<span style="color:#ae81ff">0</span>b000010 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">16</span>) <span style="color:#f92672">|</span> (<span style="color:#ae81ff">13</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">|</span> <span style="color:#ae81ff">0x1</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">start_app</span>(app_start, app_sp);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">/* Not reached */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {}
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h1 id="bootstrapping-libc-with-newlib">Bootstrapping libc with Newlib<a hidden class="anchor" aria-hidden="true" href="#bootstrapping-libc-with-newlib">#</a></h1>
<p>So far, we bootstrapped a C environment, wrote a linker script from scratch, and implemented our own bootloader.</p>
<p>And yet, we cannot even write a hello world program! Consider the following <code>main.c</code> file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Hello, World</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {}
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Compiling this using our Makefile and linker script from <a href="/blog/zero-to-main-1">previous</a> <a href="/blog/how-to-write-linker-scripts-for-firmware">posts</a>, we hit the following error:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>    $ make
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    Linking build/minimal.elf
</span></span><span style="display:flex;"><span>    arm-none-eabi/bin/ld: build/objs/a/b/c/minimal.o: in <span style="color:#66d9ef">function</span> <span style="color:#e6db74">`</span>main<span style="color:#e6db74">&#39;:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    /minimal/minimal.c:4: undefined reference to `printf&#39;</span>
</span></span><span style="display:flex;"><span>    collect2: error: ld returned <span style="color:#ae81ff">1</span> exit status
</span></span><span style="display:flex;"><span>    make: *** <span style="color:#f92672">[</span>build/minimal.elf<span style="color:#f92672">]</span> Error <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>Undefined reference to <code>printf</code>! How could this be?</p>
<p>Our firmware&rsquo;s C environment doesn&rsquo;t contains a working C standard library.
This means that commonly used functions such as <code>printf</code>, <code>memcpy</code>, or <code>strncpy</code> are all out of reach of our program so far.</p>
<p>In firmware-land, nothing comes free with the system: just like we had to explicitly zero out the <code>bss</code> region to initialize some of our static variables, we’ll have to port a <code>printf</code> implementation alongside a C standard library if we want to use it.</p>
<p>In this post, we will</p>
<ol>
<li>add RedHat’s Newlib to our firmware and highlight some of its features.</li>
<li>implement syscalls, learn about constructors, and finally print out “Hello, World”!</li>
<li>also learn how to replace parts or all of the standard C library.</li>
</ol>
<h2 id="setup">Setup<a hidden class="anchor" aria-hidden="true" href="#setup">#</a></h2>
<p>As we did in previous sections, we are using Adafruit’s Metro M0 development board to run our examples. We use a cheap CMSIS-DAP adapter and openOCD to program it.</p>
<p>You can find a step by step guide <a href="/blog/getting-started-with-ibdap-and-atsamd21g18">in our previous post</a>.</p>
<p>As with previous examples, we start with our “minimal” example which you can find <a href="https://github.com/memfault/zero-to-main/tree/master/minimal">on GitHub</a>. I’ve reproduced the source code for <code>main.c</code> below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;samd21g18a.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;port.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#define LED_0_PIN PIN_PA17
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">set_output</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint8_t</span> pin) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">struct</span> port_config config_port_pin;
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">port_get_config_defaults</span>(<span style="color:#f92672">&amp;</span>config_port_pin);
</span></span><span style="display:flex;"><span>      config_port_pin.direction <span style="color:#f92672">=</span> PORT_PIN_DIR_OUTPUT;
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">port_pin_set_config</span>(pin, <span style="color:#f92672">&amp;</span>config_port_pin);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">port_pin_set_output_level</span>(pin, false);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">memcpy</span>(NULL, NULL, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">set_output</span>(LED_0_PIN);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">while</span> (true) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">port_pin_toggle_output_level</span>(LED_0_PIN);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">100000</span>; <span style="color:#f92672">++</span>i) {}
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="implementing-newlib">Implementing Newlib<a hidden class="anchor" aria-hidden="true" href="#implementing-newlib">#</a></h2>
<h3 id="why-newlib">Why Newlib?<a hidden class="anchor" aria-hidden="true" href="#why-newlib">#</a></h3>
<p>There are several implementations of the C Standard Library, starting with the venerable <code>glibc</code> found on most GNU/Linux systems. Alternative implementations include Musl libc<a href="#fn:2">1</a>, Bionic libc<a href="#fn:3">2</a>, ucLibc<a href="#fn:4">3</a>, and dietlibc<a href="#fn:5">4</a>.</p>
<p>Newlib is an implementation of the C Standard Library targeted at bare-metal embedded systems that is maintained by RedHat. It has become the de-facto standard in embedded software because it is complete, has optimizations for a wide range of architectures, and produces relatively small code.</p>
<p>Today Newlib is bundled alongside toolchains and SDK provided by vendors such as ARM (<code>arm-none-eabi-gcc</code>) and Espressif (ESP-IDF for ESP32).</p>
<blockquote>
<p>Note: when code-size constrained, you may choose to use a variant of newlib, called newlib-nano, which does away with some C99 features, and some <code>printf</code> bells and whistles to deliver a more compact standard library. Newlib-nano is enabled with the <code>—specs=nano.specs</code> CFLAG. You can read more about it in our <a href="/blog/code-size-optimization-gcc-flags#c-library">code size blog post</a></p>
</blockquote>
<h3 id="enabling-newlib">Enabling Newlib<a hidden class="anchor" aria-hidden="true" href="#enabling-newlib">#</a></h3>
<p>Newlib is enabled <strong>by default</strong> when you build a project with <code>arm-none-eabi-gcc</code>.
Indeed, you must explicitly opt-out with <code>-nostdlib</code> if you prefer to build your firmware without it.</p>
<p>This is what we do for our “minimal” example, to guarantee we do not include any libc functionality by mistake.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span>    PROJECT :<span style="color:#f92672">=</span> minimal
</span></span><span style="display:flex;"><span>    BUILD_DIR ?<span style="color:#f92672">=</span> build
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    CFLAGS <span style="color:#f92672">+=</span> -nostdlib
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    SRCS <span style="color:#f92672">=</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>     startup_samd21.c <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>     <span style="color:#66d9ef">$(</span>PROJECT<span style="color:#66d9ef">)</span>.c
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    include ../common-standalone.mk
</span></span></code></pre></div><p>It is very easy to add a dependency on the C standard library without meaning to, as GCC will sometimes use standard C functions implicitly. For example, consider this code used to zero-initialize a struct:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">int</span> b[<span style="color:#ae81ff">50</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>}; <span style="color:#75715e">// zero initialize a struct
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">/* ... */</span>
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>We added no new <code>#include</code>, nor any call to C library functions. Yet if we compile this code with <code>-nostdlib</code>, we’ll get the following error:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    Linking build/minimal.elf
</span></span><span style="display:flex;"><span>    /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/bin/ld: build/objs/a/b/c/minimal.o: in <span style="color:#66d9ef">function</span> <span style="color:#e6db74">`</span>main<span style="color:#e6db74">&#39;:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    /minimal/minimal.c:16: undefined reference to `memset&#39;</span>
</span></span><span style="display:flex;"><span>    collect2: error: ld returned <span style="color:#ae81ff">1</span> exit status
</span></span><span style="display:flex;"><span>    make: *** <span style="color:#f92672">[</span>build/minimal.elf<span style="color:#f92672">]</span> Error <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>If we remove <code>-nostdlib</code>, the program compiles and link without problems.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>    Linking build/minimal.elf
</span></span><span style="display:flex;"><span>    arm-none-eabi-objdump -D build/minimal.elf &gt; build/minimal.lst
</span></span><span style="display:flex;"><span>    arm-none-eabi-objcopy build/minimal.elf build/minimal.bin -O binary
</span></span><span style="display:flex;"><span>    arm-none-eabi-size build/minimal.elf
</span></span><span style="display:flex;"><span>       text    data     bss     dec     hex filename
</span></span><span style="display:flex;"><span>       <span style="color:#ae81ff">1292</span>       <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">8192</span>    <span style="color:#ae81ff">9484</span>    250c build/minimal.elf
</span></span></code></pre></div><p>So here we are, using Newlib, and we did not have to do anything. Could it really be this simple?</p>
<blockquote>
<p>Note: the variant of Newlib bundled with <code>arm-none-eabi-gcc</code> is not compiled with <code>-g</code>, which can make debugging difficult. For that reason, you may chose to replace it with your own build of Newlib. You can read more about that process in the <a href="#implementing-our-own-c-standard-library">Implementing our own C standard library section</a> of this article.</p>
</blockquote>
<h2 id="system-calls">System Calls<a hidden class="anchor" aria-hidden="true" href="#system-calls">#</a></h2>
<p>Let’s go back to our “Hello World” example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Hello World!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {}
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Removing <code>-nostdlib</code> is not quite enough. Instead of <code>printf</code> being undefined, we now see a whole mess of undefined symbols:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>    Linking build/minimal.elf
</span></span><span style="display:flex;"><span>    /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/bin/ld: /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/lib/thumb/v6-m/nofp/libg_nano.
</span></span><span style="display:flex;"><span>    a<span style="color:#f92672">(</span>lib_a-sbrkr.o<span style="color:#f92672">)</span>: in <span style="color:#66d9ef">function</span> <span style="color:#e6db74">`</span>_sbrk_r<span style="color:#e6db74">&#39;:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    sbrkr.c:(.text._sbrk_r+0xc): undefined reference to `_sbrk&#39;</span>
</span></span><span style="display:flex;"><span>    /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/bin/ld: /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/lib/thumb/v6-m/nofp/libg_nano.
</span></span><span style="display:flex;"><span>    a<span style="color:#f92672">(</span>lib_a-writer.o<span style="color:#f92672">)</span>: in <span style="color:#66d9ef">function</span> <span style="color:#e6db74">`</span>_write_r<span style="color:#e6db74">&#39;:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    writer.c:(.text._write_r+0x10): undefined reference to `_write&#39;</span>
</span></span><span style="display:flex;"><span>    /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/bin/ld: /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/lib/thumb/v6-m/nofp/libg_nano.
</span></span><span style="display:flex;"><span>    a<span style="color:#f92672">(</span>lib_a-closer.o<span style="color:#f92672">)</span>: in <span style="color:#66d9ef">function</span> <span style="color:#e6db74">`</span>_close_r<span style="color:#e6db74">&#39;:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    closer.c:(.text._close_r+0xc): undefined reference to `_close&#39;</span>
</span></span><span style="display:flex;"><span>    /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/bin/ld: /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/lib/thumb/v6-m/nofp/libg_nano.
</span></span><span style="display:flex;"><span>    a<span style="color:#f92672">(</span>lib_a-lseekr.o<span style="color:#f92672">)</span>: in <span style="color:#66d9ef">function</span> <span style="color:#e6db74">`</span>_lseek_r<span style="color:#e6db74">&#39;:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    lseekr.c:(.text._lseek_r+0x10): undefined reference to `_lseek&#39;</span>
</span></span><span style="display:flex;"><span>    /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/bin/ld: /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/lib/thumb/v6-m/nofp/libg_nano.
</span></span><span style="display:flex;"><span>    a<span style="color:#f92672">(</span>lib_a-readr.o<span style="color:#f92672">)</span>: in <span style="color:#66d9ef">function</span> <span style="color:#e6db74">`</span>_read_r<span style="color:#e6db74">&#39;:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    readr.c:(.text._read_r+0x10): undefined reference to `_read&#39;</span>
</span></span><span style="display:flex;"><span>    /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/bin/ld: /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/lib/thumb/v6-m/nofp/libg_nano.
</span></span><span style="display:flex;"><span>    a<span style="color:#f92672">(</span>lib_a-fstatr.o<span style="color:#f92672">)</span>: in <span style="color:#66d9ef">function</span> <span style="color:#e6db74">`</span>_fstat_r<span style="color:#e6db74">&#39;:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    fstatr.c:(.text._fstat_r+0xe): undefined reference to `_fstat&#39;</span>
</span></span><span style="display:flex;"><span>    /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/bin/ld: /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/lib/thumb/v6-m/nofp/libg_nano.
</span></span><span style="display:flex;"><span>    a<span style="color:#f92672">(</span>lib_a-isattyr.o<span style="color:#f92672">)</span>: in <span style="color:#66d9ef">function</span> <span style="color:#e6db74">`</span>_isatty_r<span style="color:#e6db74">&#39;:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    isattyr.c:(.text._isatty_r+0xc): undefined reference to `_isatty&#39;</span>
</span></span><span style="display:flex;"><span>    collect2: error: ld returned <span style="color:#ae81ff">1</span> exit status
</span></span></code></pre></div><p>Specifically, the compiler is asking for <code>_fstat</code>, <code>_read</code>, <code>_lseek</code>, <code>_close</code>, <code>_write</code>, and <code>_sbrk</code>.</p>
<p>The newlib documentation<a href="#fn:6">5</a> calls these functions “system calls”. In short, they are the handful of things newlib expects the underlying “operating system”. The complete list of them is provided below:</p>
<pre><code>_exit, close, environ, execve, fork, fstat, getpid, isatty, kill,
link, lseek, open, read, sbrk, stat, times, unlink, wait, write
</code></pre>
<p>You’ll notice that several of the syscalls relate to filesystem operation or process control. These do not make much sense in a firmware context, so we’ll often simply provide a stub that returns an error code.</p>
<p>Let’s look at the ones our “Hello, World” example requires.</p>
<h3 id="fstat">fstat<a hidden class="anchor" aria-hidden="true" href="#fstat">#</a></h3>
<p><code>fstat</code> returns the status of an open file. The minimal version of this should identify all files as character special devices. This forces one-byte-read at a time.</p>
<pre><code>#include &lt;sys/stat.h&gt;
int fstat(int file, struct stat *st) {
  st-&gt;st_mode = S_IFCHR;
  return 0;
}
</code></pre>
<h3 id="lseek">lseek<a hidden class="anchor" aria-hidden="true" href="#lseek">#</a></h3>
<p><code>lseek</code> repositions the file offset of the open file associated with the file descriptor <code>fd</code> to the argument <code>offset</code> according to the directive <code>whence</code>.</p>
<p>Here we can simply return 0, which implies the file is empty.</p>
<pre><code>int lseek(int file, int offset, int whence) {
  return 0;
}
</code></pre>
<h3 id="close">close<a hidden class="anchor" aria-hidden="true" href="#close">#</a></h3>
<p><code>close</code> closes a file descriptor <code>fd</code>.</p>
<p>Since no file should have gotten <code>open</code>-ed, we can just return an error on close:</p>
<pre><code>int close(int fd) {
  return -1;
}
</code></pre>
<h3 id="write">write<a hidden class="anchor" aria-hidden="true" href="#write">#</a></h3>
<p>This is where things get interesting! <code>write</code> writes up to <code>count</code> bytes from the buffer starting at <code>buf</code> to the file referred to by the file descriptor <code>fd</code>.</p>
<p>Functions like <code>printf</code> rely on <code>write</code> to write bytes to <code>STDOUT</code>. In our case, we will want those bytes to be written to serial instead.</p>
<p>On the SAMD21 chip we are using, writing bytes to serial is done using the <code>usart_serial_putchar</code> function. We can use it to implement <code>write</code>:</p>
<pre><code>static struct usart_module stdio_uart_module;

int _write (int fd, char *buf, int count) {
  int written = 0;

  for (; count != 0; --count) {
    if (usart_serial_putchar(&amp;stdio_uart_module, (uint8_t)*buf++)) {
      return -1;
    }
    ++written;
  }
  return written;
}
</code></pre>
<p>We’ll also need to initialize the USART peripheral prior to calling printf:</p>
<pre><code>static void serial_init(void) {
  struct usart_config usart_conf;

  usart_get_config_defaults(&amp;usart_conf);
  usart_conf.mux_setting = USART_RX_3_TX_2_XCK_3;
  usart_conf.pinmux_pad0 = PINMUX_UNUSED;
  usart_conf.pinmux_pad1 = PINMUX_UNUSED;
  usart_conf.pinmux_pad2 = PINMUX_PB22D_SERCOM5_PAD2;
  usart_conf.pinmux_pad3 = PINMUX_PB23D_SERCOM5_PAD3;

  usart_serial_init(&amp;stdio_uart_module, SERCOM5, &amp;usart_conf);
  usart_enable(&amp;stdio_uart_module);
}

int main() {
  serial_init();

  printf(&quot;Hello, World!\n&quot;);
  while (1) {}
}
</code></pre>
<h3 id="read">read<a hidden class="anchor" aria-hidden="true" href="#read">#</a></h3>
<p><code>read</code> attempts to read up to <code>count</code> bytes from file descriptor <code>fd</code> into the buffer at <code>buf</code>.</p>
<p>Similarly to <code>write</code>, we want <code>read</code> to read bytes from serial:</p>
<pre><code>int _read (int fd, char *buf, int count) {
  int read = 0;

  for (; count &gt; 0; --count) {
    usart_serial_getchar(&amp;stdio_uart_module, (uint8_t *)buf++);
    read++;
  }

  return read;
}
</code></pre>
<h3 id="sbrk">sbrk<a hidden class="anchor" aria-hidden="true" href="#sbrk">#</a></h3>
<p><code>sbrk</code> increases the program’s data space by <code>increment</code> bytes. In other words, it increases the size of the heap.</p>
<p>What does <code>printf</code> have to do with the heap, you will justly ask? It turns out that newlib’s <code>printf</code> implementations allocates data on the heap and depends on a working <code>malloc</code> implementation.</p>
<p>The source for <code>printf</code> is hard to follow, but you will find that indeed <a href="https://github.com/bminor/newlib/blob/6497fdfaf41d47e835fdefc78ecb0a934875d7cf/newlib/libc/stdio/vfprintf.c#L226">it calls malloc</a>!</p>
<p>Here’s a simple implementation of <code>sbrk</code>:</p>
<pre><code>void *_sbrk(int incr) {
  static unsigned char *heap = HEAP_START;
  unsigned char *prev_heap = heap;
  heap += incr;
  return prev_heap;
}
</code></pre>
<p>More often than not, we want the heap to use all the RAM not used by anything else. We therefore set <code>HEAP_START</code> to the first address not spoken for in our linker script. In our <a href="/blog/how-to-write-linker-scripts-for-firmware#complete-linker-script">previous post</a>, we had added the <code>_end</code> variable in our linker script to that end.</p>
<p>We replace <code>HEAP_START</code> with <code>_end</code> and get:</p>
<pre><code>void *_sbrk(int incr) {
  static unsigned char *heap = NULL;
  unsigned char *prev_heap;

  if (heap == NULL) {
    heap = (unsigned char *)&amp;_end;
  }
  prev_heap = heap;

  heap += incr;

  return prev_heap;
}
</code></pre>
<p>Putting it all together, we get the following <code>main.c</code> file:</p>
<pre><code>static struct usart_module stdio_uart_module;

// LIBC SYSCALLS
/////////////////////

extern int _end;

void *_sbrk(int incr) {
  static unsigned char *heap = NULL;
  unsigned char *prev_heap;

  if (heap == NULL) {
    heap = (unsigned char *)&amp;_end;
  }
  prev_heap = heap;

  heap += incr;

  return prev_heap;
}

int _close(int file) {
  return -1;
}

int _fstat(int file, struct stat *st) {
  st-&gt;st_mode = S_IFCHR;

  return 0;
}

int _isatty(int file) {
  return 1;
}

int _lseek(int file, int ptr, int dir) {
  return 0;
}

void _exit(int status) {
  __asm(&quot;BKPT #0&quot;);
}

void _kill(int pid, int sig) {
  return;
}

int _getpid(void) {
  return -1;
}

int _write (int file, char * ptr, int len) {
  int written = 0;

  if ((file != 1) &amp;&amp; (file != 2) &amp;&amp; (file != 3)) {
    return -1;
  }

  for (; len != 0; --len) {
    if (usart_serial_putchar(&amp;stdio_uart_module, (uint8_t)*ptr++)) {
      return -1;
    }
    ++written;
  }
  return written;
}

int _read (int file, char * ptr, int len) {
  int read = 0;

  if (file != 0) {
    return -1;
  }

  for (; len &gt; 0; --len) {
    usart_serial_getchar(&amp;stdio_uart_module, (uint8_t *)ptr++);
    read++;
  }
  return read;
}


// APP
////////////////////

static void __attribute__((constructor)) serial_init(void) {
  struct usart_config usart_conf;

  usart_get_config_defaults(&amp;usart_conf);
  usart_conf.mux_setting = USART_RX_3_TX_2_XCK_3;
  usart_conf.pinmux_pad0 = PINMUX_UNUSED;
  usart_conf.pinmux_pad1 = PINMUX_UNUSED;
  usart_conf.pinmux_pad2 = PINMUX_PB22D_SERCOM5_PAD2;
  usart_conf.pinmux_pad3 = PINMUX_PB23D_SERCOM5_PAD3;

  usart_serial_init(&amp;stdio_uart_module, SERCOM5, &amp;usart_conf);
  usart_enable(&amp;stdio_uart_module);
}

int main() {
  serial_init();
  printf(&quot;Hello, World!\n&quot;);
}
</code></pre>
<p>This compiles fine, and can be run on our MCU. Hello, World!</p>
<h2 id="initializing-state-with-constructors--destructors">Initializing State with Constructors &amp; Destructors<a hidden class="anchor" aria-hidden="true" href="#initializing-state-with-constructors--destructors">#</a></h2>
<p>Although we could perfectly well stop here, we can improve a bit over the above.</p>
<p>In our example, <code>printf</code> depends implicitly on <code>serial_init</code> being called. This isn’t the end of the world, but it goes against the spirit of a standard library function which should be usable anywhere in our program.</p>
<p>Instead, let’s see what we can do so that this works:</p>
<pre><code>int main() {
  printf(&quot;Hello, World\n&quot;);
}
</code></pre>
<p>Can you think of a solution?</p>
<p>If we want <code>printf</code> to work anywhere in our <code>main</code> function, then <code>serial_init</code> must be run <strong>before</strong> main. What runs before main? We know from our previous post that it is the <code>Reset_Handler</code>. A simple solution might therefore be:</p>
<pre><code>void Reset_Handler(void)
{
  /* ... */
  /* Hardware Initialization */
  serial_init();

  /* Branch to main function */
  main();

  /* Infinite loop */
  while (1);
}
</code></pre>
<p>The GNU compiler collection and Newlib offer an alternative solution: constructors.</p>
<p>Constructors are functions which should be run before <code>main</code>. Conceptually, they are similar to the constructors of statically allocated C++ objects.</p>
<p>A function is marked as a constructor using the attribute syntax: <code>__attribute__((constructor))</code>. We can thus update <code>serial_init</code>:</p>
<pre><code>static void __attribute__((constructor)) serial_init(void) {
  struct usart_config usart_conf;

  usart_get_config_defaults(&amp;usart_conf);
  usart_conf.mux_setting = USART_RX_3_TX_2_XCK_3;
  usart_conf.pinmux_pad0 = PINMUX_UNUSED;
  usart_conf.pinmux_pad1 = PINMUX_UNUSED;
  usart_conf.pinmux_pad2 = PINMUX_PB22D_SERCOM5_PAD2;
  usart_conf.pinmux_pad3 = PINMUX_PB23D_SERCOM5_PAD3;

  usart_serial_init(&amp;stdio_uart_module, SERCOM5, &amp;usart_conf);
  usart_enable(&amp;stdio_uart_module);
}
</code></pre>
<p>But how do these constructors get invoked? We know that in firmware, we do not get anything for free. This is where newlib comes in.</p>
<p>By default, GCC will put every constructor into an array in their own section of flash. Newlib then offers a function, <code>__libc_init_array</code> which iterates over the array and invokes every constructor. You can find out more about it by reading <a href="https://github.com/bminor/newlib/blob/master/newlib/libc/misc/init.c">the source code</a>.</p>
<p>All we need to do is call <code>__libc_init_array</code> prior to <code>main</code> in our <code>Reset_Handler</code>, and we are good to go.</p>
<pre><code>void Reset_Handler(void)
{
  /* ... */
  /* Run constructors / initializers */
  __libc_init_array();

  /* Branch to main function */
  main();

  /* Infinite loop */
  while (1);
}
</code></pre>
<h2 id="newlib-and-multi-threading">Newlib and Multi-threading<a hidden class="anchor" aria-hidden="true" href="#newlib-and-multi-threading">#</a></h2>
<p>We have not yet talked much about multi-threading (e.g. with an RTOS) in this series, and going into details is outside of the scope of this article. However, there are a few things worth knowing when using Newlib in a multi-threaded environment.</p>
<h3 id="_impure_ptr-and-the-_reent-struct"><code>_impure_ptr</code> and the <code>_reent</code> struct<a hidden class="anchor" aria-hidden="true" href="#_impure_ptr-and-the-_reent-struct">#</a></h3>
<p>Most Newlib functions are <em>reentrant</em>. This means that they can be called by multiple processes safely.</p>
<p>For the functions that cannot be easily made re-entrant, newlib depends on the operating system correctly setting the <code>_impure_ptr</code> variable whenever a context switch occur. That variable is expected to hold a <code>struct _reent</code> for the current thread. That struct is used to store state for standard library functions being used by that thread.</p>
<h3 id="locking-shared-memory">Locking shared memory<a hidden class="anchor" aria-hidden="true" href="#locking-shared-memory">#</a></h3>
<p>Some standard library functions depend on global memory which would not make sense to hold in the <code>_reent</code> struct. This is especially important when using <code>malloc</code> to allocate memory out of the heap. If mutliple threads try modifying the heap at the same time, they risk corrupting it.</p>
<p>To allow multiple threads to call <code>malloc</code>, Newlib provides the <code>__malloc_lock</code> and <code>__malloc_unlock</code> APIs<a href="#fn:1">6</a>. A good implementation of these APIs would lock and unlock a recursive mutex.</p>
<h2 id="implementing-our-own-c-standard-library">Implementing our own C standard library<a hidden class="anchor" aria-hidden="true" href="#implementing-our-own-c-standard-library">#</a></h2>
<p>In some cases, you may want to take different tradeoffs than the ones taken by the implementers of Newlib. Perhaps you are willing to sacrifice some functionality for code space, or are willing to trade performance for security. In most cases it is easier to replace a few functions, though you may end up with a fully custom C library.</p>
<h3 id="replacing-a-function">Replacing a function<a hidden class="anchor" aria-hidden="true" href="#replacing-a-function">#</a></h3>
<p>Because Newlib is a static library with a separate object file for every function, all you need to do to replace a function is define it in your program. The linker won’t go looking for it in static libraries if it finds it in your code.</p>
<p>For example, we may want to replace Newlib’s <code>printf</code> implementation, either because it is too large or because it depends on dynamic memory management. Using Marco Paland’s excellent alternative<a href="#fn:7">7</a> is as simple as a Makefile change.</p>
<p>We first clone it in our firmware’s folder under <code>lib/printf</code>, and update our Makefile to reflect the change:</p>
<pre><code>PROJECT := with-libc
BUILD_DIR ?= build

INCLUDES = \
  ... \
  lib/printf

SRCS = \
  ... \
  lib/printf/printf.c \
 startup_samd21.c \
 $(PROJECT).c

include ../common-standalone.mk
</code></pre>
<h3 id="full-replacement">Full replacement<a hidden class="anchor" aria-hidden="true" href="#full-replacement">#</a></h3>
<p>In some cases, you may want to do away with Newlib altogether. Perhaps you don’t want any dynamic memory allocation, in which case you could use Embedded Artistry’s solid alternative<a href="#fn:8">8</a>. Another good reason to replace the version of Newlib provided by your toolchain is to use your own build of it because you would like to use different compile-time flags.</p>
<p>Once we have copied the static lib (<code>.a</code>) for our selected libc, we disable Newlib with <code>-nostdlib</code> and explicitly link in our substitute library. You can find the resulting Makefile below:</p>
<pre><code>PROJECT := with-libc
BUILD_DIR ?= build

CFLAGS += -nostdlib
LDFLAGS += -L../lib/embeddedartistry_libc -lc

INCLUDES = \
 $(ASF_PATH)/sam0/drivers/sercom \
 $(ASF_PATH)/sam0/drivers/sercom/usart \
 $(ASF_PATH)/common/services/serial \
 $(ASF_PATH)/common/services/serial/sam0_usart

SRCS = \
 $(ASF_PATH)/sam0/drivers/sercom/usart/usart.c \
 $(ASF_PATH)/sam0/drivers/sercom/sercom.c \
 startup_samd21.c \
 $(PROJECT).c

include ../common-standalone.mk
</code></pre>
<blockquote>
<p>Note that the <code>__libc_init_array</code> functionality is not found in every standard C library. You will either need to avoid using it, or bring in Newlib’s implementation.</p>
</blockquote>
<h2 id="reference-links">Reference Links<a hidden class="anchor" aria-hidden="true" href="#reference-links">#</a></h2>
<ol>
<li>
<p><a href="https://www.musl-libc.org/">musl libc</a> <a href="#fnref:2">↩</a></p>
</li>
<li>
<p><a href="https://android.googlesource.com/platform/bionic/">bionic libc</a> <a href="#fnref:3">↩</a></p>
</li>
<li>
<p><a href="https://www.uclibc.org/">ucLibc</a> <a href="#fnref:4">↩</a></p>
</li>
<li>
<p><a href="https://www.fefe.de/dietlibc/">dietlibc</a> <a href="#fnref:5">↩</a></p>
</li>
<li>
<p><a href="https://sourceware.org/newlib/libc.html#Syscalls">newlib documentation</a> <a href="#fnref:6">↩</a></p>
</li>
<li>
<p><a href="https://sourceware.org/newlib/libc.html#g_t_005f_005fmalloc_005flock">__malloc_lock documentation</a> <a href="#fnref:1">↩</a></p>
</li>
<li>
<p><a href="https://github.com/mpaland/printf">Marco Paland’s printf</a> <a href="#fnref:7">↩</a></p>
</li>
<li>
<p><a href="https://github.com/embeddedartistry/libc">Embedded Artistry’s libc</a> <a href="#fnref:8">↩</a></p>
</li>
</ol>
<h1 id="bare-metal-rust">Bare metal Rust<a hidden class="anchor" aria-hidden="true" href="#bare-metal-rust">#</a></h1>
<p>For the past thirty years or so, the choice of languages for embedded systems developers has been relatively slim.
Languages like C++ and Ada have found a home in some niche areas, such as telecommunications and safety critical fields, while higher level languages like Lua, Python, and JavaScript have found a home for scripting and prototyping.</p>
<p>Despite these options, most developers working on bare metal systems have been using the same two languages as long as I can remember: Assembly and C.</p>
<p>But not for no reason! Languages often make trade-offs to fit the needs of the developers working with them: an interpreter to allow for rapid iteration, a heap for ease of memory management, exceptions for simplifying control flow, etc. These trade-offs usually come with a price: whether it is code size, RAM usage, low level control, power usage, latency, or determinism.</p>
<p>Since 2015, Rust has been redefining what it means to combine the best-in-class aspects of performance, correctness, and developer convenience into one language, without compromise. In this post, we’ll bootstrap a Rust environment on a Cortex-M microcontroller from scratch, and explain a few of the language concepts you might not have seen before.</p>
<p>As a compiled systems language (based on LLVM), it is also capable of reaching down to the lowest levels of embedded programming as well, without losing built-in features that feel more at home in higher level languages, like a package manager, helpful compile time diagnostics, correctness through powerful static analysis, or documentation tooling.</p>
<p>This post is meant as a complement to the original <a href="/blog/zero-to-main-1">Zero to main()</a> post on the Interrupt blog, and will elide some of the explanations of hardware level concepts. If you’re new to embedded development, or haven’t seen that post, go read it now!</p>
<h2 id="setting-the-stage-1">Setting the stage<a hidden class="anchor" aria-hidden="true" href="#setting-the-stage-1">#</a></h2>
<p>Most of the concepts and code presented in this series should work for all Cortex-M series MCUs, though these examples target the nRF52 processor by Nordic. This is a Cortex-M4F chip found on several affordable development boards.</p>
<p>Specifically, we are using:</p>
<ul>
<li>Decawave’s <a href="https://www.decawave.com/product/dwm1001-development-board/">DWM1001-DEV</a> as our development board</li>
<li>The built-in JLink capabilities of the board</li>
<li>Segger’s JLinkGDBServer for programming</li>
</ul>
<p>Software wise, we will be using:</p>
<ul>
<li>The 1.39.0 version of Rust, though any stable version 1.31.0 or newer should work</li>
<li>We’ll also use some of the <code>arm-none-eabi</code> binutils, such as <code>arm-none-eabi-gdb</code> and <code>arm-none-eabi-objdump</code>, which are compatible with the binaries produced by Rust</li>
</ul>
<p>We’ll also be implementing a simple blinking LED application. The full Rust source used for this blog post is available <a href="https://github.com/ferrous-systems/zero-to-main/blob/master/from-scratch/src/main.rs">here, on GitHub</a>. This is what the source code looks like for our application:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>    <span style="color:#75715e">#![no_std]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#![no_main]</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">use</span> nrf52::gpio::{Level, Pins};
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; <span style="color:#f92672">!</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> gpios <span style="color:#f92672">=</span> Pins::take();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> led <span style="color:#f92672">=</span> gpios.p0_31;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>        led.set_push_pull_output(Level::Low);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>            led.set_high();
</span></span><span style="display:flex;"><span>            delay(<span style="color:#ae81ff">2_000_000</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>            led.set_low();
</span></span><span style="display:flex;"><span>            delay(<span style="color:#ae81ff">6_000_000</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="power-on-1">Power on<a hidden class="anchor" aria-hidden="true" href="#power-on-1">#</a></h2>
<p>Let’s build our Rust application, and see what the binary contains:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>    cargo build --release
</span></span><span style="display:flex;"><span>       Compiling from-scratch v0.1.0 <span style="color:#f92672">(</span>/home/james/memfault/blog-1/examples/from-scratch<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        Finished release <span style="color:#f92672">[</span>optimized<span style="color:#f92672">]</span> target<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span> in 0.62s
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    arm-none-eabi-objcopy -O binary target/thumbv7em-none-eabihf/release/from-scratch  target/thumbv7em-none-eabihf/release/from-scratch.bin
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    xxd target/thumbv7em-none-eabihf/release/from-scratch.bin | head -n <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>    00000000: <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0120</span> dd00 <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span>  ... ............
</span></span><span style="display:flex;"><span>    00000010: <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span>  ................
</span></span><span style="display:flex;"><span>    00000020: <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span>  ................
</span></span><span style="display:flex;"><span>    00000030: <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span>  ................
</span></span><span style="display:flex;"><span>    00000040: <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0000</span>  ................
</span></span></code></pre></div><p>Reading this, our initial stack pointer is <code>0x20010000</code>, and our start address pointer is <code>0x000000dd</code>. Let’s see what symbol is there. We will also pass <code>-C</code> to objdump, which will demangle our symbols (we’ll explain demangling a bit more later):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>    arm-none-eabi-objdump -Ct target/thumbv7em-none-eabihf/release/from-scratch | sort
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">00000004</span> g     O .vector_table  <span style="color:#ae81ff">00000004</span> __RESET_VECTOR
</span></span><span style="display:flex;"><span>    000000dc g       .vector_table  <span style="color:#ae81ff">00000000</span> _stext
</span></span><span style="display:flex;"><span>    000000dc l     F .text  0000005c from_scratch::reset_handler
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">00000138</span> l     F .text  0000006a from_scratch::main
</span></span><span style="display:flex;"><span>    000001a4 g       *ABS*  <span style="color:#ae81ff">00000000</span> __sidata
</span></span><span style="display:flex;"><span>    ...
</span></span></code></pre></div><p>Same as in the original post, our compiler has set the lowest bit of our reset handler to one to indicate a thumb2 function, so <code>from_scratch::reset_handler</code> is what we’re looking for.</p>
<h2 id="writing-a-reset_handler">Writing a Reset_Handler<a hidden class="anchor" aria-hidden="true" href="#writing-a-reset_handler">#</a></h2>
<p>The Cortex-M processor on our board doesn’t actually know the difference between C and Rust, so our responsibilities for starting the firmware are the same when we build a Rust program, we need to:</p>
<ol>
<li>Provide an entry point, stored in the second word of flash</li>
<li>Zero-initialize the <code>.bss</code> section</li>
<li>Set items with static storage duration to their initial values. In Rust the destination (in RAM) is referred to as <code>.data</code>, and the source values (in Flash) is referred to as <code>.rodata</code></li>
</ol>
<p>Let’s go through the code required to write this reset handler, one chunk at a time.</p>
<h3 id="starting-at-the-top">Starting at the top<a hidden class="anchor" aria-hidden="true" href="#starting-at-the-top">#</a></h3>
<p>The first line in many embedded applications and libraries in Rust will look like this:</p>
<pre><code>#![no_std]
</code></pre>
<p>This is called a “global attribute”, and it is stating that this Rust code will not be using the Rust Standard Library. Attributes in Rust are sometimes used similarly to <code>#pragma</code> in C, in that they can change certain behaviors of the compiler.</p>
<p>Rust provides a number of built-in library components, but the two main ones are:</p>
<ol>
<li>The Rust Standard Library</li>
<li>The Rust Core Library</li>
</ol>
<p>While the Standard Library contains a number of useful components, such as data structures, and interfaces for opening files and sockets, it generally requires your target to have these things! For bare metal applications, we can instead forego this library and only use the Rust Core Library, which does not have these requirements.</p>
<p>Rust as a language has a concept of “modules”, which can be used to organize and provide namespaces for your code. Libraries or applications in Rust are called “Crates”, and each has its own namespace. This is why we saw the symbol <code>from_scratch::reset_handler</code> in our linker script: It was referring to the <code>reset_handler</code> function in the <code>from_scratch</code> crate (which is the application crate in this example).</p>
<p>To use items from another crate, including the <a href="https://doc.rust-lang.org/core/index.html"><code>core</code> library</a>, you can import these items in using the <code>use</code> syntax:</p>
<pre><code>use core::{
    mem::zeroed,
    panic::PanicInfo,
    ptr::{read, write_volatile},
};
</code></pre>
<p>This imports the symbols into the current context so that they can be used. Most symbols in Rust are not available in a global namespace, which helps to avoid naming collisions.</p>
<p>However in some cases, it is important to have a globally defined symbol. As part of the ABI of the Cortex-M platform, we need to provide the address of the reset handler in a very specific location. Let’s look at how we do that in Rust:</p>
<h3 id="setting-the-reset-vector">Setting the Reset Vector<a hidden class="anchor" aria-hidden="true" href="#setting-the-reset-vector">#</a></h3>
<pre><code>#[link_section = &quot;.vector_table.reset_vector&quot;]
#[no_mangle]
pub static __RESET_VECTOR: fn() -&gt; ! = reset_handler;
</code></pre>
<p>Let’s unpack that from the bottom up:</p>
<pre><code>pub static __RESET_VECTOR: fn() -&gt; ! = reset_handler;
</code></pre>
<p>This line defines a symbol called <code>__RESET_VECTOR</code> at static scope. The type of this symbol is <code>fn() -&gt; !</code>, which is a pointer to a function that takes no arguments and that never returns, or that “diverges”. The value of this symbol is <code>reset_handler</code>, which is the name of a function in our program. Functions are a first class items in Rust (similar to Python), so we can use the names of functions as a value that represents a function pointer.</p>
<pre><code>#[no_mangle]
</code></pre>
<p>This is another attribute, like our <code>#![no_std]</code>. By starting with <code>#[</code> instead of <code>#![</code>, we can tell this is a local attribute instead of a global attribute, which means it only applies to the next item, instead of the whole module.</p>
<p>The <code>#[no_mangle]</code> attribute tells the compiler <strong>not</strong> to mangle this symbol, so it will show up as <code>__RESET_VECTOR</code>, not <code>from_scratch::__RESET_VECTOR</code>. <a href="https://en.wikipedia.org/wiki/Name_mangling">Name mangling</a> is a technique used by languages like C++ and Rust to emit unique names for things like functions, generic data type parameters, or symbols for data at static scope, no matter where or how often they are used in the resulting binary.</p>
<pre><code>#[link_section = &quot;.vector_table.reset_vector&quot;]
</code></pre>
<p>This is another attribute that is informing the compiler to place this symbol in the <code>.vector_table.reset_vector</code> section of our linker script, which will place it right where we need it. This is similar to gcc’s <code>__attribute__((section(...)))</code>.</p>
<h3 id="the-reset-handler-for-real">The Reset Handler, for real<a hidden class="anchor" aria-hidden="true" href="#the-reset-handler-for-real">#</a></h3>
<p>Now let’s look at our actual reset handler, from top to bottom:</p>
<pre><code>pub fn reset_handler() -&gt; ! {
    extern &quot;C&quot; {
        // These symbols come from `linker.ld`
        static mut __sbss: u32; // Start of .bss section
        static mut __ebss: u32; // End of .bss section
        static mut __sdata: u32; // Start of .data section
        static mut __edata: u32; // End of .data section
        static __sidata: u32; // Start of .rodata section
    }

    // Initialize (Zero) BSS
    unsafe {
        let mut sbss: *mut u32 = &amp;mut __sbss;
        let ebss: *mut u32 = &amp;mut __ebss;

        while sbss &lt; ebss {
            write_volatile(sbss, zeroed());
            sbss = sbss.offset(1);
        }
    }

    // Initialize Data
    unsafe {
        let mut sdata: *mut u32 = &amp;mut __sdata;
        let edata: *mut u32 = &amp;mut __edata;
        let mut sidata: *const u32 = &amp;__sidata;

        while sdata &lt; edata {
            write_volatile(sdata, read(sidata));
            sdata = sdata.offset(1);
            sidata = sidata.offset(1);
        }
    }

    // Call user's main function
    main()
}
</code></pre>
<p>Phew! That was a lot at once, especially if you aren’t familiar with Rust! Let’s break that down one chunk at a time to explain the concepts in a little more detail:</p>
<h3 id="defining-a-function-in-rust">Defining a function in Rust<a hidden class="anchor" aria-hidden="true" href="#defining-a-function-in-rust">#</a></h3>
<pre><code>pub fn reset_handler() -&gt; ! {
</code></pre>
<p>This defines a function that is public, named <code>reset_handler</code>, that takes no arguments <code>()</code>, and that never returns <code>-&gt; !</code>.</p>
<p>In Rust, functions normally either don’t return a value like this:</p>
<pre><code>/// Returns nothing
fn foo() { /* ... */ }
</code></pre>
<p>Or do return a value like this:</p>
<pre><code>/// Returns a 32-bit unsigned integer
fn bar() -&gt; u32 { /* ... */ }
</code></pre>
<p>The <code>!</code> type, called the “Never type”, means that this function will never return, or diverges. Since our reset handler never will return (where would it go?) we can tell Rust this, which may allow it to make certain optimizations at compile time.</p>
<h3 id="a-little-help-from-the-linker">A little help from the linker<a hidden class="anchor" aria-hidden="true" href="#a-little-help-from-the-linker">#</a></h3>
<pre><code>extern &quot;C&quot; {
    // These symbols come from `linker.ld`
    static mut __sbss: u32; // Start of .bss section
    static mut __ebss: u32; // End of .bss section
    static mut __sdata: u32; // Start of .data section
    static mut __edata: u32; // End of .data section
    static __sidata: u32; // Start of .rodata section
}
</code></pre>
<p>This section defines a number of static symbols which will be provided by our linker, namely the start and end of the sections that are important for our reset handler to know about. These symbols are defined in an <code>extern &quot;C&quot;</code> scope, which means two things:</p>
<ol>
<li>They will be provided sometime later, by another piece of code, or in this case, the linker itself</li>
<li>They will be defined using the “C” style of ABI and naming conventions, which means they are implicitly <code>#[no_mangle]</code></li>
</ol>
<p>Some of these symbols are also declared as <code>mut</code>, or “mutable”. By default in Rust, all variables are immutable, or read-only. To make a variable mutable in Rust, you must explicitly mark it as <code>mut</code>. This is the opposite of languages like C and C++, where variables are by default mutable, and must be marked with <code>const</code> to prevent them from being modified.</p>
<h3 id="zeroing-the-bss-section">Zeroing the BSS section<a hidden class="anchor" aria-hidden="true" href="#zeroing-the-bss-section">#</a></h3>
<pre><code>// Initialize (Zero) BSS
unsafe {
    let mut sbss: *mut u32 = &amp;mut __sbss;
    let ebss: *mut u32 = &amp;mut __ebss;

    while sbss &lt; ebss {
        write_volatile(sbss, zeroed());
        sbss = sbss.offset(1);
    }
}
</code></pre>
<p>As a language, Rust makes some pretty strong guarantees around memory safety, correctness, and freedom from Undefined Behavior. However, when working directly with the hardware, which has no knowledge of Rust’s guarantees, it is necessary to work in Rust’s <code>unsafe</code> mode, which allows some additional behaviors, but requires the developer to uphold certain correctness guarantees manually.</p>
<p>Rust has two ways of referring to data by reference:</p>
<ol>
<li>References</li>
<li>Raw Pointers</li>
</ol>
<p>In most Rust code, we use references, which can be statically guaranteed for correctness and memory safety. However in this case, we are given the raw integers, which we want to treat as pointers.</p>
<p>In this code, we take a mutable reference to the <code>__sbss</code> and <code>__ebss</code> symbols provided by the linker, and convert these Rust references into raw pointers.</p>
<p>We then use these pointers to make volatile writes of zero across the range, one 32-bit word at a time.</p>
<p>This section zeros our entire <code>.bss</code> section, as defined by the linker.</p>
<h3 id="initializing-static-data">Initializing static data<a hidden class="anchor" aria-hidden="true" href="#initializing-static-data">#</a></h3>
<pre><code>// Initialize Data
unsafe {
    let mut sdata: *mut u32 = &amp;mut __sdata;
    let edata: *mut u32 = &amp;mut __edata;
    let mut sidata: *const u32 = &amp;__sidata;

    while sdata &lt; edata {
        write_volatile(sdata, read(sidata));
        sdata = sdata.offset(1);
        sidata = sidata.offset(1);
    }
}
</code></pre>
<p>This section of code initializes our <code>.data</code> section, copying directly from the <code>.rodata</code> section. This is similar to the code above, however we also walk the pointer in the initializer section as well as the pointer in the destination section.</p>
<h3 id="ready-for-launch">Ready for launch<a hidden class="anchor" aria-hidden="true" href="#ready-for-launch">#</a></h3>
<p>Finally, at the end of our reset handler, we get to call main!</p>
<pre><code>// Call user's main function
main()
</code></pre>
<p>Since the main function we defined above is also divergent (<code>fn main() -&gt; !</code>), we can simply call the function. If we had called a non-divergent function, we would get a compile error here!</p>
<h3 id="something-just-for-rust">Something just for Rust<a hidden class="anchor" aria-hidden="true" href="#something-just-for-rust">#</a></h3>
<p>Rust does have one additional requirement for a bare metal program: You must define the panic handler.</p>
<pre><code>/// This function is called on panic.
#[panic_handler]
fn panic(_info: &amp;PanicInfo) -&gt; ! {
    // On a panic, loop forever
    loop {
        continue;
    }
}
</code></pre>
<p>Rust has a concept of a <code>panic</code>, which is like failing an assert in C. This happens when the program has hit an unrecoverable error case, and must be stopped in some way.</p>
<p>Unlike Exceptions in C++, panics are usually not designed to be recovered from gracefully, and therefore do not require the overhead necessary to unwind.</p>
<p>Still, we must define a “panic handler” in case our program ever panics. For this example, we go into an endless loop, though you could choose to do something different, like logging the error to flash, or soft-rebooting the system immediately.</p>
<h3 id="programming-without-compromise">Programming without Compromise<a hidden class="anchor" aria-hidden="true" href="#programming-without-compromise">#</a></h3>
<p>Earlier I mentioned that Rust brings convenience without compromise. To demonstrate this, let’s take a quick look at the size and total contents of our code once we compile for <code>opt-level = &quot;s&quot;</code>, which is equivalent to <code>-Os</code> in C or C++:</p>
<pre><code>arm-none-eabi-size target/thumbv7em-none-eabihf/release/from-scratch
   text    data     bss     dec     hex filename
    420       0       8     428     1ac target/thumbv7em-none-eabihf/release/from-scratch

arm-none-eabi-nm -nSC target/thumbv7em-none-eabihf/release/from-scratch
00000004 00000004 R __RESET_VECTOR
00000008 R __reset_vector
000000dc R _stext
000000dc 0000005c t from_scratch::reset_handler
00000138 0000006a t from_scratch::main
000001a4 T __erodata
000001a4 T __etext
000001a4 A __sidata
20000000 T __edata
20000000 B __sbss
20000000 T __sdata
20000000 00000004 b from_scratch::delay::DUMMY
20000004 00000001 b from_scratch::nrf52::gpio::Pins::take::TAKEN
20000008 B __ebss
20000008 B __sheap
20010000 A _stack_start
</code></pre>
<p>This is 420 bytes of <code>.text</code>, which boils down to 220 bytes for the vector table, and 198 bytes of actual code.</p>
<h2 id="wrapping-up">Wrapping up<a hidden class="anchor" aria-hidden="true" href="#wrapping-up">#</a></h2>
<p>Although we spent this post talking about how to write support for scratch in Rust, we almost never need to actually do this in practice!</p>
<p>Instead we can leverage Cargo, the package manager and build system for Rust, to use existing libraries that support Cortex-M and Nordic components, a board support crate that handles configuration for our specific development board, and provide a panic handler.</p>
<p>These libraries include an initialization runtime with pre-init hooks, a template linker script that can be modified and extended, access to common Cortex-M components like the NVIC, and more, without having to copy and paste boilerplate reference code into our project.</p>
<p>Now we instead end up with a program that looks like this:</p>
<pre><code>#![no_std]
#![no_main]

// Panic provider crate
use panic_reset as _;

// Provides definitions for our development board
use dwm1001::{
    cortex_m_rt::entry,
    nrf52832_hal::prelude::*,
    DWM1001
};

#[entry]
fn main() -&gt; ! {
    // Set up the board, initializing the LEDs on the board
    let mut board = DWM1001::take().unwrap();

    // Obtain a microsecond precision timer
    let mut timer = board.TIMER0.constrain();

    loop {
        // board.leds.D10 - Bottom LED BLUE
        board.leds.D10.enable();
        timer.delay(2_000_000);

        board.leds.D10.disable();
        timer.delay(6_000_000);
    }
}
</code></pre>
<p>All of the code used in this blog post is available <a href="https://github.com/ferrous-systems/zero-to-main">on GitHub</a>. If you’re looking for information on how to get started with embedded Rust, check out the <a href="https://github.com/rust-embedded/wg">Embedded Working Group</a>’s <a href="https://docs.rust-embedded.org/">bookshelf</a> for documentation on how to install Rust, connect to your device, and build and run your first application.</p>
<p>In future posts we’ll talk about how libraries like <a href="https://docs.rs/r0"><code>r0</code></a>, <a href="https://docs.rs/cortex-m"><code>cortex-m</code></a>, and <a href="https://docs.rs/cortex-m-rt"><code>cortex-m-rt</code></a> provide common functionality when writing embedded programs, and how libraries like <a href="https://docs.rs/nrf52832-pac"><code>nrf52832-pac</code></a>, <a href="https://docs.rs/nrf52832-hal"><code>nrf52832-hal</code></a>, and <a href="https://docs.rs/dwm1001"><code>dwm1001</code></a> provide compile-time safe abstractions over hardware interfaces!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://fanyxok.github.io/tags/cortex-m/">Cortex-M</a></li>
      <li><a href="https://fanyxok.github.io/tags/embedded/">Embedded</a></li>
      <li><a href="https://fanyxok.github.io/tags/bare-matel/">Bare matel</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://fanyxok.github.io/posts/p07-arm-cortex-m-exceptions-and-nvic/">
    <span class="title">Next »</span>
    <br>
    <span>A Practical guide to ARM Cortex-M Exception Handling</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://fanyxok.github.io">福岚溪森</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
