<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Oblivious Transfer and Cyclic Group | 福岚溪森</title>
<meta name="keywords" content="">
<meta name="description" content="Cyclic Group 定义 $$\langle\mathbb{G},q,g \rangle$$
\(\mathbb{G}=\langle \mathbb{Z}_{n}, \cdot \rangle\)
\(\mathbb{Z}_{n} \)是一个集合, {$0$&hellip;$n-1$}.
\(\cdot\)是集合中的运算符.
对\(\mathbb{G}\)中的元素$a$进行$k$次幂运算表示为\(a^{k}=a \cdot a &hellip;\cdot a\), 即$k$个$a$进行$\cdot$运算.
若群$\mathbb{G}$的每一个元素都是$\mathbb{G}$的某一个固定元素$a$的幂，则称$\mathbb{G}$为循环群.
$q$是$\mathbb{G}$的order, $q$的值等于$\mathbb{G}$中元素的个数, 也记为$|\mathbb{G}|$.
$g$是$\mathbb{G}$的generator(生成元), $\mathbb{G}$中的所有元素都能由$g$通过幂运算生成.
由群$\mathbb{G}$, 阶$q$和生成元$g$, 即可定义一个循环群.
如何寻找一个生成元 如果$\mathbb{G}$有素数阶$p$, 则$\mathbb{G}$中除了identity之外的所有元素都是$\mathbb{G}$的生成元.
如果$p$是素数, 则$\mathbb{Z}_{p}^{*}$是阶为$p-1$的循环群.
假设$\mathbb{G}$阶非素数$p$, 可以均匀的从$\mathbb{G}$中采样元素, 直到这个元素是一个生成元.
$\mathbb{G}$的阶$q$有素数因数$\{p_{i}\}^k_{i=1}$, 检查元素$h$是否为生成元
for $i = 1$ to $k$ : if $h^{q/p_{i}}=1$ return &ldquo;$h$ is not a generator&rdquo; return &ldquo;$h$ is a generator&rdquo; $\mathbb{G}$有阶$q$,生成元$g$, 则任意一个元素可以表示为$h=g^{x}$.
当gcd($x,q$)=1时, $h$也是$\mathbb{G}$的一个生成元. Oblivious Transfer from Cyclic Group Reference:
More efficient oblivious transfer and extensions for faster secure computation">
<meta name="author" content="">
<link rel="canonical" href="https://fanyxok.github.io/posts/otandcylicgroup/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8b523f1730c922e314350296d83fd666efa16519ca136320a93df674d00b6325.css" integrity="sha256-i1I/FzDJIuMUNQKW2D/WZu&#43;hZRnKE2MgqT32dNALYyU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://fanyxok.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://fanyxok.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://fanyxok.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://fanyxok.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://fanyxok.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><head>
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>

<script>
  document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
          delimiters: [
              {left: "$$", right: "$$", display: true},
              {left: "$", right: "$", display: false}
          ]
      });
  });
</script>
</head><meta property="og:title" content="Oblivious Transfer and Cyclic Group" />
<meta property="og:description" content="Cyclic Group 定义 $$\langle\mathbb{G},q,g \rangle$$
\(\mathbb{G}=\langle \mathbb{Z}_{n}, \cdot \rangle\)
\(\mathbb{Z}_{n} \)是一个集合, {$0$&hellip;$n-1$}.
\(\cdot\)是集合中的运算符.
对\(\mathbb{G}\)中的元素$a$进行$k$次幂运算表示为\(a^{k}=a \cdot a &hellip;\cdot a\), 即$k$个$a$进行$\cdot$运算.
若群$\mathbb{G}$的每一个元素都是$\mathbb{G}$的某一个固定元素$a$的幂，则称$\mathbb{G}$为循环群.
$q$是$\mathbb{G}$的order, $q$的值等于$\mathbb{G}$中元素的个数, 也记为$|\mathbb{G}|$.
$g$是$\mathbb{G}$的generator(生成元), $\mathbb{G}$中的所有元素都能由$g$通过幂运算生成.
由群$\mathbb{G}$, 阶$q$和生成元$g$, 即可定义一个循环群.
如何寻找一个生成元 如果$\mathbb{G}$有素数阶$p$, 则$\mathbb{G}$中除了identity之外的所有元素都是$\mathbb{G}$的生成元.
如果$p$是素数, 则$\mathbb{Z}_{p}^{*}$是阶为$p-1$的循环群.
假设$\mathbb{G}$阶非素数$p$, 可以均匀的从$\mathbb{G}$中采样元素, 直到这个元素是一个生成元.
$\mathbb{G}$的阶$q$有素数因数$\{p_{i}\}^k_{i=1}$, 检查元素$h$是否为生成元
for $i = 1$ to $k$ : if $h^{q/p_{i}}=1$ return &ldquo;$h$ is not a generator&rdquo; return &ldquo;$h$ is a generator&rdquo; $\mathbb{G}$有阶$q$,生成元$g$, 则任意一个元素可以表示为$h=g^{x}$.
当gcd($x,q$)=1时, $h$也是$\mathbb{G}$的一个生成元. Oblivious Transfer from Cyclic Group Reference:
More efficient oblivious transfer and extensions for faster secure computation" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://fanyxok.github.io/posts/otandcylicgroup/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-19T19:03:35&#43;08:00" />
<meta property="article:modified_time" content="2022-07-19T19:03:35&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Oblivious Transfer and Cyclic Group"/>
<meta name="twitter:description" content="Cyclic Group 定义 $$\langle\mathbb{G},q,g \rangle$$
\(\mathbb{G}=\langle \mathbb{Z}_{n}, \cdot \rangle\)
\(\mathbb{Z}_{n} \)是一个集合, {$0$&hellip;$n-1$}.
\(\cdot\)是集合中的运算符.
对\(\mathbb{G}\)中的元素$a$进行$k$次幂运算表示为\(a^{k}=a \cdot a &hellip;\cdot a\), 即$k$个$a$进行$\cdot$运算.
若群$\mathbb{G}$的每一个元素都是$\mathbb{G}$的某一个固定元素$a$的幂，则称$\mathbb{G}$为循环群.
$q$是$\mathbb{G}$的order, $q$的值等于$\mathbb{G}$中元素的个数, 也记为$|\mathbb{G}|$.
$g$是$\mathbb{G}$的generator(生成元), $\mathbb{G}$中的所有元素都能由$g$通过幂运算生成.
由群$\mathbb{G}$, 阶$q$和生成元$g$, 即可定义一个循环群.
如何寻找一个生成元 如果$\mathbb{G}$有素数阶$p$, 则$\mathbb{G}$中除了identity之外的所有元素都是$\mathbb{G}$的生成元.
如果$p$是素数, 则$\mathbb{Z}_{p}^{*}$是阶为$p-1$的循环群.
假设$\mathbb{G}$阶非素数$p$, 可以均匀的从$\mathbb{G}$中采样元素, 直到这个元素是一个生成元.
$\mathbb{G}$的阶$q$有素数因数$\{p_{i}\}^k_{i=1}$, 检查元素$h$是否为生成元
for $i = 1$ to $k$ : if $h^{q/p_{i}}=1$ return &ldquo;$h$ is not a generator&rdquo; return &ldquo;$h$ is a generator&rdquo; $\mathbb{G}$有阶$q$,生成元$g$, 则任意一个元素可以表示为$h=g^{x}$.
当gcd($x,q$)=1时, $h$也是$\mathbb{G}$的一个生成元. Oblivious Transfer from Cyclic Group Reference:
More efficient oblivious transfer and extensions for faster secure computation"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://fanyxok.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Oblivious Transfer and Cyclic Group",
      "item": "https://fanyxok.github.io/posts/otandcylicgroup/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Oblivious Transfer and Cyclic Group",
  "name": "Oblivious Transfer and Cyclic Group",
  "description": "Cyclic Group 定义 $$\\langle\\mathbb{G},q,g \\rangle$$\n\\(\\mathbb{G}=\\langle \\mathbb{Z}_{n}, \\cdot \\rangle\\)\n\\(\\mathbb{Z}_{n} \\)是一个集合, {$0$\u0026hellip;$n-1$}.\n\\(\\cdot\\)是集合中的运算符.\n对\\(\\mathbb{G}\\)中的元素$a$进行$k$次幂运算表示为\\(a^{k}=a \\cdot a \u0026hellip;\\cdot a\\), 即$k$个$a$进行$\\cdot$运算.\n若群$\\mathbb{G}$的每一个元素都是$\\mathbb{G}$的某一个固定元素$a$的幂，则称$\\mathbb{G}$为循环群.\n$q$是$\\mathbb{G}$的order, $q$的值等于$\\mathbb{G}$中元素的个数, 也记为$|\\mathbb{G}|$.\n$g$是$\\mathbb{G}$的generator(生成元), $\\mathbb{G}$中的所有元素都能由$g$通过幂运算生成.\n由群$\\mathbb{G}$, 阶$q$和生成元$g$, 即可定义一个循环群.\n如何寻找一个生成元 如果$\\mathbb{G}$有素数阶$p$, 则$\\mathbb{G}$中除了identity之外的所有元素都是$\\mathbb{G}$的生成元.\n如果$p$是素数, 则$\\mathbb{Z}_{p}^{*}$是阶为$p-1$的循环群.\n假设$\\mathbb{G}$阶非素数$p$, 可以均匀的从$\\mathbb{G}$中采样元素, 直到这个元素是一个生成元.\n$\\mathbb{G}$的阶$q$有素数因数$\\{p_{i}\\}^k_{i=1}$, 检查元素$h$是否为生成元\nfor $i = 1$ to $k$ : if $h^{q/p_{i}}=1$ return \u0026ldquo;$h$ is not a generator\u0026rdquo; return \u0026ldquo;$h$ is a generator\u0026rdquo; $\\mathbb{G}$有阶$q$,生成元$g$, 则任意一个元素可以表示为$h=g^{x}$.\n当gcd($x,q$)=1时, $h$也是$\\mathbb{G}$的一个生成元. Oblivious Transfer from Cyclic Group Reference:\nMore efficient oblivious transfer and extensions for faster secure computation",
  "keywords": [
    
  ],
  "articleBody": "Cyclic Group 定义 $$\\langle\\mathbb{G},q,g \\rangle$$\n\\(\\mathbb{G}=\\langle \\mathbb{Z}_{n}, \\cdot \\rangle\\)\n\\(\\mathbb{Z}_{n} \\)是一个集合, {$0$…$n-1$}.\n\\(\\cdot\\)是集合中的运算符.\n对\\(\\mathbb{G}\\)中的元素$a$进行$k$次幂运算表示为\\(a^{k}=a \\cdot a …\\cdot a\\), 即$k$个$a$进行$\\cdot$运算.\n若群$\\mathbb{G}$的每一个元素都是$\\mathbb{G}$的某一个固定元素$a$的幂，则称$\\mathbb{G}$为循环群.\n$q$是$\\mathbb{G}$的order, $q$的值等于$\\mathbb{G}$中元素的个数, 也记为$|\\mathbb{G}|$.\n$g$是$\\mathbb{G}$的generator(生成元), $\\mathbb{G}$中的所有元素都能由$g$通过幂运算生成.\n由群$\\mathbb{G}$, 阶$q$和生成元$g$, 即可定义一个循环群.\n如何寻找一个生成元 如果$\\mathbb{G}$有素数阶$p$, 则$\\mathbb{G}$中除了identity之外的所有元素都是$\\mathbb{G}$的生成元.\n如果$p$是素数, 则$\\mathbb{Z}_{p}^{*}$是阶为$p-1$的循环群.\n假设$\\mathbb{G}$阶非素数$p$, 可以均匀的从$\\mathbb{G}$中采样元素, 直到这个元素是一个生成元.\n$\\mathbb{G}$的阶$q$有素数因数$\\{p_{i}\\}^k_{i=1}$, 检查元素$h$是否为生成元\nfor $i = 1$ to $k$ : if $h^{q/p_{i}}=1$ return “$h$ is not a generator” return “$h$ is a generator” $\\mathbb{G}$有阶$q$,生成元$g$, 则任意一个元素可以表示为$h=g^{x}$.\n当gcd($x,q$)=1时, $h$也是$\\mathbb{G}$的一个生成元. Oblivious Transfer from Cyclic Group Reference:\nMore efficient oblivious transfer and extensions for faster secure computation\nAsharov G, Lindell Y, Schneider T, et al.\nProceedings of the 2013 ACM SIGSAC conference on Computer \u0026 communications security.\n以下方案基于DDH假设.\nFast Notes Input Sender and Receiver agree on $\\langle\\mathbb{G},q,g \\rangle$. Sender and Receiver agree on Hash. Sender: n个 ($x_{i}^{0}, x_{i}^{1}$) pair Receiver: n个 bit ($\\sigma_{1},…,\\sigma_{n}$) Receiver do $\\alpha_{i}\\in_{R}\\mathbb{Z}_{q}$ $h_{i}\\in_{R}\\mathbb{G}$ $h_{i}^{0}= (\\sigma_{i} == 0) \\ ?\\ g^{\\alpha_{i}} : h_{i}$ $h_{i}^{1}= (\\sigma_{i} == 0) \\ ?\\ h_{i} : g^{\\alpha_{i}}$ send $n$ pair $(h_{i}^{0}, h_{i}^{1})$ to Sender. Sender do $r\\in_{R}\\mathbb{Z}_{q}$ $u=g^{r}$ $k_{i}^{0}, k_{i}^{1} = (h_{i}^{0})^{r}, (h_{i}^{1})^{r}$ $v_{i}^{0}, v_{i}^{1} = x_{i}^{0} \\oplus \\text{Hash}(k_{i}^{0}), x_{i}^{1} \\oplus \\text{Hash}(k_{i}^{1})$ send $u$ to Receiver. send n pair $(v_{i}^{0}, v_{i}^{1})$. Receiver do $k_{i}^{\\sigma_{i}} = u^{\\alpha_{i}}$ $x_{i}^{\\sigma_{i}} = v_{i}^{\\sigma_{i}} \\oplus \\text{Hash}(k_{i}^{\\sigma_{i}})$ Receiver outputs $\\{x_{i}^{\\sigma_i}\\}$, Sender has no output. Discussion $x$应当和Hash的长度保持一致, 或者小于Hash的长度, 否则$v$的头几位会泄露$x$的信息. 如果Hash的长度与$k$的长度一致, 由于$k$是$\\mathbb{G}$中的元素, $x$也应是$\\mathbb{G}$中的元素, 否则会泄露$x$的信息. 最好的情况是, S和R约定好Hash, 可以从较短的$k$中产生较长的Hash$(k)$, 那么此时也应约定好$x$的bit长度$l$. OT传输的信息长度可能会变, 也可能太长, 如果导致计算的开销过高, 或许可以通过与对称密码结合的方法, 用OT传输秘钥, 用秘钥加密$x$, 从而让Receiver获得秘钥来解密密文. 此时对称加密的秘钥长度就可以固定下来. 不过对称加密如AES本身秘钥的长度就达到了129,192和256, 或许已经超过了$\\mathbb{G}$的长度. MPC中最用的两中有限域是$prime$域和$2k$域$\\mathbb{G}_{p}$和$\\mathbb{G}_{2^k}$, 理论上来说素数域的效率会更高一些, 而2k域正好对应计算时32bit, 64bi的数据范围. ",
  "wordCount" : "223",
  "inLanguage": "en",
  "datePublished": "2022-07-19T19:03:35+08:00",
  "dateModified": "2022-07-19T19:03:35+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://fanyxok.github.io/posts/otandcylicgroup/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "福岚溪森",
    "logo": {
      "@type": "ImageObject",
      "url": "https://fanyxok.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://fanyxok.github.io" accesskey="h" title="福岚溪森 (Alt + H)">福岚溪森</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Oblivious Transfer and Cyclic Group
    </h1>
    <div class="post-meta"><span title='2022-07-19 19:03:35 +0800 CST'>July 19, 2022</span>&nbsp;·&nbsp;2 min

</div>
  </header> 
  <div class="post-content"><h2 id="cyclic-group">Cyclic Group<a hidden class="anchor" aria-hidden="true" href="#cyclic-group">#</a></h2>
<h3 id="定义">定义<a hidden class="anchor" aria-hidden="true" href="#定义">#</a></h3>
<p>$$\langle\mathbb{G},q,g \rangle$$</p>
<p>\(\mathbb{G}=\langle \mathbb{Z}_{n}, \cdot  \rangle\)</p>
<p>\(\mathbb{Z}_{n} \)是一个集合, {$0$&hellip;$n-1$}.</p>
<p>\(\cdot\)是集合中的运算符.</p>
<p>对\(\mathbb{G}\)中的元素$a$进行$k$次幂运算表示为\(a^{k}=a \cdot a &hellip;\cdot a\), 即$k$个$a$进行$\cdot$运算.</p>
<p>若群$\mathbb{G}$的每一个元素都是$\mathbb{G}$的某一个固定元素$a$的幂，则称$\mathbb{G}$为循环群.</p>
<p>$q$是$\mathbb{G}$的order, $q$的值等于$\mathbb{G}$中元素的个数, 也记为$|\mathbb{G}|$.</p>
<p>$g$是$\mathbb{G}$的generator(生成元), $\mathbb{G}$中的所有元素都能由$g$通过幂运算生成.</p>
<p>由群$\mathbb{G}$, 阶$q$和生成元$g$, 即可定义一个循环群.</p>
<h3 id="如何寻找一个生成元">如何寻找一个生成元<a hidden class="anchor" aria-hidden="true" href="#如何寻找一个生成元">#</a></h3>
<p>如果$\mathbb{G}$有素数阶$p$, 则$\mathbb{G}$中除了identity之外的所有元素都是$\mathbb{G}$的生成元.</p>
<p>如果$p$是素数, 则$\mathbb{Z}_{p}^{*}$是阶为$p-1$的循环群.</p>
<p>假设$\mathbb{G}$阶非素数$p$, 可以均匀的从$\mathbb{G}$中采样元素, 直到这个元素是一个生成元.</p>
<ul>
<li>
<p>$\mathbb{G}$的阶$q$有素数因数$\{p_{i}\}^k_{i=1}$, 检查元素$h$是否为生成元</p>
<ul>
<li>for $i = 1$ to $k$ : if $h^{q/p_{i}}=1$ return &ldquo;$h$ is not a generator&rdquo;</li>
<li>return &ldquo;$h$ is a generator&rdquo;</li>
</ul>
</li>
<li>
<p>$\mathbb{G}$有阶$q$,生成元$g$, 则任意一个元素可以表示为$h=g^{x}$.</p>
<ul>
<li>当gcd($x,q$)=1时, $h$也是$\mathbb{G}$的一个生成元.</li>
</ul>
</li>
</ul>
<h2 id="oblivious-transfer-from-cyclic-group">Oblivious Transfer from Cyclic Group<a hidden class="anchor" aria-hidden="true" href="#oblivious-transfer-from-cyclic-group">#</a></h2>
<p>Reference:</p>
<blockquote>
<p>More efficient oblivious transfer and extensions for faster secure computation</p>
<p>Asharov G, Lindell Y, Schneider T, et al.</p>
<p>Proceedings of the 2013 ACM SIGSAC conference on Computer &amp; communications security.</p>
</blockquote>
<p>以下方案基于DDH假设.</p>
<h3 id="fast-notes">Fast Notes<a hidden class="anchor" aria-hidden="true" href="#fast-notes">#</a></h3>
<ol>
<li>Input
<ul>
<li>Sender and Receiver agree on $\langle\mathbb{G},q,g \rangle$.</li>
<li>Sender and Receiver agree on Hash.</li>
<li>Sender: n个 ($x_{i}^{0}, x_{i}^{1}$) pair</li>
<li>Receiver: n个 bit ($\sigma_{1},&hellip;,\sigma_{n}$)</li>
</ul>
</li>
<li>Receiver do
<ul>
<li>$\alpha_{i}\in_{R}\mathbb{Z}_{q}$</li>
<li>$h_{i}\in_{R}\mathbb{G}$</li>
<li>$h_{i}^{0}= (\sigma_{i} == 0) \ ?\ g^{\alpha_{i}} : h_{i}$</li>
<li>$h_{i}^{1}= (\sigma_{i} == 0) \ ?\ h_{i} : g^{\alpha_{i}}$</li>
<li>send $n$ pair $(h_{i}^{0}, h_{i}^{1})$ to Sender.</li>
</ul>
</li>
<li>Sender do
<ul>
<li>$r\in_{R}\mathbb{Z}_{q}$</li>
<li>$u=g^{r}$</li>
<li>$k_{i}^{0}, k_{i}^{1} = (h_{i}^{0})^{r}, (h_{i}^{1})^{r}$</li>
<li>$v_{i}^{0}, v_{i}^{1} = x_{i}^{0} \oplus \text{Hash}(k_{i}^{0}), x_{i}^{1} \oplus \text{Hash}(k_{i}^{1})$</li>
<li>send $u$ to Receiver.</li>
<li>send n pair $(v_{i}^{0}, v_{i}^{1})$.</li>
</ul>
</li>
<li>Receiver do
<ul>
<li>$k_{i}^{\sigma_{i}} = u^{\alpha_{i}}$</li>
<li>$x_{i}^{\sigma_{i}} = v_{i}^{\sigma_{i}} \oplus \text{Hash}(k_{i}^{\sigma_{i}})$</li>
</ul>
</li>
<li>Receiver outputs $\{x_{i}^{\sigma_i}\}$, Sender has no output.</li>
</ol>
<h3 id="discussion">Discussion<a hidden class="anchor" aria-hidden="true" href="#discussion">#</a></h3>
<ol>
<li>$x$应当和Hash的长度保持一致, 或者小于Hash的长度, 否则$v$的头几位会泄露$x$的信息. 如果Hash的长度与$k$的长度一致, 由于$k$是$\mathbb{G}$中的元素, $x$也应是$\mathbb{G}$中的元素, 否则会泄露$x$的信息. 最好的情况是, S和R约定好Hash, 可以从较短的$k$中产生较长的Hash$(k)$, 那么此时也应约定好$x$的bit长度$l$.</li>
<li>OT传输的信息长度可能会变, 也可能太长, 如果导致计算的开销过高, 或许可以通过与对称密码结合的方法, 用OT传输秘钥, 用秘钥加密$x$, 从而让Receiver获得秘钥来解密密文. 此时对称加密的秘钥长度就可以固定下来. 不过对称加密如AES本身秘钥的长度就达到了129,192和256, 或许已经超过了$\mathbb{G}$的长度.</li>
<li>MPC中最用的两中有限域是$prime$域和$2k$域$\mathbb{G}_{p}$和$\mathbb{G}_{2^k}$, 理论上来说素数域的效率会更高一些, 而2k域正好对应计算时32bit, 64bi的数据范围.</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://fanyxok.github.io">福岚溪森</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
