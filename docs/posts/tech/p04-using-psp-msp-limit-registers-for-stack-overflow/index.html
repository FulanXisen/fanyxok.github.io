<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>A Guide to Using ARM Stack Limit Registers | 福岚溪森</title>
<meta name="keywords" content="ARM, Stack Over Flow">
<meta name="description" content="Desc Text.">
<meta name="author" content="Me">
<link rel="canonical" href="https://canonical.url/to/page">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8b523f1730c922e314350296d83fd666efa16519ca136320a93df674d00b6325.css" integrity="sha256-i1I/FzDJIuMUNQKW2D/WZu&#43;hZRnKE2MgqT32dNALYyU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://fanyxok.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://fanyxok.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://fanyxok.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://fanyxok.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://fanyxok.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><head>
    
</head><meta property="og:title" content="A Guide to Using ARM Stack Limit Registers" />
<meta property="og:description" content="Desc Text." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://fanyxok.github.io/posts/tech/p04-using-psp-msp-limit-registers-for-stack-overflow/" />
<meta property="og:image" content="https://fanyxok.github.io/%3Cimage%20path/url%3E" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-03T14:28:46&#43;08:00" />
<meta property="article:modified_time" content="2023-05-03T14:28:46&#43;08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://fanyxok.github.io/%3Cimage%20path/url%3E" />
<meta name="twitter:title" content="A Guide to Using ARM Stack Limit Registers"/>
<meta name="twitter:description" content="Desc Text."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Blog",
      "item": "https://fanyxok.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Tech ",
      "item": "https://fanyxok.github.io/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "A Guide to Using ARM Stack Limit Registers",
      "item": "https://fanyxok.github.io/posts/tech/p04-using-psp-msp-limit-registers-for-stack-overflow/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "A Guide to Using ARM Stack Limit Registers",
  "name": "A Guide to Using ARM Stack Limit Registers",
  "description": "Desc Text.",
  "keywords": [
    "ARM", "Stack Over Flow"
  ],
  "articleBody": "A Guide to Using ARM Stack Limit Registers 14 Feb 2023 by Jon Kurtz\n堆栈溢出一直是开发过程中的一个严重问题。它们经常没有被检测到，并以难以理解的方式出现。我们已经实施了软件机制来保护它们，但这些机制有限，并且仍不能保护所有条件。\n随着ARM架构的成熟，使用一个百分百可靠的机制来检测溢出难道不是更好吗？\n我们将探索在ARM Cortex-M33架构上使用MSP Limit和PSP Limit寄存器来检测堆栈溢出。我们将在Renesas DA1469x上进行实现，并查看检测堆栈溢出的实际示例。此外，我们还将查看MSPLIM和PSPLIM功能不足的情况下的补充选项。\nTable of Contents Basic Terminology How does it work? Implementing the Limit Registers Initializing the MSPLIM Register Initializing the PSPLIM Register Setting up the UsageFault_Handler Testing our Implementation Limitations and Further Improvements Stack Canary FreeRTOS Buffer Overflow protection Compiler Enabled Overflow Detection GCC SSP Example Practical implementations for GCC stack Canaries Closing References Basic Terminology The ARM Cortex-M33 introduced two new stack limit registers, PSPLIM and MSPLIM 1. ARM has included this in its ARMv8 specification, so any processors before this will not have support.\nHow does it work? 这个新特性最妙的地方是它使用起来非常简单，而且可以避免在调试堆栈溢出时进行猜测。\nWe need to set the PSPLIM, and the MSPLIM registers to the boundary of the stack. If the MSP == MSPLIM register or the PSP == PSPLIM register, a UsageFault is generated. The UsageFault Status Register 2 contains a sticky bit in position four to indicate that a stack overflow occurred.\n为PSP和MSP提供硬件保护允许操作系统内的灵活性。例如，我们可以在异常和中断期间保护MSP。我们还可以在上下文切换时切换PSPLIM值，以保护每个Task的堆栈。如果你需要关于上下文切换的复习，可以在这里查看之前的文章。\nIf no RTOS is present, we can still monitor the MSP, as this will protect your whole application.\nImplementing the Limit Registers For an implementation example on the DA1469x, you can access this at Renesas’s Github 3.\nInitializing the MSPLIM Register We use the MSR instruction to write to these registers, which requires us to be in privileged mode. In this case, we will set the MSP Limit in the Reset_Handler:\nReset_Handler: ldr r0, =__StackLimit add r0, r0, #dg_configMSP_PADDING msr MSPLIM, r0 Specifically to the DA1469x, we also need to place the same initialization in the Wakeup_Reset_Handler:\nWakeup_Reset_Handler: ldr r0, =__StackLimit add r0, r0, #dg_configMSP_PADDING msr MSPLIM, r0 DA1469x休眠架构并不适用于所有Cortex-M33架构。初始化后，DA1469x用Wakeup_Reset_Handler替换Reset_Handler来处理Cortex-M33寄存器的恢复。\nThere are two definitions provided elsewhere in the project. __StackLimit is defined in vector_table_da1469x.S:\n.section .stack .align 3 .globl __StackTop .globl __StackLimit __StackLimit: .space Stack_Size .size __StackLimit, . - __StackLimit __StackTop: .size __StackTop, . - __StackTop This definition helps us find the stack limit for setting the MSP.\nWe also added padding to this value. You will find this value in a configuration file:\n#define dg_configMSP_PADDING (16) When the MSPLIM is equal to the MSP, the UsageFault exception is triggered. The padding is required to enable pushing items to the stack on Exception entry. If we don’t make space for the fault handler, nested exceptions can occur as the MSPLIM register would be continuously exceeded, usually resulting in a LOCKUP.\nThe alternative would be to use a naked function4. However, I prefer to add padding as it provides more flexibility in the fault handler and allows for Memfault hooks!\nInitializing the PSPLIM Register On the DA1469x SDK, it makes use of FreeRTOS. The psp is used for each task’s stack so we can set up the PSPLIM register to protect against a task overflow. This implementation is superior to FreeRTOS’s stack overflow check5 for the following reasons:\nFreeRTOS only checks the watermark on a context switch. Therefore, if a thread overflows the stack and isn’t yielding, it can corrupt memory, access null pointers, etc.\nFreeRTOS does not recommend using this feature in production environments because of the context switch overhead6.\nImplementing this is more straightforward. First, we must adjust the PSPLIM during a context switch in FreeRTOS.\nIn tasks.c we create the following above vTaskSwitchContext:\nvoid vTaskSwitchStackGuard(void) { volatile uint32_t end_of_stack_val = (uint32_t)pxCurrentTCB-\u003epxStack; __set_PSPLIM( end_of_stack_val); } Next, we add the call immediately after the context switch:\nvoid xPortPendSVHandler( void ){ ... \" bl vTaskSwitchContext \\n\" \" bl vTaskSwitchStackGuard \\n\" ... } That’s all we need to do for the PSP.\nSetting up the UsageFault_Handler All that’s left is doing some work in the UsageFault_Handler. We will declare the UsageFault_Handler in exceptions_handler.s and call a separate handler afterward.\nFirst, we declare an application handler:\n__RETAINED_CODE void UsageFault_HandlerC(uint8_t stack_pointer_mask) { volatile uint16_t usage_fault_status_reg __UNUSED; usage_fault_status_reg = (SCB-\u003eCFSR \u0026 SCB_CFSR_USGFAULTSR_Msk) \u003e\u003e SCB_CFSR_USGFAULTSR_Pos; hw_watchdog_freeze(); if(usage_fault_status_reg \u0026 (SCB_CFSR_STKOF_Msk \u003e\u003e SCB_CFSR_USGFAULTSR_Pos)) { while(1){} } while (1) {} } Next, let’s add our UsageFault_Handler into the exceptions_handler.S:\n#if (dg_configCODE_LOCATION == NON_VOLATILE_IS_FLASH) .section text_retained #endif .align 2 .thumb .thumb_func .globl UsageFault_Handler .type UsageFault_Handler, %function UsageFault_Handler: ldr r2,=UsageFault_HandlerC mrs r1, msp mrs r0, MSPLIM cmp r0, r1 beq UsageFault_with_MSP_Overflow mrs r1, psp mrs r0, PSPLIM cmp r0, r1 beq UsageFault_with_PSP_Overflow mov r0, #0 bx r2 UsageFault_with_PSP_Overflow: mov r0, #2 bx r2 UsageFault_with_MSP_Overflow: ldr r1, =__StackLimit msr MSPLIM, r1 mov r0, #1 bx r2 Since the USFR does not indicate if the psp or the msp caused the fault, I decided to add some detection in assembly. I prefer doing this in assembly to ensure no stack pushes before the application handler call.\n0 - General UsageFault 1 - MSP Overflow 2 - PSP Overflow (Task Overflow) In this function, we are checking the MSP and the PSP registers against the limit registers. If the MSP matches the MSPLIM register, we restore the MSPLIM to __StackLimit (Removing the padding we placed initially) and then call our application fault handler.\nTesting our Implementation We need a small piece of code to test the implementation. In our example, there is a macro provided for causing an overflow for the MSP or the PSP:\n#define TOGGLE_MSP_OVERFLOW (0) //0 Creates an application overflow in FreeRTOS task, 1 creates it on the MSP When the button is pressed, depending on this macro setting, it calls a recursive function either in interrupt context or in our main task.\nstatic void test_overflow_func(void) { test_overflow_func(); } static void _wkup_key_cb(void) { BaseType_t need_switch; /* Clear the WKUP interrupt flag!!! */ hw_wkup_reset_interrupt(); #if TOGGLE_MSP_OVERFLOW \u003e 0 test_overflow_func(); #endif xTaskNotifyFromISR(overFlow_handle, BUTTON_PRESS_NOTIF, eSetBits, \u0026need_switch); portEND_SWITCHING_ISR(need_switch); } ... void prvTestOverFlowTask( void *pvParameters ) { _wkup_init(); overFlow_handle = xTaskGetCurrentTaskHandle(); for ( ;; ) { uint32_t notif; /* * Wait on any of the notification bits, then clear them all */ xTaskNotifyWait(0, 0xFFFFFFFF, \u0026notif, portMAX_DELAY); /* Notified from BLE manager? */ if (notif \u0026 BUTTON_PRESS_NOTIF) { test_overflow_func(); } } } After pressing the button, we should see the UsageFault_HandlerC get called in our application code.\nLimitations and Further Improvements The MSPLIM and PSPLIM registers will help against most stack overflows. Unfortunately, they do not protect us from local buffers corrupting the stack. We will look at the most common; buffer overflow. A buffer overflow occurs when a fixed buffer is allocated on the stack, and the program starts writing to memory addresses outside this boundary. This results in corrupted data and can even change the return address of a function, causing undesired execution of application code.\nThere are different ways to handle this condition on other architectures. For example, Zephyr uses the MPU to guard the PSP on each thread. Here, we will discuss stack canaries.\nStack Canary Stack Canaries are widely implemented as a means of code hardening. A function will place a value (canary) on the end of a stack frame and will check the value is intact before it returns. This mechanism protects against buffer overflow attacks, where malicious source code could overflow the buffer to redirect the return address to its function.\nThis same idea can also be used to guard against buffer overflows in our application.\nFreeRTOS Buffer Overflow protection FreeRTOS implements a means for overflow detection, as discussed in Initializing the PSPLIM Register. This uses the concept of a canary, which will periodically check the value during a context switch.\nFreeRTOS has two different configurations that follow this concept:\n#if( ( configCHECK_FOR_STACK_OVERFLOW \u003e 1 ) \u0026\u0026 ( portSTACK_GROWTH \u003c 0 ) ) #define taskCHECK_FOR_STACK_OVERFLOW() \\ { \\ const uint32_t * const pulStack = ( uint32_t * ) pxCurrentTCB-\u003epxStack; \\ const uint32_t ulCheckValue = ( uint32_t ) 0xa5a5a5a5; \\ \\ if( ( pulStack[ 0 ] != ulCheckValue ) || \\ ( pulStack[ 1 ] != ulCheckValue ) || \\ ( pulStack[ 2 ] != ulCheckValue ) || \\ ( pulStack[ 3 ] != ulCheckValue ) ) \\ { \\ vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB-\u003epcTaskName ); \\ } \\ } #endif /* #if( configCHECK_FOR_STACK_OVERFLOW \u003e 1 ) */ /*-----------------------------------------------------------*/ #if( ( configCHECK_FOR_STACK_OVERFLOW \u003e 1 ) \u0026\u0026 ( portSTACK_GROWTH \u003e 0 ) ) #define taskCHECK_FOR_STACK_OVERFLOW() \\ { \\ int8_t *pcEndOfStack = ( int8_t * ) pxCurrentTCB-\u003epxEndOfStack; \\ static const uint8_t ucExpectedStackBytes[] = { tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, \\ tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, \\ tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, \\ tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, \\ tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE }; \\ \\ \\ pcEndOfStack -= sizeof( ucExpectedStackBytes ); \\ \\ /* Has the extremity of the task stack ever been written over? */ \\ if( memcmp( ( void * ) pcEndOfStack, ( void * ) ucExpectedStackBytes, sizeof( ucExpectedStackBytes ) ) != 0 ) \\ { \\ vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB-\u003epcTaskName ); \\ } \\ } #endif /* #if( configCHECK_FOR_STACK_OVERFLOW \u003e 1 ) */ Both methods check for an expected value at the end of the stack. If this value is overwritten, then vApplicationStackOverflowHook is called, and the application should record and reset. Unfortunately, the periodicity is non-deterministic, as it relies on a context switch. Periodic checks lead to a race condition when a task doesn’t yield in time. You can test this from the previous example by setting the following:\n#define dg_configARMV8_USE_STACK_GUARDS (0) #define #define TOGGLE_MSP_OVERFLOW (0) In this example, prvTestOverFlowTask will not yield, so FreeRTOS does not catch this condition.\nCompiler Enabled Overflow Detection Compilers have started enabling SSP (Stack Smashing Protection) libraries. The library options will allow the compiler to use canaries within function calls. We’re going to look at GCC’s implementation7 specifically. GCC provides the following compiler flags:\n-fstack-protector: This includes functions that call alloca and functions with buffers larger than or equal to 8 bytes. The guards are initialized when a function is entered and then checked when the function exits.\n-fstack-protector-strong - Like -fstack-protector but includes additional functions to be protected — those that have local array definitions, or have references to local frame addresses.\n-fstack-protector-all: all functions are protected.\n-fstack-protector-explicit: protects those functions which have the stack_protect attribute\nGCC SSP Example Let’s take a look at using the ssp library in GCC. First, let’s add the compiler flag from the previous example: -fstack-protector. The ssp library has two externs that we define as follows.\nuint32_t__stack_chk_guard = 0xDEADBEEF; void __stack_chk_fail(void) { /* will be called if guard/canary gets corrupted */ __ASM volatile (\"cpsid i\" : : : \"memory\"); hw_watchdog_freeze(); // Stop WDOG while(1){} } Let’s also add the vulnerability in our application and add it to the prvTestOverFlowTask:\n__attribute__((optimize(\"O0\"))) static uint8_t stack_buffer_test(uint16_t iters) { uint8_t buffer[16]; uint16_t i; for(i = 0; i \u003c iters; i++) { buffer[i] = 0xaa; } return buffer[8]; } NOTE: __stack_chk_guard should be randomized on startup if using ssp for security reasons.\nThis function has a fixed buffer to pass a value larger than the local buffer. Let’s add a stack_buffer_test(17) to our task and look at the assembly.\n(gdb) disassemble stack_buffer_test Dump of assembler code for function stack_buffer_test: 0x0000ccc8 \u003c+0\u003e: push {r7, lr} 0x0000ccca \u003c+2\u003e: sub sp, #32 0x0000cccc \u003c+4\u003e: add r7, sp, #0 0x0000ccce \u003c+6\u003e: mov r3, r0 0x0000ccd0 \u003c+8\u003e: strh r3, [r7, #6] 0x0000ccd2 \u003c+10\u003e: ldr r3, [pc, #68] ; (0xcd18 ) 0x0000ccd4 \u003c+12\u003e: ldr r3, [r3, #0] 0x0000ccd6 \u003c+14\u003e: str r3, [r7, #28] 0x0000ccd8 \u003c+16\u003e: mov.w r3, #0 0x0000ccdc \u003c+20\u003e: movs r3, #0 0x0000ccde \u003c+22\u003e: strh r3, [r7, #10] 0x0000cce0 \u003c+24\u003e: b.n 0xccf4 0x0000cce2 \u003c+26\u003e: ldrh r3, [r7, #10] 0x0000cce4 \u003c+28\u003e: adds r3, #32 0x0000cce6 \u003c+30\u003e: add r3, r7 0x0000cce8 \u003c+32\u003e: movs r2, #170 ; 0xaa 0x0000ccea \u003c+34\u003e: strb.w r2, [r3, #-20] 0x0000ccee \u003c+38\u003e: ldrh r3, [r7, #10] 0x0000ccf0 \u003c+40\u003e: adds r3, #1 0x0000ccf2 \u003c+42\u003e: strh r3, [r7, #10] 0x0000ccf4 \u003c+44\u003e: ldrh r2, [r7, #10] 0x0000ccf6 \u003c+46\u003e: ldrh r3, [r7, #6] 0x0000ccf8 \u003c+48\u003e: cmp r2, r3 0x0000ccfa \u003c+50\u003e: bcc.n 0xcce2 0x0000ccfc \u003c+52\u003e: ldrb r3, [r7, #20] 0x0000ccfe \u003c+54\u003e: ldr r2, [pc, #24] ; (0xcd18 ) 0x0000cd00 \u003c+56\u003e: ldr r1, [r2, #0] 0x0000cd02 \u003c+58\u003e: ldr r2, [r7, #28] 0x0000cd04 \u003c+60\u003e: eors r1, r2 0x0000cd06 \u003c+62\u003e: mov.w r2, #0 0x0000cd0a \u003c+66\u003e: beq.n 0xcd10 0x0000cd0c \u003c+68\u003e: bl 0xcdb0 \u003c__stack_chk_fail\u003e 0x0000cd10 \u003c+72\u003e: mov r0, r3 0x0000cd12 \u003c+74\u003e: adds r7, #32 0x0000cd14 \u003c+76\u003e: mov sp, r7 0x0000cd16 \u003c+78\u003e: pop {r7, pc} 0x0000cd18 \u003c+80\u003e: strh r4, [r6, #44] ; 0x2c 0x0000cd1a \u003c+82\u003e: movs r0, #0 Here we can see the compiler loading the canary at the end of the stack frame:\n0x0000ccd2 \u003c+10\u003e: ldr r3, [pc, #68] ; (0xcd18 ) 0x0000ccd4 \u003c+12\u003e: ldr r3, [r3, #0] 0x0000ccd6 \u003c+14\u003e: str r3, [r7, #28] (gdb) x /1a 0xcd18 0xcd18 : 0x200085b4 \u003c__stack_chk_guard\u003e (gdb) x /1a 0x200085b4 0x200085b4 \u003c__stack_chk_guard\u003e: 0xdeadbeef Before return, we can see the function checking the canary at the end of the stack frame and calling __stack_chk_fail if the value is corrupted:\n0x0000cd0a \u003c+66\u003e: beq.n 0xcd10 0x0000cd0c \u003c+68\u003e: bl 0xcdb0 \u003c__stack_chk_fail\u003e Running the rest of the example should confirm the call of __stack_chk_fail.\nPractical implementations for GCC stack Canaries Implementing the ssp library does provide additional overhead in execution time and code space. A function will add 7 additional instructions to make use of this feature. The developer should weigh these factors when choosing which setting to use in GCC.\nMy preference would be to develop and test with a stricter setting and more coverage and move to a more relaxed setting when getting closer to production. For example, you could start your development process with -fstack-protector-all, and later relax this to -fstack-protector-strong or -fstack-protector as the code matures.\nClosing The PSPLIM and the MSPLIM registers are great new features from ARM and a much-needed addition to the architecture. These can also be supplemented with other techniques to fortify your application. We hope you found this helpful, and will be inspired to make use of it in your application. Implementing these features should prevent many development headaches and safeguard your application in the field!\nReferences Cortex M33 MSPLIM PSPLIM TRM ↩\nCortex M33 USFR ↩\nDA1469x Github Example ↩\nGCC Attributes ↩\nFreeRTOS Kernel Stack Overflow Check ↩\nFreeRTOS Stack Overflow Check ↩\nGCC Instrumentation Options ↩\nJon Kurtz is an FAE Connectivity manager at Renesas.\n",
  "wordCount" : "2308",
  "inLanguage": "en",
  "image":"https://fanyxok.github.io/%3Cimage%20path/url%3E","datePublished": "2023-05-03T14:28:46+08:00",
  "dateModified": "2023-05-03T14:28:46+08:00",
  "author":{
    "@type": "Person",
    "name": "Me"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://fanyxok.github.io/posts/tech/p04-using-psp-msp-limit-registers-for-stack-overflow/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "福岚溪森",
    "logo": {
      "@type": "ImageObject",
      "url": "https://fanyxok.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://fanyxok.github.io" accesskey="h" title="福岚溪森 (Alt + H)">福岚溪森</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://fanyxok.github.io">Home</a>&nbsp;»&nbsp;<a href="https://fanyxok.github.io/posts/">Blog</a>&nbsp;»&nbsp;<a href="https://fanyxok.github.io/posts/tech/">Tech </a></div>
    <h1 class="post-title">
      A Guide to Using ARM Stack Limit Registers
    </h1>
    <div class="post-description">
      Desc Text.
    </div>
    <div class="post-meta"><span title='2023-05-03 14:28:46 +0800 CST'>May 3, 2023</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2308 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href="https://github.com/%3cpath_to_repo%3e/content/posts/tech/p04-using-psp-msp-limit-registers-for-stack-overflow.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#a-guide-to-using-arm-stack-limit-registersa-guide-to-using-arm-stack-limit-registers">A Guide to Using ARM Stack Limit Registers<a href="#a-guide-to-using-arm-stack-limit-registers"></a></a></li>
        <li><a href="#table-of-contentstable-of-contents">Table of Contents<a href="#table-of-contents"></a></a></li>
        <li><a href="#basic-terminologybasic-terminology">Basic Terminology<a href="#basic-terminology"></a></a></li>
        <li><a href="#how-does-it-workhow-does-it-work">How does it work?<a href="#how-does-it-work"></a></a></li>
        <li><a href="#implementing-the-limit-registersimplementing-the-limit-registers">Implementing the Limit Registers<a href="#implementing-the-limit-registers"></a></a>
          <ul>
            <li><a href="#initializing-the-msplim-registerinitializing-the-msplim-register">Initializing the MSPLIM Register<a href="#initializing-the-msplim-register"></a></a></li>
            <li><a href="#initializing-the-psplim-registerinitializing-the-psplim-register">Initializing the PSPLIM Register<a href="#initializing-the-psplim-register"></a></a></li>
            <li><a href="#setting-up-the-usagefault_handlersetting-up-the-usagefault_handler">Setting up the UsageFault_Handler<a href="#setting-up-the-usagefault_handler"></a></a></li>
            <li><a href="#testing-our-implementationtesting-our-implementation">Testing our Implementation<a href="#testing-our-implementation"></a></a></li>
          </ul>
        </li>
        <li><a href="#limitations-and-further-improvementslimitations-and-further-improvements">Limitations and Further Improvements<a href="#limitations-and-further-improvements"></a></a>
          <ul>
            <li><a href="#stack-canarystack-canary">Stack Canary<a href="#stack-canary"></a></a></li>
            <li><a href="#freertos-buffer-overflow-protectionfreertos-buffer-overflow-protection">FreeRTOS Buffer Overflow protection<a href="#freertos-buffer-overflow-protection"></a></a></li>
            <li><a href="#compiler-enabled-overflow-detectioncompiler-enabled-overflow-detection">Compiler Enabled Overflow Detection<a href="#compiler-enabled-overflow-detection"></a></a></li>
            <li><a href="#gcc-ssp-examplegcc-ssp-example">GCC SSP Example<a href="#gcc-ssp-example"></a></a></li>
          </ul>
        </li>
        <li><a href="#practical-implementations-for-gcc-stack-canariespractical-implementations-for-gcc-stack-canaries">Practical implementations for GCC stack Canaries<a href="#practical-implementations-for-gcc-stack-canaries"></a></a></li>
        <li><a href="#closingclosing">Closing<a href="#closing"></a></a></li>
        <li><a href="#referencesreferences">References<a href="#references"></a></a></li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="a-guide-to-using-arm-stack-limit-registersa-guide-to-using-arm-stack-limit-registers">A Guide to Using ARM Stack Limit Registers<a href="#a-guide-to-using-arm-stack-limit-registers"></a><a hidden class="anchor" aria-hidden="true" href="#a-guide-to-using-arm-stack-limit-registersa-guide-to-using-arm-stack-limit-registers">#</a></h2>
<p>14 Feb 2023 by <a href="/authors/jonkurtz">Jon Kurtz</a></p>
<p>堆栈溢出一直是开发过程中的一个严重问题。它们经常没有被检测到，并以难以理解的方式出现。我们已经实施了软件机制来保护它们，但这些机制有限，并且仍不能保护所有条件。</p>
<p>随着ARM架构的成熟，使用一个百分百可靠的机制来检测溢出难道不是更好吗？</p>
<p>我们将探索在ARM Cortex-M33架构上使用MSP Limit和PSP Limit寄存器来检测堆栈溢出。我们将在Renesas DA1469x上进行实现，并查看检测堆栈溢出的实际示例。此外，我们还将查看MSPLIM和PSPLIM功能不足的情况下的补充选项。</p>
<h2 id="table-of-contentstable-of-contents">Table of Contents<a href="#table-of-contents"></a><a hidden class="anchor" aria-hidden="true" href="#table-of-contentstable-of-contents">#</a></h2>
<ul>
<li><a href="#basic-terminology">Basic Terminology</a></li>
<li><a href="#how-does-it-work">How does it work?</a></li>
<li><a href="#implementing-the-limit-registers">Implementing the Limit Registers</a>
<ul>
<li><a href="#initializing-the-msplim-register">Initializing the MSPLIM Register</a></li>
<li><a href="#initializing-the-psplim-register">Initializing the PSPLIM Register</a></li>
<li><a href="#setting-up-the-usagefault_handler">Setting up the UsageFault_Handler</a></li>
<li><a href="#testing-our-implementation">Testing our Implementation</a></li>
</ul>
</li>
<li><a href="#limitations-and-further-improvements">Limitations and Further Improvements</a>
<ul>
<li><a href="#stack-canary">Stack Canary</a></li>
<li><a href="#freertos-buffer-overflow-protection">FreeRTOS Buffer Overflow protection</a></li>
<li><a href="#compiler-enabled-overflow-detection">Compiler Enabled Overflow Detection</a></li>
<li><a href="#gcc-ssp-example">GCC SSP Example</a></li>
</ul>
</li>
<li><a href="#practical-implementations-for-gcc-stack-canaries">Practical implementations for GCC stack Canaries</a></li>
<li><a href="#closing">Closing</a></li>
<li><a href="#references">References</a></li>
</ul>
<h2 id="basic-terminologybasic-terminology">Basic Terminology<a href="#basic-terminology"></a><a hidden class="anchor" aria-hidden="true" href="#basic-terminologybasic-terminology">#</a></h2>
<p>The ARM Cortex-M33 introduced two new stack limit registers, PSPLIM and MSPLIM <a href="#fn:m33-psplim_msplim">1</a>. ARM has included this in its ARMv8 specification, so any processors before this will not have support.</p>
<h2 id="how-does-it-workhow-does-it-work">How does it work?<a href="#how-does-it-work"></a><a hidden class="anchor" aria-hidden="true" href="#how-does-it-workhow-does-it-work">#</a></h2>
<p>这个新特性最妙的地方是它使用起来非常简单，而且可以避免在调试堆栈溢出时进行猜测。</p>
<p>We need to set the PSPLIM, and the MSPLIM registers to the boundary of the stack.
If the MSP == MSPLIM register or the PSP == PSPLIM register, a UsageFault is generated. The UsageFault Status Register <a href="#fn:m33-usfr">2</a> contains a sticky bit in position four to indicate that a stack overflow occurred.</p>
<p>为PSP和MSP提供硬件保护允许操作系统内的灵活性。例如，我们可以在异常和中断期间保护MSP。我们还可以在上下文切换时切换PSPLIM值，以保护每个Task的堆栈。如果你需要关于上下文切换的复习，可以在<a href="2019-10-30-cortex-m-rtos-context-switching.md">这里</a>查看之前的文章。</p>
<p>If no RTOS is present, we can still monitor the MSP, as this will protect your whole application.</p>
<h2 id="implementing-the-limit-registersimplementing-the-limit-registers">Implementing the Limit Registers<a href="#implementing-the-limit-registers"></a><a hidden class="anchor" aria-hidden="true" href="#implementing-the-limit-registersimplementing-the-limit-registers">#</a></h2>
<p>For an implementation example on the DA1469x, you can access this at Renesas’s Github <a href="#fn:ARMV8_Guards">3</a>.</p>
<h3 id="initializing-the-msplim-registerinitializing-the-msplim-register">Initializing the MSPLIM Register<a href="#initializing-the-msplim-register"></a><a hidden class="anchor" aria-hidden="true" href="#initializing-the-msplim-registerinitializing-the-msplim-register">#</a></h3>
<p>We use the MSR instruction to write to these registers, which requires us to be in privileged mode. In this case, we will set the MSP Limit in the Reset_Handler:</p>
<pre><code>Reset_Handler:

        ldr     r0, =__StackLimit
        add     r0, r0, #dg_configMSP_PADDING
        msr     MSPLIM, r0
</code></pre>
<p>Specifically to the DA1469x, we also need to place the same initialization in the Wakeup_Reset_Handler:</p>
<pre><code>Wakeup_Reset_Handler:

    ldr     r0, =__StackLimit
    add     r0, r0, #dg_configMSP_PADDING
    msr     MSPLIM, r0
</code></pre>
<p>DA1469x休眠架构并不适用于所有Cortex-M33架构。初始化后，DA1469x用Wakeup_Reset_Handler替换Reset_Handler来处理Cortex-M33寄存器的恢复。</p>
<p>There are two definitions provided elsewhere in the project. __StackLimit is defined in vector_table_da1469x.S:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-s" data-lang="s"><span style="display:flex;"><span>    .section .stack
</span></span><span style="display:flex;"><span>                    .align  <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>                    .globl  __StackTop
</span></span><span style="display:flex;"><span>                    .globl  __StackLimit
</span></span><span style="display:flex;"><span>    __StackLimit<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                    .space  Stack_Size
</span></span><span style="display:flex;"><span>                    .size   __StackLimit, . <span style="color:#f92672">-</span> __StackLimit
</span></span><span style="display:flex;"><span>    __StackTop<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                    .size   __StackTop, . <span style="color:#f92672">-</span> __StackTop
</span></span></code></pre></div><p>This definition helps us find the stack limit for setting the MSP.</p>
<p>We also added padding to this value. You will find this value in a configuration file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#75715e">#define dg_configMSP_PADDING                    (16)
</span></span></span></code></pre></div><p>When the MSPLIM is equal to the MSP, the UsageFault exception is triggered. The padding is required to enable pushing items to the stack on Exception entry. If we don’t make space for the fault handler, nested exceptions can occur as the MSPLIM register would be continuously exceeded, usually resulting in a LOCKUP.</p>
<p>The alternative would be to use a naked function<a href="#fn:gcc_attributes">4</a>. However, I prefer to add padding as it provides more flexibility in the fault handler and allows for Memfault hooks!</p>
<h3 id="initializing-the-psplim-registerinitializing-the-psplim-register">Initializing the PSPLIM Register<a href="#initializing-the-psplim-register"></a><a hidden class="anchor" aria-hidden="true" href="#initializing-the-psplim-registerinitializing-the-psplim-register">#</a></h3>
<p>On the DA1469x SDK, it makes use of FreeRTOS. The psp is used for each task’s stack so we can set up the PSPLIM register to protect against a task overflow. This implementation is superior to FreeRTOS’s stack overflow check<a href="#fn:1">5</a> for the following reasons:</p>
<ol>
<li>
<p>FreeRTOS only checks the watermark on a context switch. Therefore, if a thread overflows the stack and isn’t yielding, it can corrupt memory, access null pointers, etc.</p>
</li>
<li>
<p>FreeRTOS does not recommend using this feature in production environments because of the context switch overhead<a href="#fn:2">6</a>.</p>
</li>
</ol>
<p>Implementing this is more straightforward. First, we must adjust the PSPLIM during a context switch in FreeRTOS.</p>
<p>In tasks.c we create the following above vTaskSwitchContext:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">vTaskSwitchStackGuard</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">uint32_t</span> end_of_stack_val <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uint32_t</span>)pxCurrentTCB<span style="color:#f92672">-&gt;</span>pxStack;
</span></span><span style="display:flex;"><span>         <span style="color:#a6e22e">__set_PSPLIM</span>( end_of_stack_val);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Next, we add the call immediately after the context switch:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">xPortPendSVHandler</span>( <span style="color:#66d9ef">void</span> ){
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;   bl vTaskSwitchContext               </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;   bl vTaskSwitchStackGuard                        </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>That’s all we need to do for the PSP.</p>
<h3 id="setting-up-the-usagefault_handlersetting-up-the-usagefault_handler">Setting up the UsageFault_Handler<a href="#setting-up-the-usagefault_handler"></a><a hidden class="anchor" aria-hidden="true" href="#setting-up-the-usagefault_handlersetting-up-the-usagefault_handler">#</a></h3>
<p>All that’s left is doing some work in the UsageFault_Handler. We will declare the UsageFault_Handler in exceptions_handler.s and call a separate handler afterward.</p>
<p>First, we declare an application handler:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    __RETAINED_CODE <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">UsageFault_HandlerC</span>(<span style="color:#66d9ef">uint8_t</span> stack_pointer_mask)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">uint16_t</span> usage_fault_status_reg __UNUSED;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>        usage_fault_status_reg <span style="color:#f92672">=</span> (SCB<span style="color:#f92672">-&gt;</span>CFSR <span style="color:#f92672">&amp;</span>         SCB_CFSR_USGFAULTSR_Msk) <span style="color:#f92672">&gt;&gt;</span> SCB_CFSR_USGFAULTSR_Pos;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">hw_watchdog_freeze</span>();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(usage_fault_status_reg <span style="color:#f92672">&amp;</span> (SCB_CFSR_STKOF_Msk <span style="color:#f92672">&gt;&gt;</span> SCB_CFSR_USGFAULTSR_Pos))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>){}
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {}
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Next, let’s add our UsageFault_Handler into the exceptions_handler.S:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-s" data-lang="s"><span style="display:flex;"><span>    <span style="color:#75715e">#if (dg_configCODE_LOCATION == NON_VOLATILE_IS_FLASH)</span>
</span></span><span style="display:flex;"><span>                .section text_retained
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#endif</span>
</span></span><span style="display:flex;"><span>        .align  <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>        .thumb
</span></span><span style="display:flex;"><span>        .thumb_func
</span></span><span style="display:flex;"><span>        .globl  UsageFault_Handler
</span></span><span style="display:flex;"><span>        .type   UsageFault_Handler, %function
</span></span><span style="display:flex;"><span>    UsageFault_Handler<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        ldr     r2,<span style="color:#f92672">=</span>UsageFault_HandlerC
</span></span><span style="display:flex;"><span>        mrs     r1, msp
</span></span><span style="display:flex;"><span>        mrs     r0, MSPLIM
</span></span><span style="display:flex;"><span>        cmp     r0, r1
</span></span><span style="display:flex;"><span>        beq     UsageFault_with_MSP_Overflow
</span></span><span style="display:flex;"><span>        mrs     r1, psp
</span></span><span style="display:flex;"><span>        mrs     r0, PSPLIM
</span></span><span style="display:flex;"><span>        cmp     r0, r1
</span></span><span style="display:flex;"><span>        beq     UsageFault_with_PSP_Overflow
</span></span><span style="display:flex;"><span>        mov     r0, <span style="color:#75715e">#0</span>
</span></span><span style="display:flex;"><span>        bx      r2
</span></span><span style="display:flex;"><span>    UsageFault_with_PSP_Overflow<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        mov     r0, <span style="color:#75715e">#2</span>
</span></span><span style="display:flex;"><span>        bx      r2
</span></span><span style="display:flex;"><span>    UsageFault_with_MSP_Overflow<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        ldr     r1, <span style="color:#f92672">=</span>__StackLimit
</span></span><span style="display:flex;"><span>        msr     MSPLIM, r1
</span></span><span style="display:flex;"><span>        mov     r0, <span style="color:#75715e">#1</span>
</span></span><span style="display:flex;"><span>        bx      r2
</span></span></code></pre></div><p>Since the USFR does not indicate if the psp or the msp caused the fault, I decided to add some detection in assembly. I prefer doing this in assembly to ensure no stack pushes before the application handler call.</p>
<ul>
<li>0 - General UsageFault</li>
<li>1 - MSP Overflow</li>
<li>2 - PSP Overflow (Task Overflow)</li>
</ul>
<p>In this function, we are checking the MSP and the PSP registers against the limit registers. If the MSP matches the MSPLIM register, we restore the MSPLIM to <code>__StackLimit</code> (Removing the padding we placed initially) and then call our application fault handler.</p>
<h3 id="testing-our-implementationtesting-our-implementation">Testing our Implementation<a href="#testing-our-implementation"></a><a hidden class="anchor" aria-hidden="true" href="#testing-our-implementationtesting-our-implementation">#</a></h3>
<p>We need a small piece of code to test the implementation. In our example, there is a macro provided for causing an overflow for the MSP or the PSP:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#75715e">#define TOGGLE_MSP_OVERFLOW (0)     </span><span style="color:#75715e">//0 Creates an application overflow in FreeRTOS task, 1 creates it on the MSP
</span></span></span></code></pre></div><p>When the button is pressed, depending on this macro setting, it calls a recursive function either in interrupt context or in our main task.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_overflow_func</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">test_overflow_func</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_wkup_key_cb</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        BaseType_t need_switch;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Clear the WKUP interrupt flag!!! */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">hw_wkup_reset_interrupt</span>();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#if TOGGLE_MSP_OVERFLOW &gt; 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">test_overflow_func</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">xTaskNotifyFromISR</span>(overFlow_handle, BUTTON_PRESS_NOTIF, eSetBits, <span style="color:#f92672">&amp;</span>need_switch);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">portEND_SWITCHING_ISR</span>(need_switch);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">prvTestOverFlowTask</span>( <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>pvParameters )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">_wkup_init</span>();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>        overFlow_handle <span style="color:#f92672">=</span> <span style="color:#a6e22e">xTaskGetCurrentTaskHandle</span>();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> ( ;; ) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">uint32_t</span> notif;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            * Wait on any of the notification bits, then clear them all
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">xTaskNotifyWait</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0xFFFFFFFF</span>, <span style="color:#f92672">&amp;</span>notif, portMAX_DELAY);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">/* Notified from BLE manager? */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (notif <span style="color:#f92672">&amp;</span> BUTTON_PRESS_NOTIF) {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">test_overflow_func</span>();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>After pressing the button, we should see the UsageFault_HandlerC get called in our application code.</p>
<h2 id="limitations-and-further-improvementslimitations-and-further-improvements">Limitations and Further Improvements<a href="#limitations-and-further-improvements"></a><a hidden class="anchor" aria-hidden="true" href="#limitations-and-further-improvementslimitations-and-further-improvements">#</a></h2>
<p>The MSPLIM and PSPLIM registers will help against most stack overflows. Unfortunately, they do not protect us from local buffers corrupting the stack. We will look at the most common; buffer overflow. A buffer overflow occurs when a fixed buffer is allocated on the stack, and the program starts writing to memory addresses outside this boundary. This results in corrupted data and can even change the return address of a function, causing undesired execution of application code.</p>
<p>There are different ways to handle this condition on other architectures. For example, Zephyr uses the MPU to guard the PSP on each thread. Here, we will discuss stack canaries.</p>
<h3 id="stack-canarystack-canary">Stack Canary<a href="#stack-canary"></a><a hidden class="anchor" aria-hidden="true" href="#stack-canarystack-canary">#</a></h3>
<p>Stack Canaries are widely implemented as a means of code hardening. A function will place a value (canary) on the end of a stack frame and will check the value is intact before it returns. This mechanism protects against buffer overflow attacks, where malicious source code could overflow the buffer to redirect the return address to its function.</p>
<p>This same idea can also be used to guard against buffer overflows in our application.</p>
<h3 id="freertos-buffer-overflow-protectionfreertos-buffer-overflow-protection">FreeRTOS Buffer Overflow protection<a href="#freertos-buffer-overflow-protection"></a><a hidden class="anchor" aria-hidden="true" href="#freertos-buffer-overflow-protectionfreertos-buffer-overflow-protection">#</a></h3>
<p>FreeRTOS implements a means for overflow detection, as discussed in <a href="#initializing-the-psplim-register">Initializing the PSPLIM Register</a>. This uses the concept of a canary, which will periodically check the value during a context switch.</p>
<p>FreeRTOS has two different configurations that follow this concept:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#75715e">#if( ( configCHECK_FOR_STACK_OVERFLOW &gt; 1 ) &amp;&amp; ( portSTACK_GROWTH &lt; 0 ) )
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#define taskCHECK_FOR_STACK_OVERFLOW()                                                              \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        {                                                                                                   \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            const uint32_t * const pulStack = ( uint32_t * ) pxCurrentTCB-&gt;pxStack;                         \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            const uint32_t ulCheckValue = ( uint32_t ) 0xa5a5a5a5;                                          \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                                                                            \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            if( ( pulStack[ 0 ] != ulCheckValue ) ||                                                \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                ( pulStack[ 1 ] != ulCheckValue ) ||                                                \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                ( pulStack[ 2 ] != ulCheckValue ) ||                                                \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                ( pulStack[ 3 ] != ulCheckValue ) )                                             \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            {                                                                                               \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB-&gt;pcTaskName );   \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            }                                                                                               \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#endif </span><span style="color:#75715e">/* #if( configCHECK_FOR_STACK_OVERFLOW &gt; 1 ) */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">/*-----------------------------------------------------------*/</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#if( ( configCHECK_FOR_STACK_OVERFLOW &gt; 1 ) &amp;&amp; ( portSTACK_GROWTH &gt; 0 ) )
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#define taskCHECK_FOR_STACK_OVERFLOW()                                                                                              \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        {                                                                                                                                   \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        int8_t *pcEndOfStack = ( int8_t * ) pxCurrentTCB-&gt;pxEndOfStack;                                                                     \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        static const uint8_t ucExpectedStackBytes[] = { tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,     \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                        tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,     \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                        tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,     \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                        tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,     \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                        tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE };   \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                                                                                                            \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                                                                                                            \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            pcEndOfStack -= sizeof( ucExpectedStackBytes );                                                                                 \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                                                                                                                            \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            </span><span style="color:#75715e">/* Has the extremity of the task stack ever been written over? */</span><span style="color:#75715e">                                                               \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            if( memcmp( ( void * ) pcEndOfStack, ( void * ) ucExpectedStackBytes, sizeof( ucExpectedStackBytes ) ) != 0 )                   \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            {                                                                                                                               \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB-&gt;pcTaskName );                                   \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            }                                                                                                                               \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#endif </span><span style="color:#75715e">/* #if( configCHECK_FOR_STACK_OVERFLOW &gt; 1 ) */</span><span style="color:#75715e">
</span></span></span></code></pre></div><p>Both methods check for an expected value at the end of the stack. If this value is overwritten, then vApplicationStackOverflowHook is called, and the application should record and reset. Unfortunately, the periodicity is non-deterministic, as it relies on a context switch. Periodic checks lead to a race condition when a task doesn’t yield in time. You can test this from the previous example by setting the following:</p>
<pre><code>#define dg_configARMV8_USE_STACK_GUARDS         (0)
#define #define TOGGLE_MSP_OVERFLOW             (0)
</code></pre>
<p>In this example, prvTestOverFlowTask will not yield, so FreeRTOS does not catch this condition.</p>
<h3 id="compiler-enabled-overflow-detectioncompiler-enabled-overflow-detection">Compiler Enabled Overflow Detection<a href="#compiler-enabled-overflow-detection"></a><a hidden class="anchor" aria-hidden="true" href="#compiler-enabled-overflow-detectioncompiler-enabled-overflow-detection">#</a></h3>
<p>Compilers have started enabling SSP (Stack Smashing Protection) libraries. The library options will allow the compiler to use canaries within function calls. We’re going to look at GCC’s implementation<a href="#fn:5">7</a> specifically. GCC provides the following compiler flags:</p>
<ul>
<li>
<p><strong>-fstack-protector</strong>: This includes functions that call <strong>alloca</strong> and functions with buffers larger than or equal to 8 bytes. The guards are initialized when a function is entered and then checked when the function exits.</p>
</li>
<li>
<p><strong>-fstack-protector-strong</strong> - Like -fstack-protector but includes additional functions to be protected — those that have local array definitions, or have references to local frame addresses.</p>
</li>
<li>
<p><strong>-fstack-protector-all</strong>: all functions are protected.</p>
</li>
<li>
<p><strong>-fstack-protector-explicit</strong>: protects those functions which have the stack_protect attribute</p>
</li>
</ul>
<h3 id="gcc-ssp-examplegcc-ssp-example">GCC SSP Example<a href="#gcc-ssp-example"></a><a hidden class="anchor" aria-hidden="true" href="#gcc-ssp-examplegcc-ssp-example">#</a></h3>
<p>Let’s take a look at using the ssp library in GCC. First, let’s add the compiler flag from the previous example: -fstack-protector. The ssp library has two externs that we define as follows.</p>
<pre><code>uint32_t__stack_chk_guard = 0xDEADBEEF;

void __stack_chk_fail(void) { /* will be called if guard/canary gets corrupted */

    __ASM volatile (&quot;cpsid i&quot; : : : &quot;memory&quot;);

    hw_watchdog_freeze();                           // Stop WDOG
    while(1){}
}
</code></pre>
<p>Let’s also add the vulnerability in our application and add it to the prvTestOverFlowTask:</p>
<pre><code>__attribute__((optimize(&quot;O0&quot;))) static uint8_t stack_buffer_test(uint16_t iters)
{
    uint8_t buffer[16];
    uint16_t i;

    for(i = 0; i &lt; iters; i++)
    {
            buffer[i] = 0xaa;
    }

    return buffer[8];
}
</code></pre>
<blockquote>
<p><strong>NOTE:</strong> __stack_chk_guard should be randomized on startup if using ssp for security reasons.</p>
</blockquote>
<p>This function has a fixed buffer to pass a value larger than the local buffer. Let’s add a stack_buffer_test(17) to our task and look at the assembly.</p>
<pre><code>(gdb) disassemble stack_buffer_test
Dump of assembler code for function stack_buffer_test:
   0x0000ccc8 &lt;+0&gt;: push    {r7, lr}
   0x0000ccca &lt;+2&gt;: sub sp, #32
   0x0000cccc &lt;+4&gt;: add r7, sp, #0
   0x0000ccce &lt;+6&gt;: mov r3, r0
   0x0000ccd0 &lt;+8&gt;: strh    r3, [r7, #6]
   0x0000ccd2 &lt;+10&gt;:    ldr r3, [pc, #68]   ; (0xcd18 &lt;stack_buffer_test+80&gt;)
   0x0000ccd4 &lt;+12&gt;:    ldr r3, [r3, #0]
   0x0000ccd6 &lt;+14&gt;:    str r3, [r7, #28]
   0x0000ccd8 &lt;+16&gt;:    mov.w   r3, #0
   0x0000ccdc &lt;+20&gt;:    movs    r3, #0
   0x0000ccde &lt;+22&gt;:    strh    r3, [r7, #10]
   0x0000cce0 &lt;+24&gt;:    b.n 0xccf4 &lt;stack_buffer_test+44&gt;
   0x0000cce2 &lt;+26&gt;:    ldrh    r3, [r7, #10]
   0x0000cce4 &lt;+28&gt;:    adds    r3, #32
   0x0000cce6 &lt;+30&gt;:    add r3, r7
   0x0000cce8 &lt;+32&gt;:    movs    r2, #170    ; 0xaa
   0x0000ccea &lt;+34&gt;:    strb.w  r2, [r3, #-20]
   0x0000ccee &lt;+38&gt;:    ldrh    r3, [r7, #10]
   0x0000ccf0 &lt;+40&gt;:    adds    r3, #1
   0x0000ccf2 &lt;+42&gt;:    strh    r3, [r7, #10]
   0x0000ccf4 &lt;+44&gt;:    ldrh    r2, [r7, #10]
   0x0000ccf6 &lt;+46&gt;:    ldrh    r3, [r7, #6]
   0x0000ccf8 &lt;+48&gt;:    cmp r2, r3
   0x0000ccfa &lt;+50&gt;:    bcc.n   0xcce2 &lt;stack_buffer_test+26&gt;
   0x0000ccfc &lt;+52&gt;:    ldrb    r3, [r7, #20]
   0x0000ccfe &lt;+54&gt;:    ldr r2, [pc, #24]   ; (0xcd18 &lt;stack_buffer_test+80&gt;)
   0x0000cd00 &lt;+56&gt;:    ldr r1, [r2, #0]
   0x0000cd02 &lt;+58&gt;:    ldr r2, [r7, #28]
   0x0000cd04 &lt;+60&gt;:    eors    r1, r2
   0x0000cd06 &lt;+62&gt;:    mov.w   r2, #0
   0x0000cd0a &lt;+66&gt;:    beq.n   0xcd10 &lt;stack_buffer_test+72&gt;
   0x0000cd0c &lt;+68&gt;:    bl  0xcdb0 &lt;__stack_chk_fail&gt;
   0x0000cd10 &lt;+72&gt;:    mov r0, r3
   0x0000cd12 &lt;+74&gt;:    adds    r7, #32
   0x0000cd14 &lt;+76&gt;:    mov sp, r7
   0x0000cd16 &lt;+78&gt;:    pop {r7, pc}
   0x0000cd18 &lt;+80&gt;:    strh    r4, [r6, #44]   ; 0x2c
   0x0000cd1a &lt;+82&gt;:    movs    r0, #0
</code></pre>
<p>Here we can see the compiler loading the canary at the end of the stack frame:</p>
<pre><code>   0x0000ccd2 &lt;+10&gt;:    ldr r3, [pc, #68]   ; (0xcd18 &lt;stack_buffer_test+80&gt;)
   0x0000ccd4 &lt;+12&gt;:    ldr r3, [r3, #0]
   0x0000ccd6 &lt;+14&gt;:    str r3, [r7, #28]

(gdb) x /1a 0xcd18
0xcd18 &lt;stack_buffer_test+80&gt;:  0x200085b4 &lt;__stack_chk_guard&gt;
(gdb) x /1a 0x200085b4
0x200085b4 &lt;__stack_chk_guard&gt;: 0xdeadbeef
</code></pre>
<p>Before return, we can see the function checking the canary at the end of the stack frame and calling __stack_chk_fail if the value is corrupted:</p>
<pre><code>0x0000cd0a &lt;+66&gt;:   beq.n   0xcd10 &lt;stack_buffer_test+72&gt;
0x0000cd0c &lt;+68&gt;:   bl  0xcdb0 &lt;__stack_chk_fail&gt;
</code></pre>
<p>Running the rest of the example should confirm the call of __stack_chk_fail.</p>
<h2 id="practical-implementations-for-gcc-stack-canariespractical-implementations-for-gcc-stack-canaries">Practical implementations for GCC stack Canaries<a href="#practical-implementations-for-gcc-stack-canaries"></a><a hidden class="anchor" aria-hidden="true" href="#practical-implementations-for-gcc-stack-canariespractical-implementations-for-gcc-stack-canaries">#</a></h2>
<p>Implementing the ssp library does provide additional overhead in execution time and code space. A function will add 7 additional instructions to make use of this feature. The developer should weigh these factors when choosing which setting to use in GCC.</p>
<p>My preference would be to develop and test with a stricter setting and more coverage and move to a more relaxed setting when getting closer to production. For example, you could start your development process with -fstack-protector-all, and later relax this to -fstack-protector-strong or -fstack-protector as the code matures.</p>
<h2 id="closingclosing">Closing<a href="#closing"></a><a hidden class="anchor" aria-hidden="true" href="#closingclosing">#</a></h2>
<p>The PSPLIM and the MSPLIM registers are great new features from ARM and a much-needed addition to the architecture. These can also be supplemented with other techniques to fortify your application. We hope you found this helpful, and will be inspired to make use of it in your application. Implementing these features should prevent many development headaches and safeguard your application in the field!</p>
<h2 id="referencesreferences">References<a href="#references"></a><a hidden class="anchor" aria-hidden="true" href="#referencesreferences">#</a></h2>
<ol>
<li>
<p><a href="https://developer.arm.com/documentation/100231/0002/">Cortex M33 MSPLIM PSPLIM TRM</a> <a href="#fnref:m33-psplim_msplim">↩</a></p>
</li>
<li>
<p><a href="https://developer.arm.com/documentation/100235/0004/the-cortex-m33-peripherals/system-control-block/configurable-fault-status-register">Cortex M33 USFR</a> <a href="#fnref:m33-usfr">↩</a></p>
</li>
<li>
<p><a href="https://github.com/dialog-semiconductor/BLE_SDK10_examples/tree/main/features/armv8_stack_overflow_guards">DA1469x Github Example</a> <a href="#fnref:ARMV8_Guards">↩</a></p>
</li>
<li>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.3.0/gcc/Function-Attributes.html#Function-Attributes">GCC Attributes</a> <a href="#fnref:gcc_attributes">↩</a></p>
</li>
<li>
<p><a href="https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/a8a9c3ea3e34c10c6818f654883dac3dbdae12d1/tasks.c#L3052">FreeRTOS Kernel Stack Overflow Check</a> <a href="#fnref:1">↩</a></p>
</li>
<li>
<p><a href="https://www.freertos.org/Stacks-and-stack-overflow-checking.html">FreeRTOS Stack Overflow Check</a> <a href="#fnref:2">↩</a></p>
</li>
<li>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html">GCC Instrumentation Options</a> <a href="#fnref:5">↩</a></p>
</li>
</ol>
<p><img loading="lazy" src="/img/author/jonkurtz.jpg" alt=""  />
 <a href="/authors/jonkurtz">Jon Kurtz</a> is an FAE Connectivity manager at Renesas.<br>
<a href="https://www.linkedin.com/in/jonathankurtz1"></a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://fanyxok.github.io/tags/arm/">ARM</a></li>
      <li><a href="https://fanyxok.github.io/tags/stack-over-flow/">Stack Over Flow</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://fanyxok.github.io/posts/tech/p05-example-of-embedded-cmakelists-files/">
    <span class="title">« Prev</span>
    <br>
    <span>Example of Embedded CMakeLists Files</span>
  </a>
  <a class="next" href="https://fanyxok.github.io/posts/tech/p03-yao-impl/">
    <span class="title">Next »</span>
    <br>
    <span>Yao&#39;s Protocol Impl in MPCFGO</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://fanyxok.github.io">福岚溪森</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
