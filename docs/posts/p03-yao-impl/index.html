<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Yao&#39;s Protocol Impl in MPCFGO | My Website</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Desc Text.">
    <meta name="generator" content="Hugo 0.68.3" />
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    
    
    
      

    

    
    
    <meta property="og:title" content="Yao&#39;s Protocol Impl in MPCFGO" />
<meta property="og:description" content="Desc Text." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://YuXinFan.github.io/posts/p03-yao-impl/" />
<meta property="article:published_time" content="2023-04-28T15:45:15+08:00" />
<meta property="article:modified_time" content="2023-04-28T15:45:15+08:00" />
<meta itemprop="name" content="Yao&#39;s Protocol Impl in MPCFGO">
<meta itemprop="description" content="Desc Text.">
<meta itemprop="datePublished" content="2023-04-28T15:45:15&#43;08:00" />
<meta itemprop="dateModified" content="2023-04-28T15:45:15&#43;08:00" />
<meta itemprop="wordCount" content="1814">



<meta itemprop="keywords" content="first," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Yao&#39;s Protocol Impl in MPCFGO"/>
<meta name="twitter:description" content="Desc Text."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        My Website
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">Yao&#39;s Protocol Impl in MPCFGO</h1>
      
      <p class="tracked">
        By <strong>Me</strong>
      </p>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2023-04-28T15:45:15+08:00">April 28, 2023</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id="yaos-protocol-theory">Yao&rsquo;s Protocol Theory</h1>
<h1 id="impl-yaos-protocol-in-mpcfgo">Impl Yao&rsquo;s Protocol in MPCFGO</h1>
<h2 id="type-struct">Type Struct</h2>
<p>Let&rsquo;s declare a struct to represent a Yao&rsquo;s Protocol variable.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Yshare The label and pointer are stored in a []byte, [0:len-1]byte, is the label, and [len-1]byte is the pointer
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Yshare</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#75715e">// Yshare is a share of l bit, Plaintext is a l-bit number
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Plaintext</span> <span style="color:#a6e22e">pub</span>.<span style="color:#a6e22e">PubNum</span>
	<span style="color:#a6e22e">wValue</span>    [][]<span style="color:#66d9ef">byte</span>    <span style="color:#75715e">// wValue[i] is the i-th bit&#39;s label and pointer, activated
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">wTable</span>    [][<span style="color:#ae81ff">2</span>][]<span style="color:#66d9ef">byte</span> <span style="color:#75715e">// wValue[i][0] is the i-th bit&#39;s label and pointer of value 0, wValue[i][1] of value 1
</span><span style="color:#75715e"></span>}
</code></pre></div><p><code>Yshare</code> contains three fields:</p>
<ul>
<li><code>Plaintext</code>: a <code>pub.PubNum</code> type, which represents an l-bit plaintext number.If this Yshare variable is created from garbler&rsquo;s input, this instance in garbler side should own the correct value of Plaintext. If this Yshare variable is create from evaluator&rsquo;s input, this instance in evaluator side should own the correct value of Plaintext. Otherwise, this instance do not own the correct value but own a unset value that has the same type with the correct value.</li>
<li><code>wValue</code>: a two-dimensional byte slice (<code>[][]byte</code>) representing the label and pointer of each bit in the <code>Plaintext</code>. Specifically, <code>wValue[i]</code> contains the label and pointer of the <code>i</code>-th bit of the plaintext. The label and pointer are stored in a <code>[]byte</code>, where <code>[0:len-1]byte</code> represents the label, and <code>[len-1]byte</code> represents the pointer.</li>
<li><code>wTable</code>: a three-dimensional byte slice (<code>[][2][]byte</code>) representing the label and pointer of each possible value (0 or 1) of each bit in the <code>Plaintext</code>. Specifically, <code>wTable[i][j]</code> contains the label and pointer of the <code>i</code>-th bit of the plaintext when it has value <code>j</code>.</li>
</ul>
<p>The <code>Yshare</code> type is used to represent a share of an l-bit secret, where each bit is shared between multiple parties. The <code>wValue</code> and <code>wTable</code> fields are used to store the shares of each bit and their corresponding labels and pointers.</p>
<p>These are two methods of the <code>Yshare</code> type, <code>New()</code> and <code>NewFrom()</code>, which are used to create new instances of <code>Yshare</code> and return them as a <code>PvtNum</code> type.</p>
<h2 id="new-newfrom">New, NewFrom</h2>
<p>The <code>New()</code> method takes a <code>network.Network</code> type and a <code>pub.PubNum</code> type as inputs, and returns a new <code>Yshare</code> instance as a <code>PvtNum</code> type. If the input network is the server, it generates the shares for the <code>Plaintext</code> using the <code>newYshare()</code> function and sends the length of the <code>Yshare</code> instance to the client. It then sends the label and pointer for each bit of the <code>Plaintext</code> based on the value of each bit. If the input network is not the server, it receives the length of the <code>Yshare</code> instance from the server and then receives the label and pointer for each bit of the <code>Plaintext</code>.</p>
<p>The <code>NewFrom()</code> method takes a <code>network.Network</code> type as an input and returns a new <code>Yshare</code> instance as a <code>PvtNum</code> type. If the input network is the server, it generates a new instance of <code>pub.PubNum</code> with a length specified by the length of the <code>Yshare</code> instance received from the client. It then sends the label and pointer for each bit of the <code>Yshare</code> instance to the client. If the input network is not the server, it receives the <code>Plaintext</code> of the <code>Yshare</code> instance from the server and then receives the label and pointer for each bit of the <code>Yshare</code> instance.</p>
<p>The newYshare function creates a new Yshare object with a specified length.</p>
<p>The wTable field of the Yshare object is initialized as a slice of length length, where each element of the slice is a pair of slices of length config.SymByte+1 bytes. The first slice of each pair is assigned a random byte array of length config.SymByte+1 using the rand_.Read() function. The second slice of each pair is assigned the result of XOR-ing the first slice with a fixed byte array DELTA using the misc.BytesXorBytes() function.</p>
<p>The last byte of each slice in the wTable field is then set to either 0 or 1 based on the result of the randBool() function. If randBool() returns true, the last byte of the first slice is set to 1 and the last byte of the second slice is set to 0. If randBool() returns false, the last byte of the first slice is set to 0 and the last byte of the second slice is set to 1.</p>
<p>Finally, the newYshare function returns the newly created Yshare object.</p>
<h2 id="declassify">Declassify</h2>
<p><code>decode0</code> and <code>decode1</code> are two methods of the <code>Yshare</code> struct that are used to declassify a secret-shared value. Declassification is the process of converting a secret-shared value into a plaintext value that can be used in subsequent computations.</p>
<p><code>decode0</code> is called by the server to declassify a secret-shared value. It computes the declassified value using the wire values received from the client. The method first computes two hashes, <code>h0</code> and <code>h1</code>, of the wire values for each share using a pseudorandom function (PRF). It then checks the least significant bit (LSB) of the wire value to determine which hash value to use to compute the corresponding bit of the declassified value. Finally, it sends the declassified value back to the client.</p>
<p><code>decode1</code> is called by the client to declassify a secret-shared value. It computes the declassified value using the wire values received from the server. The method first receives a table <code>dTable</code> containing the declassified bits computed by the server. For each share, it computes the LSB of the wire value using a PRF and checks it to determine which bit of <code>dTable</code> corresponds to the corresponding bit of the declassified value. Finally, it sends the declassified value back to the server.</p>
<h2 id="basic-gate-evaluation">Basic Gate Evaluation</h2>
<p>This is an implementation of the &ldquo;Eval&rdquo; function in Go. It takes a Bristol circuit, represented by the &ldquo;bc&rdquo; parameter, and a set of input Yshares, represented by the &ldquo;ins&rdquo; parameter, and evaluates the circuit to produce a single output Yshare.</p>
<p>The &ldquo;Eval&rdquo; function performs the evaluation using the provided &ldquo;net&rdquo; parameter, which is a network object that represents the communication channels between the parties involved in the computation. If &ldquo;net.Server&rdquo; is true, then the current party is the garbler, and the function performs the necessary computations to generate garbled gates and sends them to the other party. If &ldquo;net.Server&rdquo; is false, then the current party is the evaluator, and the function waits to receive garbled gates from the garbler, and then evaluates them to produce the final output Yshare.</p>
<p>The implementation uses a set of helper functions to perform the necessary cryptographic operations. For example, the &ldquo;prf.FixedKeyAES.Hash&rdquo; function is used to hash keys, and the &ldquo;misc.BytesXorBytes&rdquo; function is used to perform XOR operations on byte arrays.</p>
<p>The implementation first performs some sanity checks to ensure that the circuit and input Yshares are valid. It then generates garbled gates for each gate in the circuit using the provided input Yshares. The implementation supports four types of gates: AND, EQ, EQW, NOT, and XOR. For each gate type, the implementation performs the necessary cryptographic operations to generate the corresponding garbled gate, and then sends the garbled gates to the other party over the network.</p>
<p>The implementation stores the garbled gates in the &ldquo;gWires&rdquo; array, which is a two-dimensional array of byte arrays. The first dimension corresponds to the output wire of the gate, and the second dimension corresponds to the two possible output values of the gate (0 and 1). The implementation then waits to receive the garbled gate values from the garbler, and uses them to evaluate the garbled circuit to produce the final output Yshare. Finally, the implementation returns the output Yshare.</p>
<h3 id="xor">XOR</h3>
<p>implements an XOR gate using FreeXOR technique. FreeXOR is a technique used to evaluate an XOR gate in a garbled circuit by using only one shared wire instead of two.</p>
<p>The inputs to the XOR gate are the values of the two input wires v.InWire[0] and v.InWire[1]. The values of these wires are retrieved from gWires and stored in the variables lhs and rhs, respectively.</p>
<p>Then, two output wires for the XOR gate are allocated in gWires[v.OutWire][0] and gWires[v.OutWire][1]. The XOR operation is performed on the input wires using misc.BytesXorBytes function and the result is stored in gWires[v.OutWire][0].</p>
<p>Finally, a FreeXOR gate is created using DELTA as the shared wire value and gWires[v.OutWire][0] as the unshared wire value. The result of this FreeXOR operation is stored in gWires[v.OutWire][1].</p>
<p>The result is that gWires[v.OutWire][0] and gWires[v.OutWire][1] now contain the two possible output values of the XOR gate, and these values can be sent to the next gate in the circuit.</p>
<h3 id="and">AND</h3>
<p>The circuit evaluation used here is based on two primitive gates: the FreeXOR gate and the Halfgate. The FreeXOR gate takes two input wires a and b and computes a XOR b, while the Halfgate takes two input wires a and b and computes a AND b. The Halfgate can be implemented using two FreeXOR gates, as shown in the Halfgates construction.</p>
<p>The code uses the following steps to evaluate an AND gate:</p>
<p>It initializes a lookup table gTable with two entries, each of which contains a byte array of length config.SymByte (the size of the symmetric key used in the circuit).
It retrieves the values of the input wires v.InWire[0] and v.InWire[1] from the gWires array, which stores the values of all wires in the circuit.
It computes the key crKeyP by hashing the value of one of the input wires (either rhs[0] or rhs[1]) using a fixed AES key stored in the prf.FixedKeyAES variable. The choice of input wire to hash depends on the value of lhs[0][config.SymByte], which represents the value of the first bit of the other input wire lhs[0].
If rhs[0][config.SymByte] is zero, it computes the entry gTable[0] by hashing the other value of the second input wire rhs[1] using the same AES key, XORing it with crKeyP, and optionally XORing it with the constant DELTA if lhs[0][config.SymByte] is one. If rhs[0][config.SymByte] is one, it computes the entry gTable[0] using the opposite values of the input wires.
It computes the key clKeyP by hashing the value of the input wire lhs[0] using the same fixed AES key. The choice of input wire to hash depends on the value of r, which represents the value of the first bit of the output wire v.OutWire.
It computes the entry gTable[1] by hashing the other value of the input wire lhs[1] using the same AES key, XORing it with clKeyP and rhs[0], and optionally XORing it with DELTA if r is one.
It computes the values of the output wire v.OutWire by XORing clKeyP and crKeyP and storing the result in gWires[v.OutWire][0], and by XORing this result with DELTA and storing the result in gWires[v.OutWire][1].
It sends the two entries of the lookup table gTable[0] and gTable[1] to the other party over the network using the net.Send function.
The code assumes that the gWires array contains the correct values for all wires in the circuit, and that the prf.FixedKeyAES variable contains a fixed AES key that is shared between the two parties.</p>
<h3 id="xor-1">XOR</h3>
<ul class="pa0">
  
   <li class="list di">
     <a href="/tags/first" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">first</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://YuXinFan.github.io" >
    &copy;  My Website 2023 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
