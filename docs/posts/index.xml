<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on My Website</title>
    <link>https://YuXinFan.github.io/posts/</link>
    <description>Recent content in Posts on My Website</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 03 May 2023 23:38:47 +0800</lastBuildDate><atom:link href="https://YuXinFan.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Example of Embedded CMakeLists Files</title>
      <link>https://YuXinFan.github.io/posts/p05-example-of-embedded-cmakelists-files/</link>
      <pubDate>Wed, 03 May 2023 23:38:47 +0800</pubDate>
      
      <guid>https://YuXinFan.github.io/posts/p05-example-of-embedded-cmakelists-files/</guid>
      <description>The most thoroughly commented embedded CMakeLists file January 05, 2023 - CMake Build System Embedded STM32
Many embedded software engineers have had to deal with build systems that are either non cross-platform or a part of the IDE they are using, don&amp;rsquo;t offer easy composability or per-library configuration, provide no testing support or ways to generate or package files without using a third party scripting language.
CMake is a build system that offers solutions to many of those problems and is already well adopted in the world of traditional software development.</description>
    </item>
    
    <item>
      <title>A Guide to Using ARM Stack Limit Registers</title>
      <link>https://YuXinFan.github.io/posts/p04-using-psp-msp-limit-registers-for-stack-overflow/</link>
      <pubDate>Wed, 03 May 2023 14:28:46 +0800</pubDate>
      
      <guid>https://YuXinFan.github.io/posts/p04-using-psp-msp-limit-registers-for-stack-overflow/</guid>
      <description>A Guide to Using ARM Stack Limit Registers 14 Feb 2023 by Jon Kurtz
堆栈溢出一直是开发过程中的一个严重问题。它们经常没有被检测到，并以难以理解的方式出现。我们已经实施了软件机制来保护它们，但这些机制有限，并且仍不能保护所有条件。
随着ARM架构的成熟，使用一个百分百可靠的机制来检测溢出难道不是更好吗？
我们将探索在ARM Cortex-M33架构上使用MSP Limit和PSP Limit寄存器来检测堆栈溢出。我们将在Renesas DA1469x上进行实现，并查看检测堆栈溢出的实际示例。此外，我们还将查看MSPLIM和PSPLIM功能不足的情况下的补充选项。
Table of Contents Basic Terminology How does it work? Implementing the Limit Registers Initializing the MSPLIM Register Initializing the PSPLIM Register Setting up the UsageFault_Handler Testing our Implementation Limitations and Further Improvements Stack Canary FreeRTOS Buffer Overflow protection Compiler Enabled Overflow Detection GCC SSP Example Practical implementations for GCC stack Canaries Closing References Basic Terminology The ARM Cortex-M33 introduced two new stack limit registers, PSPLIM and MSPLIM 1.</description>
    </item>
    
    <item>
      <title>Yao&#39;s Protocol Impl in MPCFGO</title>
      <link>https://YuXinFan.github.io/posts/p03-yao-impl/</link>
      <pubDate>Fri, 28 Apr 2023 15:45:15 +0800</pubDate>
      
      <guid>https://YuXinFan.github.io/posts/p03-yao-impl/</guid>
      <description>Yao&amp;rsquo;s Protocol Theory Impl Yao&amp;rsquo;s Protocol in MPCFGO Type Struct Let&amp;rsquo;s declare a struct to represent a Yao&amp;rsquo;s Protocol variable.
// Yshare The label and pointer are stored in a []byte, [0:len-1]byte, is the label, and [len-1]byte is the pointer type Yshare struct { // Yshare is a share of l bit, Plaintext is a l-bit number Plaintext pub.PubNum wValue [][]byte // wValue[i] is the i-th bit&amp;#39;s label and pointer, activated wTable [][2][]byte // wValue[i][0] is the i-th bit&amp;#39;s label and pointer of value 0, wValue[i][1] of value 1 } Yshare contains three fields:</description>
    </item>
    
    <item>
      <title>ARM Cortex-M RTOS Context Switching</title>
      <link>https://YuXinFan.github.io/posts/p02-cortex-m-context-switching/</link>
      <pubDate>Thu, 27 Apr 2023 21:21:59 +0800</pubDate>
      
      <guid>https://YuXinFan.github.io/posts/p02-cortex-m-context-switching/</guid>
      <description>ARM Cortex-M RTOS Context Switching 30 Oct 2019 by Chris Coleman
Many embedded systems reach a level of complexity where having a basic set of scheduling primitives and ability to run different tasks can be helpful. The operation of switching from one task to another is known as a context switch. A Real Time Operating System (RTOS) will typically provide this functionality. Having a foundational knowledge of how the core of an RTOS works can be a valuable skill set for an embedded engineer to have.</description>
    </item>
    
    <item>
      <title>How to debug a HardFault on an ARM Cortex-M MCU</title>
      <link>https://YuXinFan.github.io/posts/p01-cortex-m-fault/</link>
      <pubDate>Thu, 27 Apr 2023 21:21:59 +0800</pubDate>
      
      <guid>https://YuXinFan.github.io/posts/p01-cortex-m-fault/</guid>
      <description>How to debug a HardFault on an ARM Cortex-M MCU 20 Nov 2019 by Chris Coleman
Faults happen on embedded devices all the time for a variety of reasons – ranging from something as simple as a NULL pointer dereference to something more unexpected like running a faulty code path only when in a zero-g environment on the Tower of Terror in Disneyland1. It’s important for any embedded engineer to understand how to debug and resolve this class of issue quickly.</description>
    </item>
    
    <item>
      <title>IEEE745浮点数表示法</title>
      <link>https://YuXinFan.github.io/posts/ieee745/</link>
      <pubDate>Fri, 22 Jul 2022 10:44:05 +0800</pubDate>
      
      <guid>https://YuXinFan.github.io/posts/ieee745/</guid>
      <description>32-bit 表示一个单精度浮点数 float
$V=(-1)^s \times M \times 2^E$ 32-bit 分为3部分： S, E, M
S: 符号位，1bit，0 表示正数， -1 表示负数 E: 指数位，8bit，取值[-127, 128]. M: 尾数位，23bit，取值[0, $2^{23}-1$]. 指数的底固定为2，指数有正数也有负数，但指数部分没有符号位，取一个中间值，小于中间值的表示负数，等于中间值的表示0，大于中间值的表示正数，中间值的定义如下：Bias=$2^{k-1}$-1, k表示E的bit数。实际的E为E-Bias.
尾数部分隐藏了小数点前的1，实际为1.M。M转换为十进制从高位开始计算： $1+b_{22}\times\frac{1}{2}+b_{21}\times\frac{1}{4}+&amp;hellip;+b_{0}\times\frac{1}{2^{23}}$
规格化的表示，E不是全0，也不是全1，M任意取值
E全为0时，表示+0.0, -0.0和接近0.0的值
E全为1，M全为0时，表示无穷，符号位区分正无穷和负无穷
E全为1，M不全为0时，表示NaN，不是一个数。</description>
    </item>
    
    <item>
      <title>AES对称加密</title>
      <link>https://YuXinFan.github.io/posts/aes/</link>
      <pubDate>Thu, 21 Jul 2022 17:31:28 +0800</pubDate>
      
      <guid>https://YuXinFan.github.io/posts/aes/</guid>
      <description>AES 对称密钥加密中最流行的算法之一, 除加密以外还可以用于构建消息认证码, 伪随机函数等密码工具
AES的区块长度固定为128比特，密钥长度则可以是128，192或256比特
分组密码工作模式 使用同一个区块密码密钥对多于一块的数据进行加密
区块密码自身只能加密长度等于密码区块长度的单块数据，若要加密变长数据，则数据必须先被划分为一些单独的密码块
最后一块数据也需要使用合适填充方式将数据扩展到符合密码块大小的长度
一种工作模式描述了加密每一数据块的过程，并常常使用基于一个通常称为初始化向量的附加输入值以进行随机化，以保证安全。
初始化向量IV 许多工作模式中用于将加密随机化的一个位块，由此即使同样的明文被多次加密也会产生不同的密文，避免了较慢的重新产生密钥的过程。
初始化向量与密钥相比有不同的安全性需求，因此IV通常无须保密，然而在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个IV. 对于CBC和CFB，重用IV会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。 对于OFB和CTR而言，重用IV会导致完全失去安全性。
在CBC模式中，IV在加密时必须是无法预测的. SSL2.0使用的采用上一个消息的最后一块密文作为下一个消息的IV，是不安全的
Padding ECB和CBC需要最后一块在加密前进行填充
在明文的最后填充空字符以使其长度为块长度的整数倍 在数据后添加一个1位，再添加足够的0位直到满足块长度的要求 添加一个值为128的字节（十六进制的80），再以0字节填满最后一个块 向最后一个块填充n个值均为n的字节 密文窃取 等等 常用模式 电子密码本（ECB） 需要加密的消息按照块密码的块大小被分为数个块，并对每个块进行独立加密。
缺点在于同样的明文块会被加密成相同的密文块；它不能很好的隐藏数据模式。在某些场合，这种方法不能提供严格的数据保密性，因此并不推荐用于密码协议中。
易受到重放攻击的影响，因为每个块是以完全相同的方式解密的.
密码块链接（CBC） 每个明文块先与前一个密文块进行异或后，再进行加密. 为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。
主要缺点在于加密过程是串行的，无法被并行化，而且消息必须被填充到块大小的整数倍。在解密时，从两个邻接的密文块中即可得到一个明文块。因此，解密过程可以被并行化.
填充密码块链接（PCBC） 每个明文块先与前一个明文块和密文块进行异或后再进行加密, 互换两个邻接的密文块不会对后续块的解密造成影响
密文反馈（CFB，Cipher feedback） 类似于CBC，可以将块密码变为自同步的流密码；工作过程亦非常相似，CFB的解密过程几乎就是颠倒的CBC的加密过程
输出反馈模式（Output feedback, OFB） 将块密码变成同步的流密码。它产生密钥流的块，然后将其与明文块进行异或，得到密文。 与其它流密码一样，密文中一个位的翻转会使明文中同样位置的位也产生翻转。这种特性使得许多错误校正码，例如奇偶校验位，即使在加密前计算，而在加密后进行校验也可以得出正确结果。 每个使用OFB的输出块与其前面所有的输出块相关，因此不能并行化处理。然而，由于明文和密文只在最终的异或过程中使用，因此可以事先对IV进行加密，最后并行的将明文或密文进行并行的异或处理。
计数器模式（CTR） CTR模式的特征类似于OFB，但它允许在解密时进行随机存取。由于加密和解密过程均可以进行并行处理，CTR适合运用于多处理器的硬件上。
其他 消息认证码（MAC）通常由块密码得到，例如CBC-MAC（英语：CBC-MAC），OMAC（英语：One-key_MAC）和PMAC（英语：PMAC_(cryptography)）。
认证加密也采用块密码作为其中的一部，其同时使用加密和MAC以提供保密性和数据完整性，例如IAPM（英语：IAPM_(mode)），CCM（英语：CCM_mode），CWC（英语：CWC_mode），EAX（英语：EAX_mode），GCM（英语：Galois/Counter_Mode）和OCB（英语：OCB_mode）。</description>
    </item>
    
    <item>
      <title>My First Post</title>
      <link>https://YuXinFan.github.io/posts/my-first-post/</link>
      <pubDate>Tue, 19 Jul 2022 19:03:35 +0800</pubDate>
      
      <guid>https://YuXinFan.github.io/posts/my-first-post/</guid>
      <description>Welcome The first post of hugo
This is a second header The third The fouth Fifty Six? amazing
A math equation: \(c^2 = a^2 + b^2\)
full line equation: $$ e^e = \pi $$
A Table a a b b A complex latex equation $$\begin{array}{cc} a &amp;amp; b \\ c &amp;amp; d \end{array}$$
$$\begin{bmatrix} a &amp;amp; b \newline c &amp;amp; d \end{bmatrix}$$</description>
    </item>
    
    <item>
      <title>Oblivious Transfer and Cyclic Group</title>
      <link>https://YuXinFan.github.io/posts/otandcylicgroup/</link>
      <pubDate>Tue, 19 Jul 2022 19:03:35 +0800</pubDate>
      
      <guid>https://YuXinFan.github.io/posts/otandcylicgroup/</guid>
      <description>Cyclic Group 定义 $$\langle\mathbb{G},q,g \rangle$$
\(\mathbb{G}=\langle \mathbb{Z}_{n}, \cdot \rangle\)
\(\mathbb{Z}_{n} \)是一个集合, {$0$&amp;hellip;$n-1$}.
\(\cdot\)是集合中的运算符.
对\(\mathbb{G}\)中的元素$a$进行$k$次幂运算表示为\(a^{k}=a \cdot a &amp;hellip;\cdot a\), 即$k$个$a$进行$\cdot$运算.
若群$\mathbb{G}$的每一个元素都是$\mathbb{G}$的某一个固定元素$a$的幂，则称$\mathbb{G}$为循环群.
$q$是$\mathbb{G}$的order, $q$的值等于$\mathbb{G}$中元素的个数, 也记为$|\mathbb{G}|$.
$g$是$\mathbb{G}$的generator(生成元), $\mathbb{G}$中的所有元素都能由$g$通过幂运算生成.
由群$\mathbb{G}$, 阶$q$和生成元$g$, 即可定义一个循环群.
如何寻找一个生成元 如果$\mathbb{G}$有素数阶$p$, 则$\mathbb{G}$中除了identity之外的所有元素都是$\mathbb{G}$的生成元.
如果$p$是素数, 则$\mathbb{Z}_{p}^{*}$是阶为$p-1$的循环群.
假设$\mathbb{G}$阶非素数$p$, 可以均匀的从$\mathbb{G}$中采样元素, 直到这个元素是一个生成元.
$\mathbb{G}$的阶$q$有素数因数$\{p_{i}\}^k_{i=1}$, 检查元素$h$是否为生成元
for $i = 1$ to $k$ : if $h^{q/p_{i}}=1$ return &amp;ldquo;$h$ is not a generator&amp;rdquo; return &amp;ldquo;$h$ is a generator&amp;rdquo; $\mathbb{G}$有阶$q$,生成元$g$, 则任意一个元素可以表示为$h=g^{x}$.
当gcd($x,q$)=1时, $h$也是$\mathbb{G}$的一个生成元. Oblivious Transfer from Cyclic Group Reference:
More efficient oblivious transfer and extensions for faster secure computation</description>
    </item>
    
  </channel>
</rss>
